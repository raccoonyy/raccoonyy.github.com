<!DOCTYPE html>
<html lang="ko">
<head>

    <title>DockerCompose로 개발 환경 구성하기</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css?v=841d0b82a7" />

    <meta name="description" content="배포 환경에 Docker를 사용하고 있을 때 개발 환경에서도 Docker를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다. 슬라이드 버전 - https://goo.gl/MquH4r" />
    <link rel="icon" href="/favicon.png" type="image/png" />
    <link rel="canonical" href="https://raccoonyy.github.io/docker-usages-for-dev-environment-setup/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="raccoony&#x27;s cave" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="DockerCompose로 개발 환경 구성하기" />
    <meta property="og:description" content="배포 환경에 Docker를 사용하고 있을 때 개발 환경에서도 Docker를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다. 슬라이드 버전 - https://goo.gl/MquH4r" />
    <meta property="og:url" content="https://raccoonyy.github.io/docker-usages-for-dev-environment-setup/" />
    <meta property="og:image" content="https://raccoonyy.github.io/content/images/2017/02/docker-usages-dev-environment-setup.png" />
    <meta property="article:published_time" content="2021-03-26T11:08:00.000Z" />
    <meta property="article:modified_time" content="2021-03-26T16:04:25.000Z" />
    <meta property="article:tag" content="docker" />
    <meta property="article:tag" content="ghost" />
    <meta property="article:tag" content="docker-compose" />
    <meta property="article:tag" content="개발 환경" />
    
    <meta property="article:publisher" content="https://www.facebook.com/raccoonyy" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="DockerCompose로 개발 환경 구성하기" />
    <meta name="twitter:description" content="배포 환경에 Docker를 사용하고 있을 때 개발 환경에서도 Docker를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다. 슬라이드 버전 - https://goo.gl/MquH4r" />
    <meta name="twitter:url" content="https://raccoonyy.github.io/docker-usages-for-dev-environment-setup/" />
    <meta name="twitter:image" content="https://raccoonyy.github.io/content/images/2017/02/docker-usages-dev-environment-setup.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="raccoony" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="docker, ghost, docker-compose, 개발 환경" />
    <meta name="twitter:site" content="@raccoonyy" />
    <meta property="og:image:width" content="1024" />
    <meta property="og:image:height" content="512" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "raccoony&#x27;s cave",
        "url": "https://raccoonyy.github.io/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://raccoonyy.github.io/favicon.png"
        }
    },
    "author": {
        "@type": "Person",
        "name": "raccoony",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s=250&d=mm&r=x",
            "width": 250,
            "height": 250
        },
        "url": "https://raccoonyy.github.io/author/raccoony/",
        "sameAs": []
    },
    "headline": "DockerCompose로 개발 환경 구성하기",
    "url": "https://raccoonyy.github.io/docker-usages-for-dev-environment-setup/",
    "datePublished": "2021-03-26T11:08:00.000Z",
    "dateModified": "2021-03-26T16:04:25.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://raccoonyy.github.io/content/images/2017/02/docker-usages-dev-environment-setup.png",
        "width": 1024,
        "height": 512
    },
    "keywords": "docker, ghost, docker-compose, 개발 환경",
    "description": "인프런 강의 안내\n이 글의 내용을 인프런 강의\n[https://www.inflearn.com/course/%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88?inst&#x3D;9acd6a2e]\n로 제작하였습니다. 아래 배너를 눌러주세요~\n\n도커 쓸 땐 필수! 도커 컴포즈 - 인프런 | 강의도커를 실제 사용하려다보면 항상 등장하는 도커 컴포즈! 무엇이 좋은지, 어떻게 활용하는지를\n실습과 함께 배울 수 있습니다., 도커 컴포즈, 기본부터 핵심까지!도커를 실제 사용하려다보면 항상 도커 컴포즈가 등장합니다.도커만으로도\n힘겨웠는데 또 뭔가를 배우라고 하니 답답할 수도 있는데요.도커 컴포즈와 함께라면,복잡한 도커 명령어 (X)깔끔한 설정 파일과 간단한 명령어\n(O)‘도커 컴포즈’를 검색했을 때 가장 위에 나타나는 블로그 저자의 직강![사진]블로그 글이 개발 환경 구축에 중점을 두었다면, 이\n강의에서는\n도커 컴포즈의 기본…인프런 [https://bit.ly/inflearn",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://raccoonyy.github.io/"
    }
}
    </script>

    <meta name="generator" content="Ghost 4.1" />
    <link rel="alternate" type="application/rss+xml" title="raccoony&#x27;s cave" href="https://raccoonyy.github.io/rss/" />
    <script defer src="https://unpkg.com/@tryghost/portal@~1.0.0/umd/portal.min.js" data-ghost="https://raccoonyy.github.io/"></script><style> .gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style>
    <meta name="google-site-verification" content="HbTOu4bsFHuaiGTyAv017aq7Z_-DyKGG4Zdf6GAf3Eg" />
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" />
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2370280605121686",
    enable_page_level_ads: true
  });
</script>
<script>var disqus = 'raccoonyscave'</script>
<style>:root {--ghost-accent-color: #FF1A75;}</style>

</head>
<body class="post-template tag-docker tag-ghost-tag tag-docker-compose tag-gaebal-hwangyeong">
<div class="viewport">

    <header id="gh-head" class="gh-head has-cover">
        <nav class="gh-head-inner inner gh-container">

            <div class="gh-head-brand">
                <a class="gh-head-logo" href="https://raccoonyy.github.io">
                        raccoony&#x27;s cave
                </a>
                <a class="gh-burger" role="button">
                    <div class="gh-burger-box">
                        <div class="gh-burger-inner"></div>
                    </div>
                </a>
            </div>
            <div class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="http://raccoonyy.github.io/">Home</a></li>
    <li class="nav-about-me"><a href="https://raccoonyy.github.io/about-me/">About Me</a></li>
    <li class="nav-django"><a href="https://raccoonyy.github.io/tag/django/">Django</a></li>
    <li class="nav-python"><a href="https://raccoonyy.github.io/tag/python/">Python</a></li>
</ul>

            </div>
            <div class="gh-head-actions">
                <div class="gh-social">
                        <a class="gh-social-facebook" href="https://www.facebook.com/raccoonyy" title="Facebook" target="_blank" rel="noopener"><svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M16 0c8.837 0 16 7.163 16 16s-7.163 16-16 16S0 24.837 0 16 7.163 0 16 0zm5.204 4.911h-3.546c-2.103 0-4.443.885-4.443 3.934.01 1.062 0 2.08 0 3.225h-2.433v3.872h2.509v11.147h4.61v-11.22h3.042l.275-3.81h-3.397s.007-1.695 0-2.187c0-1.205 1.253-1.136 1.329-1.136h2.054V4.911z" /></svg></a>
                        <a class="gh-social-twitter" href="https://twitter.com/raccoonyy" title="Twitter" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>
</a>
                </div>

                    <a class="gh-head-button" href="#/portal">Subscribe</a>
            </div>
        </nav>
    </header>

    <main>
        



<article class="article post tag-docker tag-ghost-tag tag-docker-compose tag-gaebal-hwangyeong featured">

    <header class="article-header gh-canvas">

        <section class="article-tag">
            <a href="https://raccoonyy.github.io/tag/docker/">docker</a>
        </section>

        <h1 class="article-title">Docker (Compose) 활용법 - 개발 환경 구성하기</h1>


        <div class="article-byline">
            <section class="article-byline-content">
                <ul class="author-list">
                    <li class="author-list-item">
                        <a href="/author/raccoony/" class="author-avatar">
                            <img class="author-profile-image" src="//www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s&#x3D;250&amp;d&#x3D;mm&amp;r&#x3D;x" alt="raccoony" />
                        </a>
                    </li>
                </ul>
                <div class="article-byline-meta">
                    <h4 class="author-name"><a href="/author/raccoony/">raccoony</a></h4>
                    <div class="byline-meta-content">
                        <time class="byline-meta-date" datetime="2021-03-26">2021년 3월 26일</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 38 min read</span>
                    </div>
                </div>
            </section>
        </div>

        <figure class="article-image">
            <img
                srcset="/content/images/size/w300/2017/02/docker-usages-dev-environment-setup.png 300w,
                        /content/images/size/w600/2017/02/docker-usages-dev-environment-setup.png 600w,
                        /content/images/size/w1000/2017/02/docker-usages-dev-environment-setup.png 1000w,
                        /content/images/size/w2000/2017/02/docker-usages-dev-environment-setup.png 2000w"
                sizes="(min-width: 1400px) 1400px, 92vw"
                src="/content/images/size/w2000/2017/02/docker-usages-dev-environment-setup.png"
                alt="Docker (Compose) 활용법 - 개발 환경 구성하기"
            />
        </figure>
    </header>

    <section class="gh-content gh-canvas">
        <!--kg-card-begin: markdown--><h2 id="">인프런 강의 안내</h2>
<p>이 글의 내용을 <a href="https://www.inflearn.com/course/%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88?inst=9acd6a2e">인프런 강의</a>로 제작하였습니다. 아래 배너를 눌러주세요~</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-bookmark-card kg-card-hascaption"><a class="kg-bookmark-container" href="https://bit.ly/inflearn-docker-compose"><div class="kg-bookmark-content"><div class="kg-bookmark-title">도커 쓸 땐 필수! 도커 컴포즈 - 인프런 | 강의</div><div class="kg-bookmark-description">도커를 실제 사용하려다보면 항상 등장하는 도커 컴포즈! 무엇이 좋은지, 어떻게 활용하는지를 실습과 함께 배울 수 있습니다., 도커 컴포즈, 기본부터 핵심까지!도커를 실제 사용하려다보면 항상 도커 컴포즈가 등장합니다.도커만으로도 힘겨웠는데 또 뭔가를 배우라고 하니 답답할 수도 있는데요.도커 컴포즈와 함께라면,복잡한 도커 명령어 (X)깔끔한 설정 파일과 간단한 명령어 (O)‘도커 컴포즈’를 검색했을 때 가장 위에 나타나는 블로그 저자의 직강![사진]블로그 글이 개발 환경 구축에 중점을 두었다면, 이 강의에서는 도커 컴포즈의 기본…</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://bit.ly/icon-512x512.png"><span class="kg-bookmark-author">인프런</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://cdn.inflearn.com/public/files/courses/326328/71dda384-9c1d-428d-b9ed-65908356e2eb/326328-kor.jpg"></div></a><figcaption>도커 쓸 땐 필수! 도커 컴포즈&nbsp;</figcaption></figure><!--kg-card-begin: markdown--><h2 id="">개정 알림</h2>
<blockquote>
<p>2019-03-20</p>
</blockquote>
<p>이 글의 개정본을 <a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose">도커 컴포즈를 활용하여 완벽한 개발 환경 구성하기</a>에서 읽으실 수 있습니다. 개정본에서는 도커 컴포즈의 최신 버전에 맞춰 필요 없는 설명을 일부 삭제했고, 도커 자체에 대한 설명도 <a href="https://www.44bits.io/ko/post/why-should-i-use-docker-container">왜 굳이 도커를 써야 하나요?</a>로 분리하였습니다.</p>
<!--kg-card-end: markdown--><hr><!--kg-card-begin: markdown--><blockquote>
<p>배포 환경에 도커를 사용하고 있을 때 개발 환경에서도 도커를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다.</p>
</blockquote>
<p><strong>일러두기: 글보다 슬라이드가 편한 분들은 아래 슬라이드를 보시면 되겠습니다.</strong></p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/5adOWwGkwzaw2w" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/raccoonyy/docker-compose-usages" title="Docker compose usages" target="_blank">Docker 활용법 - 개발 환경 구성하기</a> </strong> from <strong><a target="_blank" href="https://www.slideshare.net/raccoonyy">raccoony</a></strong> </div>
<h3 id="20170905">2017-09-05 수정 내역</h3>
<ul>
<li>파이썬용 바이너리 파일(pytest, flake8 등)들의 설치 위치를 수정하여, <a href="./#1103">컨테이너 재생성시 바이너리 파일이 없어지는 문제 수정</a></li>
<li><a href="./#1104">파이썬 로그가 빠릿하게 출력되지 않는 문제 수정</a></li>
</ul>
<h3 id="20170321">2017-03-21 수정 내역</h3>
<ul>
<li>의존 패키지를 하나 추가하더라도 패키지 전체를 다시 설치해야 하는 불편을 없애고자, <a href="./#1102">패키지 관리용 볼륨 설정 내용을 추가</a>했습니다.</li>
</ul>
<hr>
<h1 id="0">0 (사전 학습) 도커가 뭐야?</h1>
<p>아직 도커를 잘 모르는 분께는 <a href="https://subicura.com/">subicura</a>님이 작성하신 연재 글을 추천합니다.</p>
<h3 id="01">0.1 초보를 위한 도커 안내서 시리즈</h3>
<ul>
<li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html">1. 도커란 무엇인가?</a></li>
<li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html">2. 설치하고 컨테이너 실행하기</a></li>
<li><a href="https://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html">3. 이미지 만들고 배포하기</a></li>
</ul>
<h3 id="02">0.2 사족</h3>
<p>subicura님의 안내서로 부족하진 않겠지만 혹시라도 이해를 도울 수 있을까 싶어서,</p>
<p><strong>도커를 프로그래밍에 빗대어 보겠습니다.</strong></p>
<ul>
<li><code>Dockerfile</code>: 서버 구성을 문서화한 것(=<strong>클래스 선언이 들어 있는 파일</strong>)</li>
<li><code>docker build</code>: 도커 이미지 만들기(=<strong>클래스 선언을 애플리케이션에 로드</strong>)</li>
<li><code>docker run</code>의 옵션들: 이미지에 붙이는 장식들(=<strong>인스턴스의 변수들</strong>)</li>
<li><code>docker run</code>: 장식 붙은 이미지를 실제로 실행(=<strong>인스턴스 생성</strong>)</li>
</ul>
<p>이를 그림으로 나타내면 다음과 같습니다.</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/03/docker-like-as-class-and-instance.png" alt="클래스와 인스턴스 생성에 비유해 본 도커" loading="lazy"></p>
<p>프로그래밍에서는 User 클래스를 파일에 적고, 이를 애플리케이션에서 불러와서, name과 id를 할당하고, 새 인스턴스를 만들어 사용하다가, 용도가 다 하면 삭제하겠죠.</p>
<p>마찬가지로, 도커 이미지에 들어갈 내용을 정의하고(<code>Dockerfile</code>), 이미지를 빌드한 다음(<code>docker build</code>), 각종 옵션을 붙여 컨테이너를 실행(<code>docker run</code>)하여 사용하다가, 용도가 다 하면 컨테이너를 삭제한다고 생각하시면 됩니다.</p>
<p>그럼, 더 이상의 자세한 설명은 생략하고 본론으로 넘어가겠습니다.</p>
<hr>
<p>설명을 따라하기 위한 예제 프로젝트는 다음의 깃헙 저장소에서 다운받을 수 있습니다. (Django용과 Express용을 준비했습니다.)</p>
<p><strong>파이썬/Django용 예제 프로젝트</strong></p>
<div class="github-card" data-github="raccoonyy/django-sample-for-docker-compose" data-width="640" data-height="173" data-theme="default"></div>
<script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
<p><strong>노드/Express용 예제 프로젝트</strong></p>
<div class="github-card" data-github="raccoonyy/express-sample-for-docker-compose" data-width="640" data-height="173" data-theme="default"></div>
<script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
<hr>
<h1 id="1dockercompose">1 개발 환경에 docker-compose 적용하기</h1>
<h3 id="11">1.1 개발 환경 구성은 항상 까다롭다</h3>
<p>새 프로젝트를 시작하거나 기존 프로젝트에 참여한 후 가장 먼저 하는 일은 바로, 개발 환경 구성일 겁니다. 파이썬과 Django를 사용하는 프로젝트라면 보통 다음과 같은 과정을 거칩니다.</p>
<pre><code class="language-bash">$ pyenv install (파이썬 버전)
$ pyenv virtualenv (파이썬 버전) (가상환경이름)
(가상환경이름) $ pip install -r requirements.txt
...
</code></pre>
<p>이를 그림으로 나타내면 이렇게 될 텐데요.</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/03/virtualenv3.png" alt="로컬에 개발 환경 구성하기" loading="lazy"></p>
<p>이 구성이 한 번에 되면 좋겠지만,</p>
<ol>
<li>실제로는 패키지 설치가 막힐 때도 있고(SSL, LDAP 관련)</li>
<li>막상 배포를 했더니 개발 환경과 서버 환경이 같지 않아서 문제가 발생하기도 하고</li>
<li>(실수가 있건 없건) 로컬 컴퓨터에 이미 존재하는 파이썬 환경과 꼬이는 경우도 발생</li>
</ol>
<p>합니다.</p>
<p>그런데 배포 환경에서는 다음과 같이 이미 도커를 활용 중이었기에, 이 구성을 개발 환경에서도 그대로 사용할 수는 없을까 생각하게 되었습니다.</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/03/dockerized-production.png" alt="배포 환경에서 사용 중인 도커" loading="lazy"></p>
<h3 id="12">1.2 시도!</h3>
<h4 id="121">1.2.1 도커 이미지 빌드</h4>
<p>먼저, 예제 프로젝트의 루트 디렉터리에서 도커 이미지를 빌드합니다.</p>
<pre><code class="language-bash">$ docker build -t django-sample .
</code></pre>
<p>이렇게 하면 <code>django-sample</code>이라는 이름을 지닌 도커 이미지가 만들어 집니다.</p>
<h4 id="122">1.2.2 앱 컨테이너 실행</h4>
<p>이제 컨테이너를 실행해봅시다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    -p 8000:8000 \
    django-sample \
    ./manage.py runserver 0:8000
</code></pre>
<p>도커의 <code>run</code> 명령은 구조가 다음과 같습니다.</p>
<pre><code>$ docker run [옵션] 이미지이름[:태그] [명령어] [전달인자]
</code></pre>
<p><code>run</code> 명령의 옵션에 익숙치 않은 분들을 위해 간단히 설명을 붙이자면,</p>
<ul>
<li><code>-it</code>: 컨테이너의 표준 입력과 로컬 컴퓨터의 키보드 입력을 연결한다고 생각하면 됩니다.</li>
<li><code>--rm</code>: 컨테이너를 종료할 때 컨테이너를 삭제합니다.</li>
<li><code>-p</code>: 컨테이너 외부와 내부를 연결할 포트입니다.</li>
<li><code>django-sample</code>: 실행할 이미지 이름입니다.</li>
<li><code>./manage.py runserver 0:8000</code>: 개발 서버 실행용 명령어입니다.</li>
</ul>
<p>이 명령은 실행이 되는 듯 하다가 데이터베이스를 찾지 못해 오류가 발생합니다. 그럼 데이터베이스 서버를 실행해 보죠.</p>
<h4 id="123">1.2.3 데이터베이스 컨테이너 실행</h4>
<p>데이터베이스 서버도 도커로 실행할 수 있습니다. 터미널 창을 하나 더 열고 다음 명령을 입력해보세요.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    postgres:9.6.1
</code></pre>
<p>데이터베이스 서버가 실행되었지만 앱 개발 서버는 여전히 동작하지 않을 겁니다.</p>
<h3 id="13">1.3 이제 동작하지 않는 원인을 살펴봅시다</h3>
<h4 id="131postgresql">1.3.1 앱 컨테이너가 PostgreSQL 컨테이너를 못 찾음</h4>
<p>조금 전에는, 앱 컨테이너를 실행한 후 PostgreSQL 컨테이너를 실행했습니다. 그런데 컨테이너는 실행 직후부터 컨테이너 외부의 상황과 격리됩니다. 따라서 PostgreSQL 컨테이너가 실행되었는지 알지 못하죠.</p>
<p>이를 위해 1. PostgreSQL 컨테이너를 먼저 실행하고, 2. PostgreSQL 컨테이너를 실행할 때 컨테이너 이름을 붙이면(<code>db</code>라고 하죠), 3. 앱 컨테이너에서는 <code>db</code>라는 이름으로 접근할 수 있습니다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    postgres:9.6.1
</code></pre>
<ul>
<li><code>--name</code>: postgres 컨테이너에 <code>db</code>이라는 이름을 부여하였습니다.</li>
<li><code>-e</code>: 환경변수를 설정하여 컨테이너를 실행할 수 있습니다. 여기서는 컨테이너 시작과 함께 djangosample 데이터베이스를 만들고(<code>POSTGRES_DB</code>) sampleuser라는 사용자에게 접속 권한을 부여(<code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code>)합니다. (<a href="https://hub.docker.com/_/postgres/">도커 허브의 공식 postgres 저장소</a>에 가보면 설정할 수 있는 환경 변수 종류를 알 수 있습니다.)</li>
</ul>
<p>이제 앱 컨테이너에서 <code>db</code>라는 이름을 사용하여 PostgreSQL 컨테이너에 접근할 수 있습니다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    django-sample \
    ./manage.py runserver 0:8000
</code></pre>
<ul>
<li><code>--link</code>: 참조할 다른 컨테이너를 선언합니다.</li>
</ul>
<p>이제 두 번째 문제로 넘어가 보죠.</p>
<h4 id="132">1.3.2 앱 코드를 수정해도, 컨테이너 속 파일에는 반영되지 않음</h4>
<p>컨테이너는 실행 직후부터 컨테이너 외부의 상황과 격리됩니다. 하지만 개발할 때는 보통 앱 코드를 수시로 바꾸고 개발 서버도 이를 감지하여 서버를 재시작합니다.</p>
<p>이를 해결하고자 격리된 컨테이너에 통로를 하나 만듭니다. 수정할 앱 코드의 디렉터리를 앱 컨테이너 내부로 연결하여, 코드를 바꿀 때마다 컨테이너 속 코드도 바뀌게 해보겠습니다. <kbd>Ctrl</kbd>+<kbd>C</kbd>를 눌러 앱 컨테이너를 종료한 후, 다시 다음 명령어를 실행합니다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    --volume=$(pwd):/app/ \
    django-sample \
    ./manage.py runserver 0:8000
</code></pre>
<ul>
<li><code>--volume</code>: 이 옵션을 사용하여 로컬 디렉터리의 특정 경로를 컨테이너 내부로 마운트할 수 있습니다. (<code>$(pwd)</code>는 명령을 실행하는 현재 디렉터리의 절대 경로입니다.)</li>
</ul>
<p>이제 마지막 문제입니다.</p>
<h4 id="133db">1.3.3 db 컨테이너를 지우면, 데이터베이스 데이터가 사라짐</h4>
<p>앞에서 db 컨테이너를 실행하면서 <code>--rm</code> 옵션을 지정했는데요. 이렇게 하면 db 컨테이너가 종료한 후 삭제되면서 컨테이너 내부에 쌓였던 데이터베이스 데이터들도 모두 사라집니다. 깔끔해서 좋긴 하지만 간혹 데이터베이스에 데이터를 남겨두면서 작업을 진행할 필요도 생기는데 말이죠.</p>
<p>이 역시 <code>--volume</code> 옵션을 사용하면 해결할 수 있습니다. db 컨테이너가 실행 중인 터미널에서 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 눌러 컨테이너를 종료한 후, 다음 명령으로 다시 실행합시다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    --volume=$(pwd)/docker/data:/var/lib/postgresql/data \
    postgres:9.6.1
</code></pre>
<ul>
<li><code>--volume</code>: 데이터베이스 데이터가 저장되는 컨테이너 내부의 디렉터리인 <code>/var/lib/postgresql/data</code>를 로컬 컴퓨터의 디렉터리(<code>$(pwd)/docker/data</code>)로 연결하면, 컨테이너 삭제와 상관 없이 데이터를 유지할 수 있습니다.</li>
</ul>
<h3 id="14">1.4 재도전!</h3>
<p>이제 도커의 <code>run</code> 명령어는 모두 완성된 것 같으니, 모든 컨테이너를 종료한 후 다음과 같은 순서를 따라 컨테이너들을 재시작해봅시다.</p>
<h4 id="141db">1.4.1 이번엔 db 컨테이너부터 실행</h4>
<pre><code class="language-bash">$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    --volume=$(pwd)/docker/data:/var/lib/postgresql/data \
    postgres:9.6.1
</code></pre>
<h4 id="142">1.4.2 앱 이미지 빌드</h4>
<pre><code class="language-bash">$ docker build -t django-sample .
</code></pre>
<h4 id="143">1.4.3 앱 컨테이너 실행</h4>
<pre><code class="language-bash">$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    --volume=$(pwd):/app/ \
    django-sample \
    ./manage.py runserver 0:8000
</code></pre>
<p>브라우저에서 <a href="http://127.0.0.1:8000">http://127.0.0.1:8000</a>을 열어보면 드디어 Django의 초기 화면을 만날 수 있습니다!</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/03/django-it-worked.png" alt="" loading="lazy"></p>
<p>지금까지의 구성을 그림으로 그려보면 배포 환경과 거의 비슷해지겠죠.</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/03/docker-native-develoment-environment2.png" alt="도커를 활용한 개발 환경 구성 - 첫 시도" loading="lazy"></p>
<h3 id="15">1.5 도커 방식의 불편함</h3>
<p>도커로 개발 환경을 구성하는 데 성공하긴 했지만, 이번엔 다른 불편이 발생했습니다.</p>
<h4 id="151">1.5.1 장황한 옵션</h4>
<p>첫 번째는 서버를 실행할 때마다 옵션을 적기가 귀찮습니다. 헷갈리기도 하고, 빼먹는 경우도 생깁니다. 그래서 옵션들을 미리 적어둘 수는 없을까 고민하게 되었습니다.</p>
<h4 id="152db">1.5.2 앱 컨테이너와 db 컨테이너의 실행 순서</h4>
<p>반드시 db 컨테이너를 실행한 다음에야 앱 컨테이너를 실행해야 합니다. 그렇지 않으면 앱 컨테이너에서 db 컨테이너를 찾을 수 없기 때문이죠.</p>
<h3 id="16">1.6 도커 컴포즈</h3>
<p>그때 <a href="https://docs.docker.com/compose/">도커 컴포즈(Docker Compose)</a>를 사용해 볼 마음이 생겼습니다. 컴포즈는 컨테이너 여럿을 띄우는 도커 애플리케이션을 정의하고 실행하는 도구(Tool for defining and running <strong>multi-container Docker applications</strong>)입니다.</p>
<p>컨테이너 실행에 필요한 옵션을 <code>docker-compose.yml</code>이라는 파일에 적어둘 수 있고, 컨테이너 간 의존성도 관리할 수 있어서 안성맞춤이었지요.</p>
<p>도커와 도커 컴포즈를 비교하면 다음과 같습니다.</p>
<ul>
<li><code>Dockerfile</code> vs. <code>Dockerfile-dev</code>: 서버 구성을 문서화한 것(=<strong>클래스 선언이 들어 있는 파일</strong>)</li>
<li><code>docker build</code> vs. <code>docker-compose build</code>: 도커 이미지 만들기(=<strong>클래스 선언을 애플리케이션에 로드</strong>)</li>
<li><code>docker run</code>의 옵션들 vs. <code>docker-compose.yml</code>: 이미지에 붙이는 장식들(=<strong>인스턴스의 변수들</strong>)</li>
<li><code>docker run</code> vs. <code>docker-compose up</code>: 장식 붙은 이미지를 실제로 실행(=<strong>인스턴스 생성</strong>)</li>
</ul>
<p>도커 컴포즈에서는 컨테이너 실행에 사용되는 옵션과 컨테이너 간 의존성을 모두 <code>docker-compose.yml</code>파일에 적어두고, 컴포즈용 명령어를 사용하여 컨테이너들을 실행, 관리합니다.</p>
<p>클래스와 인스턴스의 예를 들면, 어떤 인스턴스를 자주 생성해야 해서 필요한 변수를 딕셔너리로 저장해두는 것과 비슷하겠습니다. 이를 그림으로 나타내면 다음과 같습니다.</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/03/docker-compose-yml.png" alt="" loading="lazy"></p>
<h3 id="161">1.6.1 선행 조건</h3>
<p>이후의 예시를 따라하려면 도커 엔진의 버전이 1.12.0 이상이어야 하고, docker-compose의 버전은 1.6.0 이상이어야 합니다. 최근에 도커를 설치했다면 큰 문제가 없을 겁니다.</p>
<pre><code class="language-bash">$ docker version
Client:
 Version:      1.13.1
 API version:  1.26
 Go version:   go1.7.5
 Git commit:   092cba3
 Built:
 OS/Arch:      darwin/amd64

Server:
 Version:      1.13.1
 API version:  1.26 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   092cba3
 Built:        Wed Feb  8 08:47:51 2017
 OS/Arch:      linux/amd64
 Experimental: true
$ docker-compose version
docker-compose version 1.11.1, build 7c5d5e4
docker-py version: 2.0.2
CPython version: 2.7.12
OpenSSL version: OpenSSL 1.0.2j  26 Sep 2016
</code></pre>
<p>이 조건이 만족했다면 이제 <code>docker-compose.yml</code> 파일을 만들어 봅시다.</p>
<h3 id="17dockercomposeyml">1.7 docker-compose.yml</h3>
<p><code>docker-compose.yml</code>은 옵션을 미리 정의한 문서라고 볼 수 있습니다. 프로젝트 루트에 파일을 만들고, 다음 내용을 붙여 넣습니다. (<a href="https://gist.github.com/raccoonyy/2db75b86f73bc0b337a0c2c3f94709a1/79fe204485726b37ce73486fc93d73cef1b55004">gist 링크</a>)</p>
<pre><code class="language-yaml">version: '2.1'

services:
  db:
    image: postgres:9.6.1
    volumes:
      - ./docker/data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: &quot;pg_isready -h localhost -p 5432 -q -U postgres&quot;
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - &quot;8000:8000&quot;
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      - ./:/app/
</code></pre>
<p>이제 파일의 윗부분부터 한 줄씩 살펴봅시다.</p>
<h4 id="171version">1.7.1 version</h4>
<pre><code>version: '2.1'
</code></pre>
<p><code>docker run</code>에서는 없었던 부분입니다. <code>docker-compose.yml</code> 파일의 제일 윗부분에는 파일 규격 버전을 적습니다. 파일의 규격에 따라 지원하는 옵션이 달라지며, 최근에 &quot;3.1&quot;이 등장하긴 했지만 보통은 &quot;2&quot;나 &quot;2.1&quot;을 사용해도 충분합니다. (파일 규격 버전에 따른 자세한 내용은 <a href="https://docs.docker.com/compose/compose-file/compose-versioning/">compose 파일의 버전과 호환성을 안내한 공식 문서</a>를 참고하세요.)</p>
<p>여기서는 2.1 버전을 사용합니다.</p>
<h4 id="172services">1.7.2 services</h4>
<pre><code>services:
</code></pre>
<p>이 항목 밑에 실행하려는 서비스들을 정의합니다. 서비스란, 앱 컨테이너나 postgres 컨테이너 각각의 묶음입니다.</p>
<h4 id="173db">1.7.3 db</h4>
<pre><code>  db:
</code></pre>
<p>postgres 서비스의 이름을 <code>db</code>로 정하였습니다.</p>
<h4 id="174image">1.7.4 image</h4>
<pre><code>    image: postgres:9.6.1
</code></pre>
<p><code>db</code> 서비스에서 사용할 도커 이미지를 적습니다. 여기서는 <a href="https://hub.docker.com/_/postgres/">dockerhub의 공식 postgres:9.6.1 이미지</a>를 사용하였습니다.</p>
<h4 id="175volumes">1.7.5 volumes</h4>
<pre><code>    volumes:
      - ./docker/data:/var/lib/postgresql/data
</code></pre>
<p><code>docker run</code>으로 앱 컨테이너를 실행할 때 <code>--volume</code> 옵션을 사용하여 데이터베이스의 데이터를 로컬 컴퓨터에 저장했던 부분과 같습니다. 다만 <code>docker-compose.yml</code>의 <code>volumes</code>에는 상대 경로를 지정할 수 있다는 점이 다릅니다.</p>
<p><code>docker run</code>으로 앱 컨테이너를 실행할 때와 마찬가지로, 프로젝트 루트 아래의 <code>docker/data</code> 디렉터리에 데이터를 저장하기로 했습니다.</p>
<h4 id="176environment">1.7.6 environment</h4>
<pre><code>    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
</code></pre>
<p><code>docker run</code>에서 <code>-e</code> 옵션에 적었던 내용들입니다. 마지막의 <code>POSTGRES_INITDB_ARGS</code> 부분이 추가되었는데, 데이터베이스 서버의 인코딩을 설정하기 위함입니다.</p>
<h4 id="177healthcheck">1.7.7 healthcheck</h4>
<pre><code>    healthcheck:
      test: &quot;pg_isready -h localhost -p 5432 -q -U postgres&quot;
      interval: 3s
      timeout: 1s
      retries: 10
</code></pre>
<p>혹시 손이 빠른 분들 중에는, 앞서 <code>docker run</code> 명령으로 앱 컨테이너를 띄울 때 개발 서버가 데이터베이스 서버에 접속하지 못하는 오류를 접하신 분들도 계실지 모르겠습니다. postgres 컨테이너가 실행 중인데도 말이죠.</p>
<p>이는 postgres 컨테이너가 처음 실행되면서 데이터베이스나 사용자가 미처 생성되기 전에, 앱 컨테이너가 데이터베이스에 접근하려고 시도하기 때문입니다. 컴포즈에서도 마찬가지 문제가 발생하게 되는데요. 따라서 postgres 서비스가 제대로 실행될 뿐만 아니라 데이터베이스에 접근할 수 있는지도 파악을 해야 합니다.</p>
<p><code>healthcheck</code>는 바로 이것을 제어할 수 있습니다. 검사에 사용할 명령(<code>test</code>)을 3초 간격(<code>interval</code>)으로 열 번 시도(<code>retries</code>)하며, 각 시도에서 타임아웃은 1초(<code>timeout</code>)로 지정하였습니다.</p>
<p>여기서 사용한 <code>pg_isready</code> 명령은 데이터베이스 서버에 접근할 수 있는지를 파악합니다. (PostgreSQL 9.3부터 추가된 <code>pg_isready</code> 명령에 대해서는 <a href="https://www.postgresql.org/docs/9.3/static/app-pg-isready.html">PostgreSQL 문서의 pg_isready 부분</a>을 참고하세요.)</p>
<p>조금 장황한 듯 하지만, 앞으로는 이 옵션들을 일일이 타이핑하지 않아도 된다는 점을 생각하며 앱 서비스로 넘어가겠습니다.</p>
<h4 id="178django">1.7.8 django</h4>
<p>앱 서비스의 이름은 <code>django</code>로 지정하였습니다.</p>
<h4 id="179build">1.7.9 build</h4>
<pre><code>    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
</code></pre>
<p>db 서비스와 달리 앱 서비스는 도커 이미지를 빌드할 일이 잦기 때문에, 특정 이미지 대신 <code>build</code> 옵션을 추가합니다.</p>
<p><code>context</code>는 <code>docker build</code> 명령을 실행할 디렉터리 경로라고 보시면 됩니다.</p>
<p><code>dockerfile</code>은 <strong>'개발용' 도커 이미지</strong>를 빌드하는 데 사용할 Dockerfile을 지정하면 되는데요. 배포용 Dockerfile과 어떻게 다른지는 추후 설명하겠습니다.</p>
<h4 id="1710environment">1.7.10 environment</h4>
<pre><code>    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
</code></pre>
<p>환경 변수는 그냥 <code>docker run</code>을 할 때보다 좀더 자세하게 적었습니다. 각 값은 Django 설정 파일(<code>djangosample/settings.py</code>)에서 사용합니다.</p>
<h4 id="1711ports">1.7.11 ports</h4>
<pre><code>    ports:
      - &quot;8000:8000&quot;
</code></pre>
<p>도커 컴포즈로 서비스를 실행하면 기본적으로 가상의 네트워크가 하나 만들어지고, 네트워크 외부의 접근이 막힙니다. (도커 컨테이너가 그렇듯이요.) 따라서 외부에서 접근할 수 있는 포트를 지정해주어야 합니다. 여기서는 Django 개발 서버의 기본 포트는 8000을 지정하였습니다.</p>
<h4 id="1712depends_on">1.7.12 depends_on</h4>
<pre><code>    depends_on:
      db:
        condition: service_healthy
</code></pre>
<p>서비스가 하나 이상일 때, 실행 의존성을 지정할 수 있습니다. 여기서 지정한 내용은, <code>db</code> 서비스가 실행된 후에 <code>django</code> 서비스를 실행하겠다는 의미입니다. <code>contidion</code> 뒤에는 서비스 시작(<code>service_started</code>)이나 서비스 헬스체크 성공(<code>service_healthy</code>)을 지정할 수 있습니다.</p>
<p><code>db</code> 서비스의 <code>healthcheck</code> 부분과 여기서의 <code>service_healthy</code> 부분이 서로 맞물리면, <code>db</code> 서비스에서 데이터베이스 서버 접속이 가능해진 순간 이후에야, <code>django</code> 서비스가 시작합니다.</p>
<blockquote>
<p><code>depend_on</code>에서 <code>condition</code>을 지정하는 방식이 도커 컴포즈 파일 규격 3.0과 3.1에서는 제대로 작동하지 않는다고 합니다.</p>
</blockquote>
<h4 id="1713links">1.7.13 links</h4>
<pre><code>    links:
      - db
</code></pre>
<p><code>docker run</code>에서 <code>--link</code> 옵션에서 지정했던 내용입니다. 앱 컨테이너 안에서 db 서비스를 <code>db</code>라는 이름으로 참조할 수 있습니다.</p>
<h4 id="1714command">1.7.14 command</h4>
<pre><code>    command: /start-dev.sh
</code></pre>
<p><code>docker run</code>으로 앱 컨테이너를 실행할 때 가장 마지막에 적었던 <code>./manage.py runserver 0:8000</code>을 대신할 셀 스크립트 파일을 하나 만들었습니다. 다음은 <code>start-dev.sh</code>의 내용입니다.</p>
<pre><code class="language-bash">#!/bin/sh
python manage.py migrate
python manage.py runserver 0:8000
</code></pre>
<p>Django 마이그레이션을 따로 실행하기가 귀찮아서, 개발 서버 실행에 앞서 넣어두었습니다.</p>
<h4 id="1715volumes">1.7.15 volumes</h4>
<pre><code>    volumes:
      - ./:/app/
</code></pre>
<p><code>docker run</code>으로 앱 컨테이너를 실행할 때 프로젝트 루트 디렉터리를 컨테이너 안에 연결했던 부분과 같습니다.</p>
<p>이렇게 해서 <code>docker-compose.yml</code> 파일을 모두 살펴보았습니다.</p>
<h3 id="18">1.8 드디어 실행!</h3>
<p><code>docker-compose.yml</code>을 모두 작성했다면 드디어 서비스를 실행할 차례입니다.</p>
<pre><code class="language-bash">$ docker-compose up -d
Creating network &quot;djangosample_default&quot; with the default driver
Creating djangosample_db_1
Creating djangosample_django_1
Attaching to djangosample_db_1, djangosample_django_1
db_1          | Initializing database
... (DB 초기화 진행) ...
django_1      | Operations to perform:
django_1      |   Apply all migrations: admin, app, auth, contenttypes, myapp, sessions, sites
django_1      | Running migrations:
... (DB 마이그레이션 진행) ...
</code></pre>
<p><a href="http://127.0.0.1:8000">http://127.0.0.1:8000</a>에 접속해보면 개발 서버가 잘 작동함을 확인할 수 있습니다. 이를 그림으로 나타내면 다음과 같습니다.</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/02/docker-compose-dev-env2.png" alt="" loading="lazy"></p>
<p>각 컨테이너를 실행하던 길고 복잡한 명령어들이 사라졌고, 간단한 명령어 한 줄로 개발 서버와 데이터베이스를 모두 실행하였습니다. 이렇게 해서 개발 서버 구성이 모두 끝났습니다.</p>
<p>그런데 앞에서 개발 서버용 Dockerfile이 따로 존재한다고 말했는데요. 이것 하나만 더 짚고 넘어가겠습니다.</p>
<h3 id="19dockerfilevsdockerfiledev">1.9 Dockerfile vs. Dockerfile-dev</h3>
<p>크게 보자면, 개발 서버에는 필요 없는 내용을 지우고, 개발 서버에만 필요한 내용을 추가하면 됩니다.</p>
<p>먼저, 개발 서버용 Dockerfile-dev에 필요 없는 내용을 살펴보겠습니다.</p>
<pre><code class="language-dockerfile"># 개발 서버용 Dockerfile-dev에서 뺄 부분들

# 앱 코드 복사
ADD ./app/      /app/

# Django 정적 파일 수집
RUN ./manage.py collectstatic --noinput

# 서버 실행 명령
CMD    ['supervisord', '-n']
</code></pre>
<ul>
<li>앱 코드: 앱 코드는 컨테이너 안에 고정하지 않고 로컬 컴퓨터의 디렉터리를 참조하게 했기 때문에, 이 부분은 필요 없습니다. (<code>docker-compose.yml</code>의 <code>volume</code> 부분)</li>
<li>정적 파일: 배포 환경에서 Django는 정적 파일을 직접 서빙하지 않고, nginx나 Apache 등에 맡기는데요. 지금은 개발 서버를 실행하려는 것이므로 이 과정이 필요 없죠.</li>
<li>서버 실행: 한 컨테이너 안에서 Django용 uwsgi와 웹 서비스인 nginx를 실행하고자 프로세스 관리자인 supervisord를 사용하기도 하는데요. 개발 환경에서는 개발 서버만 실행하면 되니까 역시 삭제합니다.</li>
</ul>
<p>그 다음은 개발용 Dockerfile-dev에만 추가하는 내용입니다.</p>
<pre><code class="language-dockerfile"># 개발용 Dockerfile-dev에 추가할 부분들

# 개발 환경 구성에 필요한 파일 복사
COPY ./requirements-dev.txt /app/requirements-dev.txt
RUN  pip install -r requirements-dev.txt

# 개발 서버 실행에 필요한 파일 복사
ADD compose/django/start-dev.sh /start-dev.sh
RUN chmod +x /*.sh
</code></pre>
<ul>
<li><code>requirements-dev.txt</code>: 개발 환경 구성에 사용할 패키지들을 <code>requirements-dev.txt</code>에 정리한 후, 컨테이너에 넣고 설치(<code>pip install -r</code>)합니다.</li>
<li><code>start-dev.sh</code>: 개발 서버 실행용 명령이 들어 있습니다.</li>
</ul>
<p>그래서 최종 <code>Dockerfile-dev</code>의 내용은 다음과 같습니다. (<a href="https://gist.github.com/raccoonyy/3674be1c8f24f6299b1949a92dbe5795">gist 링크</a>)</p>
<pre><code class="language-dockerfile">FROM python:3

RUN \
    apt-get update &amp;&amp;\
    apt-get -y install \
        libpq-dev \
        python-dev

WORKDIR /app

ADD    ./manage.py                    /app/
ADD    ./requirements.txt             /app/
ADD    ./requirements-dev.txt         /app/
RUN    pip install -r requirements.txt
RUN    pip install -r requirements-dev.txt

ADD    compose/django/start-dev.sh    /start-dev.sh
RUN    chmod +x /*.sh
</code></pre>
<h3 id="110">1.10 좀더 개선하기</h3>
<h4 id="1101">1.10.1 데이터베이스 저장소 관리</h4>
<p>아울러, 기존의 <code>docker-compose.yml</code>을 살짝 개선해 보겠습니다. (<a href="https://gist.github.com/raccoonyy/2db75b86f73bc0b337a0c2c3f94709a1">gist 링크</a>)</p>
<pre><code class="language-yaml">version: '2.1'

# 변경 부분!
volumes:
  django_sample_db_dev: {}

services:
  db:
    image: postgres:9.6.1
    volumes:
      # 여기도 변경 부분!
      - django_sample_db_dev:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: &quot;pg_isready -h localhost -p 5432 -U postgres&quot;
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - &quot;8000:8000&quot;
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      # 마지막으로 여기도!
      - ./manage.py:/app/manage.py
      - ./requirements.txt:/app/requirements.txt
      - ./requirements-dev.txt:/app/requirements-dev.txt
      - ./djangosample:/app/djangosample
</code></pre>
<p>모두 volumes와 관련된 부분들인데요.</p>
<p>처음 바뀐 부분에서는 도커가 관리하는 가상의 디스크를 <code>django_sample_db_dev</code>라는 이름으로 만듭니다. 이렇게 만들어진 디스크는 <code>docker volume ls</code> 명령으로 확인할 수 있습니다.</p>
<p>이렇게 만든 가상 디스크를 두 번째 바뀐 부분에서 사용합니다. db 서비스가 로컬 디스크 대신 이 가상 디스크에 데이터를 쌓도록 하였습니다. (이렇게 하면 나중에 서비스를 지울 때 디스크도 함께 지울 수 있습니다.)</p>
<p>마지막 바뀐 부분에서는 프로젝트 루트 전체를 컨테이너 안에 링크하는 대신, 특정 파일이나 폴더만 지정하였습니다. npm으로 노드 모듈을 설치한 경우 프로젝트 루트 밑의 <code>node_modules</code> 디렉터리를 컨테이너 안에서도 참조하게 되는데, 이때 로컬 컴퓨터와 컨테이너 안의 유닉스 환경이 달라서 실행 파일이 제대로 실행되지 않는 문제를 피하기 위함입니다. (물론, 이는 <code>.dockerignore</code> 파일로도 제어할 수 있겠습니다.)</p>
<h4 id="1102">1.10.2 패키지 설치 볼륨 추가</h4>
<p>개발 환경이라는 특성상 의존 패키지를 추가하는 일이 잦은데요. 이때마다 도커 이미지를 새로 빌드하면서 의존 패키지를 전부 다시 설치하는 시간이 조금 낭비처럼 느껴집니다.</p>
<p>이를 개선하고자 앱 컨테이너 내부의 파이썬 패키지가 설치되는 <code>/usr/local/lib/python3.6/site-packages/</code> 디렉터리를 도커 볼륨으로 빼내겠습니다.</p>
<pre><code class="language-yaml">version: '2.1'

volumes:
  django_sample_db_dev: {}
  # 변경 부분!
  django_sample_packages: {}

services:
  db:
    image: postgres:9.6.1
    volumes:
      - django_sample_db_dev:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: &quot;pg_isready -h localhost -p 5432 -U postgres&quot;
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - &quot;8000:8000&quot;
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      - ./manage.py:/app/manage.py
      - ./requirements.txt:/app/requirements.txt
      - ./requirements-dev.txt:/app/requirements-dev.txt
      - ./djangosample:/app/djangosample
      - django_sample_packages:/usr/local/lib/python3.6/site-packages/
</code></pre>
<p>이 볼륨을 활용하려면 <code>Dockerfile-dev</code>와 <code>start-dev.sh</code>도 조금 바꿔야 합니다.</p>
<ul>
<li><code>Dockerfile-dev</code></li>
</ul>
<pre><code class="language-dockerfile">FROM python:3
MAINTAINER raccoony &lt;raccoonyy@gmail.com&gt;

RUN \
    apt-get update &amp;&amp;\
    apt-get -y install \
        libpq-dev \
        python-dev

WORKDIR /app

ADD    ./manage.py                    /app/
# 아래 주석 처리한 부분을 삭제합니다.
# ADD    ./requirements.txt             /app/
# RUN    pip install -r requirements.txt

ADD    compose/django/start-dev.sh       /start-dev.sh
RUN    chmod +x /*.sh
</code></pre>
<ul>
<li><code>start-dev.sh</code></li>
</ul>
<pre><code class="language-bash">#!/bin/sh
# 추가된 부분
pip install -r requirements.txt
python manage.py migrate
gunicorn --workers=3 --bind 0:8000 djangosample.wsgi
</code></pre>
<p>이제 도커 이미지를 새로 만듭니다(<code>docker-compose up --build</code>).</p>
<p>이후부터는 컨테이너가 사라져도 의존 패키지들은 도커 볼륨(<code>django_sample_packages</code>)에 모두 저장되어 있을 겁니다. <code>requirements.txt</code>에 내용을 추가한 후에는 도커 이미지를 빌드할 필요 없이, 컨테이너를 새로 띄우기만 하면(<code>docker-compose up --force-recreate</code>), 추가된 패키지가 설치됩니다.</p>
<h4 id="1103">1.10.3 컨테이너 재생성시 바이너리 파일이 없어지는 문제 수정</h4>
<p>의존 패키지를 재설치하지 않아서 좋아졌지만, 단점이 생겼습니다. 컨테이너만 재생성할 경우 pytest나 flake8 등 이미 설치한 패키지들의 바이너리 파일들이 사라졌음을 확인할 수 있을 겁니다. 이는 pytest나 flake8 패키지를 설치할 때 <code>.py</code> 파일들은 <code>django_sample_packages</code> 볼륨에 설치되지만, 실행 파일들은 <code>/usr/local/bin</code> 디렉터리에 복사되기 때문인데요.</p>
<p>이를 해결하고자 <code>PYTHONUSERBASE</code>와 <code>PATH</code> 환경변수를 추가하고, pip 패키지 설치시 이 환경변수를 사용하게 해보겠습니다.</p>
<p>먼저, <code>Dockerfile-dev</code> 파일에 다음 내용을 추가합니다.</p>
<pre><code class="language-dockerfile">ENV PYTHONUSERBASE=/usr/local/
# 파이썬 버전에 따라 중간 경로인 python3.5 부분이 달라집니다.
ENV PATH=${PYTHONUSERBASE}lib/python3.5/site-packages/bin:${PATH}
</code></pre>
<p>그리고 <code>start-dev.sh</code> 파일의 <code>pip install</code> 부분에 <code>--user</code> 옵션을 추가합니다.</p>
<pre><code class="language-bash">#!/bin/sh
pip install --user -r requirements.txt
python manage.py migrate
gunicorn --workers=3 --bind 0:8000 djangosample.wsgi
</code></pre>
<p>이렇게 하면 파이썬용 바이너리 파일들이 <code>/usr/local/bin</code> 대신 <code>/usr/local/lib/python3.5/site-packages/bin</code>에 설치됩니다. 이 디렉터리는 <code>django_sample_packages</code> 볼륨 속에 위치하기 때문에, 컨테이너가 재생성되더라도 바이너리 파일들이 삭제되지 않습니다.</p>
<h4 id="1104">1.10.4 파이썬 로그가 한 발 느리게 출력되는 문제 수정</h4>
<p>이렇게 사용하다보니 간혹 파이썬 로그가 한 발 늦게 출력된다는 느낌을 받을 때가 있었습니다. 검색을 해보니 파이썬 출력 버퍼링이 기본으로 작동하기 때문이었는데요. 이 버퍼링을 없애려면 <code>PYTHONUNBUFFERED</code> 환경변수를 추가하면 됩니다.</p>
<p><code>Dockerfile-dev</code>에 다음 내용을 추가합니다. (설정할 값은 0이든 1이든 상관 없고, 환경변수가 존재하기만 하면 됩니다.)</p>
<pre><code class="language-dockerfile">ENV PYTHONUNBUFFERED=0
</code></pre>
<p>이렇게 해서 도커 컴포즈로 개발 환경을 어떻게 구성하는지 살펴보았습니다.</p>
<p>이제 docker-compose에서 주로 사용하는 명령어들을 간략하게 훑어보겠습니다.</p>
<hr>
<h3 id="dockercompose">docker-compose의 주요 명령어</h3>
<blockquote>
<p><code>docker-compose</code> 명령어를 짧은 alias로 등록해두면 편리합니다. 저는 oh-my-zsh에서 기본으로 제공하는 <code>dco</code>를 사용하고 있습니다.</p>
</blockquote>
<h4 id="upd">up -d</h4>
<p><code>docker-compose.yml</code> 파일의 내용에 따라 이미지를 빌드하고 서비스를 실행합니다. 자세한 진행 과정은 다음과 같습니다.</p>
<ol>
<li>서비스를 띄울 네트워크 설정</li>
<li>필요한 볼륨 생성</li>
<li>필요한 이미지 pull</li>
<li>필요한 이미지 build</li>
<li>서비스 의존성에 따라 서비스 실행</li>
</ol>
<p><code>up</code> 명령에 사용할 수 있는 몇 가지 옵션도 존재합니다.</p>
<ul>
<li><code>-d</code>: 서비스 실행 후 콘솔로 빠져나옵니다. (<code>docker run</code>에서의 <code>-d</code>와 같습니다.)</li>
<li><code>--force-recreate</code>: 컨테이너를 지우고 새로 만듭니다.</li>
<li><code>--build</code>: 서비스 시작 전 이미지를 새로 만듭니다.</li>
</ul>
<h4 id="ps">ps</h4>
<p>현재 환경에서 실행 중인 서비스를 보여줍니다.</p>
<pre><code class="language-bash">$ docker-compose ps
        Name                       Command               State           Ports
--------------------------------------------------------------------------------
djangosample_db_1       /docker-entrypoint.sh postgres   Up      5432/tcp
djangosample_django_1   /start-dev.sh                    Up      0.0.0.0:8000-&gt;8000/tcp
</code></pre>
<h4 id="stopstart">stop, start</h4>
<p>서비스를 멈추거나, 멈춰 있는 서비스를 시작합니다.</p>
<pre><code class="language-bash">$ docker-compose stop
Stopping djangosample_django_1 ...
Stopping djangosample_db_1 ...

$ docker-compose start
Starting db ... done
Starting django ... done
</code></pre>
<h4 id="down">down</h4>
<p>서비스를 지웁니다. 컨테이너와 네트워크를 삭제하며, 옵션에 따라 볼륨도 지웁니다.</p>
<pre><code class="language-bash">$ docker-compose down --volume
Removing myproject_django_1 ... done
Removing myproject_db_1 ... done
Removing network djangosample_default
Removing volume django_sample_db_dev
</code></pre>
<ul>
<li><code>--volume</code>: 볼륨까지 삭제합니다.</li>
</ul>
<h4 id="exec">exec</h4>
<p>실행 중인 컨테이너에서 명령어를 실행합니다. 자동화된 마이그레이션용 파일 생성이나 유닛 테스트, lint 등을 실행할 때 사용합니다.</p>
<pre><code class="language-bash">$ docker-compose exec django ./manage.py makemigrations
...
</code></pre>
<pre><code class="language-bash">$ docker-compose exec node npm run test
&gt; expresssample@0.1.0 test /www/service
&gt; mocha $(find test -name '*.spec.js')
...
</code></pre>
<blockquote>
<p>비슷한 명령으로 <code>run</code>이 존재합니다. <code>run</code>은 새 컨테이너를 만들어서 명령어를 실행합니다. <code>docker run</code>과 마찬가지로 <code>--rm</code> 옵션을 추가하지 않으면, 컨테이너가 종료된 후에도 삭제되지 않습니다. (이런 이유 때문에 개인적으로는 <code>exec</code>를 선호합니다.)</p>
</blockquote>
<h4 id="logs">logs</h4>
<p>서비스의 로그를 확인할 수 있습니다. <code>logs</code> 뒤에 서비스 이름을 적지 않으면 도커 컴포즈가 관리하는 모든 서비스의 로그를 함께 보여줍니다.</p>
<pre><code class="language-bash">$ docker-compose logs django
Attaching to djangosample_django_1
django_1     | System check identified no issues (0 silenced).
django_1     | February 13, 2017 - 16:32:28
django_1     | Django version 1.10.4, using settings 'djangosample.settings'
django_1     | Starting development server at http://0.0.0.0:8000/
django_1     | Quit the server with CONTROL-C.
</code></pre>
<ul>
<li><code>-f</code>: 지금까지 쌓인 로그를 다 보여준 후에도 셸로 빠져나오지 않고, 로그가 쌓일 때마다 계속해서 출력합니다.</li>
</ul>
<p>마지막으로, 몇 가지 삽질 경험을 바탕으로 나름의 팁을 정리해보겠습니다.</p>
<hr>
<h3 id="">나름의 팁</h3>
<h4 id="1dockercomposeyml">1. docker-compose.yml을 수정했다면?</h4>
<p><code>docker-compose.yml</code> 파일을 수정하고 이를 서비스에 적용하려면 서비스를 멈추고(<code>stop</code>), 서비스를 지우고(<code>rm</code>), 서비스를 시작해야(<code>up</code>) 합니다.</p>
<p>하지만 <code>up</code> 명령만 실행해도, (현재 실행 중인 서비스 설정과 달라진 부분이 있다면) <strong>알아서 컨테이너를 재생성하고 서비스를 재시작</strong>해줍니다.</p>
<pre><code class="language-bash">$ docker-compose up -d [&lt;서비스 이름&gt;]
</code></pre>
<blockquote>
<p>혹시 컨테이너를 재생성하지 않는 것 같다면, <code>--force-recreate</code> 옵션을 붙이면 됩니다.</p>
</blockquote>
<h4 id="2dockerfiledev">2. Dockerfile-dev 파일을 수정했다면?</h4>
<p><code>Dockerfile-dev</code> 파일을 수정했을 땐 <code>build</code> 명령을 사용하여 도커 이미지를 새로 만들어야 합니다. 이후 서비스 중지와 삭제, 재시작을 해야 하죠.</p>
<p>하지만 <code>up</code> 명령에 다음과 같이 <code>--build</code> 옵션을 넣으면 <strong>알아서 이미지를 새로 만들고 서비스를 재시작</strong>합니다.</p>
<pre><code class="language-bash">$ docker-compose up -d --build [&lt;서비스 이름&gt;]
</code></pre>
<h4 id="3dockerfiledev">3. Dockerfile-dev도 신경 써야 함</h4>
<p>개발용 Dockerfile과 배포용 Dockerfile이 따로 존재한다는 점을 꼭 기억해야 합니다. 간혹 <code>Dockerfile</code>만 고치면서 개발 환경에서 **'외않돼?'**라고 생각한 경우가 있습니다. ;;</p>
<p>(<code>Dockerfile</code>에도 다른 <code>Dockerfile</code>을 참조한다는 개념이 있으면 좋을 텐데... 싶습니다.)</p>
<h4 id="4">4. 데이터베이스 내용도 지우고 싶다면</h4>
<p>열심히 개발하다 보면 데이터베이스에 원치 않는 데이터가 남는 경우가 있습니다. 데이터베이스에 접속해서 테이블을 삭제하거나 할 수도 있겠지만, <code>down</code> 명령에 <code>--volume</code> 옵션을 추가하면 서비스에서 사용하는 볼륨(=데이터베이스 데이터가 저장되는 곳)을 삭제하기 때문에, 데이터베이스를 깨끗하게 초기화할 수 있습니다.</p>
<pre><code>$ docker-compose down --volume
</code></pre>
<h4 id="5mysqlpostgresql">5. MySQL보다는 PostgreSQL이 조금 더 편한 듯</h4>
<p>로컬 컴퓨터에 데이터베이스 서버가 없어도, 서비스를 시작하기만 하면 알아서 데이터베이스 서버가 시작된다는 점은 굉장한 매력이었습니다. 그런데 MySQL보다는과 PostgreSQL의 초기화 과정에 걸리는 시간이 꽤 차이가 나더군요.</p>
<p>제 컴퓨터 기준이긴 하지만 MySQL보다는 초기화에는 대략 15초, PostgreSQL 초기화에 대략 5초 남짓한 시간이 걸립니다. 데이터베이스 초기화가 자주 필요한 일은 아니지만 그래도 15초와 5초의 차이는 꽤 크죠.</p>
<blockquote>
<p>아울러, 데이터를 로컬에 쌓기보다는 도커가 관리하는 가상 디스크를 사용하는 편이 속도 면에서 좀더 유리합니다.</p>
</blockquote>
<h4 id="6errornospaceleftondevice">6. <code>ERROR: 'No space left on device'</code></h4>
<p>도커를 열심히 사용하고 있는데 갑자기 다음과 같은 메시지가 뜨면서 새 이미지를 빌드할 수 없다고 하더군요.</p>
<pre><code>ERROR: 'No space left on device'
</code></pre>
<p>하드디스크에 용량이 엄청 많이 남아 있었는데도 말이죠. 부랴부랴 검색을 해보니, Docker for OS X에서 사용하는 가상 파일 시스템의 기본 최대 값이 64기가바이트여서 발생한 문제였습니다.</p>
<p><mark>주의! 다음 내용을 진행하면 도커 이미지와 컨테이너, 볼륨이 모두 사라집니다.</mark></p>
<p>이 경우 Docker for OS X의 환경 설정 <code>Reset</code> 버튼을 누르면 해결됩니다.</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/03/docker-for-os-x-reset2-copy.png" alt="" loading="lazy"></p>
<p><code>Reset</code>하기가 무섭다면, Docker for OS X를 종료한 후 다음 파일을 삭제하고서 Docker for OS X를 실행하면 됩니다.</p>
<p><code>/Users/(LOGIN_ID)/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/Docker.qcow2</code></p>
<p>정확한 위치는 Docker for OS X의 환경 설정에서 Advanced 탭에 들어가 보면 알 수 있습니다.</p>
<p><img src="https://raccoonyy.github.io/content/images/2017/03/docker-for-os-x-location-copy.png" alt="" loading="lazy"></p>
<h4 id="7pyenv23">7. pyenv 없이 파이썬2와 파이썬3을 오갈 수 있음</h4>
<p>회사에서 개발한 라이브러리에 파이썬3 호환성을 추가할 때도 이 방식을 사용해보았습니다. 파이썬3을 로컬 컴퓨터에 설치하지 않고 간단한 <code>docker-compose.yml</code>을 작성하여(사용한 이미지는 도커 공식 저장소의 <code>python:3</code>) 서비스를 띄운 후 테스트를 실행해가며, 호환성이 없는 부분을 찾아내고 수정할 수 있었습니다.</p>
<h4 id="8ghost">8. 로컬에서 Ghost 블로그 운영하기</h4>
<p>자세한 내용은 다음 블로그 글을 참고하세요. :)</p>
<p><strong><a href="https://raccoonyy.github.io/docker-for-ghost-blogging/">Docker 활용법 - Ghost 블로그 운영하기 by raccoony</a></strong></p>
<hr>
<p>이렇게 해서 개발 환경 구성하기를 마쳤습니다. 장황해보이지만, 실제로는 한 번 잘 구성해 두면 다른 프로젝트에는 그저 옮겨 붙이는 정도로 쉽게 적용할 수 있을 겁니다.</p>
<p>마지막으로, 글을 미리 읽고 검토해주신 <a href="https://twitter.com/@nacyo_t">@nacyo_t</a>님께 감사의 마음을 전합니다.</p>
<blockquote>
<p>도커를 배우고 나면<br />모든 것이 컨테이너로 보인다<br>
<small>--raccoony</small></p>
</blockquote>
<!--kg-card-end: markdown-->
    </section>


</article>

<section class="footer-cta">
    <div class="inner">
        <h2>Sign up for more like this.</h2>
        <a class="footer-cta-button" href="#/portal">
            <div>Enter your email</div>
            <span>Subscribe</span>
        </a>
    </div>
</section>


<aside class="read-more-wrap">
    <div class="read-more inner">


                    
<article class="post-card post ">

    <a class="post-card-image-link" href="/geeks-who-invented-click-and-internet/">
        <img class="post-card-image"
            srcset="/content/images/size/w300/2018/03/click.jpg 300w,
                    /content/images/size/w600/2018/03/click.jpg 600w,
                    /content/images/size/w1000/2018/03/click.jpg 1000w,
                    /content/images/size/w2000/2018/03/click.jpg 2000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="/content/images/size/w600/2018/03/click.jpg"
            alt="[독후감] 클릭을 발명한 괴짜들"
            loading="lazy"
        />
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="/geeks-who-invented-click-and-internet/">
            <header class="post-card-header">
                <h2 class="post-card-title">[독후감] 클릭을 발명한 괴짜들</h2>
            </header>
            <section class="post-card-excerpt">
                <p>인터넷 기술이라고 하면 보통은 하드웨어와 소프트웨어를 떠올리기 쉬운데, 이 책은 기술 개발 이야기를 넘어 정보를 저장하고 찾는 기술 그리고 정보를 다루는 기계와 인간이 어떤 관계여야 하는지를 고민했던 사람들의 이야기를 다루고 있습니다. 이런 고민들이 자연스레 인터넷이라는 결과를 낳게 되는 과정이 정말 흥미로웠습니다.</p>
            </section>
        </a>

        <footer class="post-card-meta">
            <ul class="author-list">
                <li class="author-list-item">
                    <a href="/author/raccoony/" class="static-avatar">
                        <img class="author-profile-image" src="//www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s&#x3D;250&amp;d&#x3D;mm&amp;r&#x3D;x" alt="raccoony" />
                    </a>
                </li>
            </ul>
            <div class="post-card-byline-content">
                <span><a href="/author/raccoony/">raccoony</a></span>
                <span class="post-card-byline-date"><time datetime="2018-03-28">2018년 3월 28일</time> <span class="bull">&bull;</span> 8 min read</span>
            </div>
        </footer>

    </div>

</article>
                    
<article class="post-card post ">

    <a class="post-card-image-link" href="/diary-of-changing-job/">
        <img class="post-card-image"
            srcset="/content/images/size/w300/2018/02/man-adjusting-tie.jpg 300w,
                    /content/images/size/w600/2018/02/man-adjusting-tie.jpg 600w,
                    /content/images/size/w1000/2018/02/man-adjusting-tie.jpg 1000w,
                    /content/images/size/w2000/2018/02/man-adjusting-tie.jpg 2000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="/content/images/size/w600/2018/02/man-adjusting-tie.jpg"
            alt="이직 일기"
            loading="lazy"
        />
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="/diary-of-changing-job/">
            <header class="post-card-header">
                <h2 class="post-card-title">이직 일기</h2>
            </header>
            <section class="post-card-excerpt">
                <p>2018년 2월 12일부터 온디맨드코리아 한국 사무실로 출근합니다.</p>
            </section>
        </a>

        <footer class="post-card-meta">
            <ul class="author-list">
                <li class="author-list-item">
                    <a href="/author/raccoony/" class="static-avatar">
                        <img class="author-profile-image" src="//www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s&#x3D;250&amp;d&#x3D;mm&amp;r&#x3D;x" alt="raccoony" />
                    </a>
                </li>
            </ul>
            <div class="post-card-byline-content">
                <span><a href="/author/raccoony/">raccoony</a></span>
                <span class="post-card-byline-date"><time datetime="2018-02-11">2018년 2월 11일</time> <span class="bull">&bull;</span> 18 min read</span>
            </div>
        </footer>

    </div>

</article>
                    
<article class="post-card post ">

    <a class="post-card-image-link" href="/2017-retrospective/">
        <img class="post-card-image"
            srcset="/content/images/size/w300/2018/01/lottetower-1.png 300w,
                    /content/images/size/w600/2018/01/lottetower-1.png 600w,
                    /content/images/size/w1000/2018/01/lottetower-1.png 1000w,
                    /content/images/size/w2000/2018/01/lottetower-1.png 2000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="/content/images/size/w600/2018/01/lottetower-1.png"
            alt="2017년 돌아보기"
            loading="lazy"
        />
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="/2017-retrospective/">
            <header class="post-card-header">
                <h2 class="post-card-title">2017년 돌아보기</h2>
            </header>
            <section class="post-card-excerpt">
                <p>우리나라가 격변을 겪은 것과 관련이 있는지, 저에게도 격변기였던 2017년을 돌아봅니다.</p>
            </section>
        </a>

        <footer class="post-card-meta">
            <ul class="author-list">
                <li class="author-list-item">
                    <a href="/author/raccoony/" class="static-avatar">
                        <img class="author-profile-image" src="//www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s&#x3D;250&amp;d&#x3D;mm&amp;r&#x3D;x" alt="raccoony" />
                    </a>
                </li>
            </ul>
            <div class="post-card-byline-content">
                <span><a href="/author/raccoony/">raccoony</a></span>
                <span class="post-card-byline-date"><time datetime="2018-01-01">2018년 1월 1일</time> <span class="bull">&bull;</span> 14 min read</span>
            </div>
        </footer>

    </div>

</article>

    </div>
</aside>


    </main>

    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="https://raccoonyy.github.io">raccoony&#x27;s cave</a> &copy; 2021</section>
            <nav class="site-footer-nav">
                
            </nav>
            <div><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>

</div>


<script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="/assets/built/casper.js?v=841d0b82a7"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-35614951-4', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
