<!DOCTYPE html>
<html>
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Docker (Compose) 활용법 - 개발 환경 구성하기</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=67668d0519">

    <meta name="description" content="배포 환경에 Docker를 사용하고 있을 때 개발 환경에서도 Docker를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다. 슬라이드 버전 - https://goo.gl/MquH4r">
    <link rel="shortcut icon" href="../favicon.png" type="image/png">
    <link rel="canonical" href="http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="raccoony's cave">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Docker (Compose) 활용법 - 개발 환경 구성하기">
    <meta property="og:description" content="배포 환경에 Docker를 사용하고 있을 때 개발 환경에서도 Docker를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다. 슬라이드 버전 - https://goo.gl/MquH4r">
    <meta property="og:url" content="http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/">
    <meta property="og:image" content="http://raccoonyy.github.io/content/images/2017/02/docker-usages-dev-environment-setup.png">
    <meta property="article:published_time" content="2017-03-13T01:08:00.000Z">
    <meta property="article:modified_time" content="2019-04-09T21:20:48.000Z">
    <meta property="article:tag" content="docker">
    <meta property="article:tag" content="ghost">
    <meta property="article:tag" content="docker-compose">
    <meta property="article:tag" content="개발 환경">
    
    <meta property="article:publisher" content="https://www.facebook.com/raccoonyy">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Docker (Compose) 활용법 - 개발 환경 구성하기">
    <meta name="twitter:description" content="배포 환경에 Docker를 사용하고 있을 때 개발 환경에서도 Docker를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다. 슬라이드 버전 - https://goo.gl/MquH4r">
    <meta name="twitter:url" content="http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/">
    <meta name="twitter:image" content="http://raccoonyy.github.io/content/images/2017/02/docker-usages-dev-environment-setup.png">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="raccoony">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="docker, ghost, docker-compose, 개발 환경">
    <meta name="twitter:site" content="@raccoonyy">
    <meta name="twitter:creator" content="@raccoonyy">
    <meta property="og:image:width" content="1024">
    <meta property="og:image:height" content="512">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "raccoony&#x27;s cave",
        "logo": {
            "@type": "ImageObject",
            "url": "http://raccoonyy.github.io/favicon.png",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "raccoony",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s=250&d=mm&r=x",
            "width": 250,
            "height": 250
        },
        "url": "http://raccoonyy.github.io/author/raccoony/",
        "sameAs": [
            "https://twitter.com/raccoonyy"
        ]
    },
    "headline": "Docker (Compose) 활용법 - 개발 환경 구성하기",
    "url": "http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/",
    "datePublished": "2017-03-13T01:08:00.000Z",
    "dateModified": "2019-04-09T21:20:48.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "http://raccoonyy.github.io/content/images/2017/02/docker-usages-dev-environment-setup.png",
        "width": 1024,
        "height": 512
    },
    "keywords": "docker, ghost, docker-compose, 개발 환경",
    "description": "배포 환경에 Docker를 사용하고 있을 때 개발 환경에서도 Docker를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다. 슬라이드 버전 - https://goo.gl/MquH4r",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://raccoonyy.github.io/"
    }
}
    </script>

    <script src="../public/ghost-sdk.min.js?v=67668d0519"></script>
<script>
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "232a54f78ba4"
});
</script>
    <meta name="generator" content="Ghost 2.19">
    <link rel="alternate" type="application/rss+xml" title="raccoony's cave" href="http://raccoonyy.github.io/rss/">
    <meta name="google-site-verification" content="HbTOu4bsFHuaiGTyAv017aq7Z_-DyKGG4Zdf6GAf3Eg">
<script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2370280605121686",
    enable_page_level_ads: true
  });
</script>
<script>var disqus = 'raccoonyscave'</script>
<style type="text/css">
    @import url(http://fonts.googleapis.com/earlyaccess/kopubbatang.css);
    body {
        font-family: 'KoPub Batang', serif;
        font-weight: 400;
        line-height: 1.8em;
        letter-spacing: -1px;
        text-align: left;
    }
    h1, h2, h3, h4, h5, h6 {
        font-family: sans-serif;
    }
    .post-content a {
        border-bottom: 0px;
        background: linear-gradient(#f26a3d, #f26a3d) no-repeat;
        background-size: 100% 1px;
        background-position: 0 1em;
        font-weight: 700;
        text-shadow: .05em 0 white, -.05em 0 white;
    }
    code, tt {
        background: none;
        border: 0px;
        margin: 0px;
        padding: 0px;
        font-weight: 700;
    }
</style>

</head>
<body class="post-template tag-docker tag-ghost-tag tag-docker-compose tag-gaebal-hwangyeong">

    <div class="site-wrapper">

        

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
                <a class="site-nav-logo" href="http://raccoonyy.github.io">raccoony's cave</a>
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="http://raccoonyy.github.io/">Home</a></li>
    <li class="nav-about-me" role="menuitem"><a href="http://raccoonyy.github.io/about-me/">About Me</a></li>
    <li class="nav-django" role="menuitem"><a href="http://raccoonyy.github.io/tag/django/">Django</a></li>
    <li class="nav-python" role="menuitem"><a href="http://raccoonyy.github.io/tag/python/">Python</a></li>
</ul>

    </div>
    <div class="site-nav-right">
        <div class="social-links">
                <a class="social-link social-link-fb" href="https://www.facebook.com/raccoonyy" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>
</a>
                <a class="social-link social-link-tw" href="https://twitter.com/raccoonyy" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>
</a>
        </div>
            <a class="rss-button" href="https://feedly.com/i/subscription/feed/http://raccoonyy.github.io/rss/" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg>
</a>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post tag-docker tag-ghost-tag tag-docker-compose tag-gaebal-hwangyeong ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="2017-03-13">13 3월 2017</time>
                        <span class="date-divider">/</span> <a href="../tag/docker/index.html">docker</a>
                </section>
                <h1 class="post-full-title">Docker (Compose) 활용법 - 개발 환경 구성하기</h1>
            </header>

            <figure class="post-full-image" style="background-image: url(../content/images/2017/02/docker-usages-dev-environment-setup.png)">
            </figure>

            <section class="post-full-content">
                <!--kg-card-begin: markdown--><h2 id="">개정 알림</h2>
<p>이 글의 개정본을 <a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose">도커 컴포즈를 활용하여 완벽한 개발 환경 구성하기</a>에서 읽으실 수 있습니다. 개정본에서는 도커 컴포즈의 최신 버전에 맞춰 필요 없는 설명을 일부 삭제했고, 도커 자체에 대한 설명도 <a href="https://www.44bits.io/ko/post/why-should-i-use-docker-container">왜 굳이 도커를 써야 하나요?</a>로 분리하였습니다.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><blockquote>
<p>배포 환경에 도커를 사용하고 있을 때 개발 환경에서도 도커를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다.</p>
</blockquote>
<p><strong>일러두기: 글보다 슬라이드가 편한 분들은 아래 슬라이드를 보시면 되겠습니다.</strong></p>
<iframe src="https://www.slideshare.net/slideshow/embed_code/key/5adOWwGkwzaw2w" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/raccoonyy/docker-compose-usages" title="Docker compose usages" target="_blank">Docker 활용법 - 개발 환경 구성하기</a> </strong> from <strong><a target="_blank" href="https://www.slideshare.net/raccoonyy">raccoony</a></strong> </div>
<h3 id="20170905">2017-09-05 수정 내역</h3>
<ul>
<li>파이썬용 바이너리 파일(pytest, flake8 등)들의 설치 위치를 수정하여, <a href="index.html#1103">컨테이너 재생성시 바이너리 파일이 없어지는 문제 수정</a></li>
<li><a href="index.html#1104">파이썬 로그가 빠릿하게 출력되지 않는 문제 수정</a></li>
</ul>
<h3 id="20170321">2017-03-21 수정 내역</h3>
<ul>
<li>의존 패키지를 하나 추가하더라도 패키지 전체를 다시 설치해야 하는 불편을 없애고자, <a href="index.html#1102">패키지 관리용 볼륨 설정 내용을 추가</a>했습니다.</li>
</ul>
<hr>
<h1 id="0">0 (사전 학습) 도커가 뭐야?</h1>
<p>아직 도커를 잘 모르는 분께는 <a href="https://subicura.com/">subicura</a>님이 작성하신 연재 글을 추천합니다.</p>
<h3 id="01">0.1 초보를 위한 도커 안내서 시리즈</h3>
<ul>
<li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html">1. 도커란 무엇인가?</a></li>
<li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html">2. 설치하고 컨테이너 실행하기</a></li>
<li><a href="https://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html">3. 이미지 만들고 배포하기</a></li>
</ul>
<h3 id="02">0.2 사족</h3>
<p>subicura님의 안내서로 부족하진 않겠지만 혹시라도 이해를 도울 수 있을까 싶어서,</p>
<p><strong>도커를 프로그래밍에 빗대어 보겠습니다.</strong></p>
<ul>
<li><code>Dockerfile</code>: 서버 구성을 문서화한 것(=<strong>클래스 선언이 들어 있는 파일</strong>)</li>
<li><code>docker build</code>: 도커 이미지 만들기(=<strong>클래스 선언을 애플리케이션에 로드</strong>)</li>
<li><code>docker run</code>의 옵션들: 이미지에 붙이는 장식들(=<strong>인스턴스의 변수들</strong>)</li>
<li><code>docker run</code>: 장식 붙은 이미지를 실제로 실행(=<strong>인스턴스 생성</strong>)</li>
</ul>
<p>이를 그림으로 나타내면 다음과 같습니다.</p>
<p><img src="../content/images/2017/03/docker-like-as-class-and-instance.png" alt="클래스와 인스턴스 생성에 비유해 본 도커"></p>
<p>프로그래밍에서는 User 클래스를 파일에 적고, 이를 애플리케이션에서 불러와서, name과 id를 할당하고, 새 인스턴스를 만들어 사용하다가, 용도가 다 하면 삭제하겠죠.</p>
<p>마찬가지로, 도커 이미지에 들어갈 내용을 정의하고(<code>Dockerfile</code>), 이미지를 빌드한 다음(<code>docker build</code>), 각종 옵션을 붙여 컨테이너를 실행(<code>docker run</code>)하여 사용하다가, 용도가 다 하면 컨테이너를 삭제한다고 생각하시면 됩니다.</p>
<p>그럼, 더 이상의 자세한 설명은 생략하고 본론으로 넘어가겠습니다.</p>
<hr>
<p>설명을 따라하기 위한 예제 프로젝트는 다음의 깃헙 저장소에서 다운받을 수 있습니다. (Django용과 Express용을 준비했습니다.)</p>
<p><strong>파이썬/Django용 예제 프로젝트</strong></p>
<div class="github-card" data-github="raccoonyy/django-sample-for-docker-compose" data-width="640" data-height="173" data-theme="default"></div>
<script src="http://cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
<p><strong>노드/Express용 예제 프로젝트</strong></p>
<div class="github-card" data-github="raccoonyy/express-sample-for-docker-compose" data-width="640" data-height="173" data-theme="default"></div>
<script src="http://cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
<hr>
<h1 id="1dockercompose">1 개발 환경에 docker-compose 적용하기</h1>
<h3 id="11">1.1 개발 환경 구성은 항상 까다롭다</h3>
<p>새 프로젝트를 시작하거나 기존 프로젝트에 참여한 후 가장 먼저 하는 일은 바로, 개발 환경 구성일 겁니다. 파이썬과 Django를 사용하는 프로젝트라면 보통 다음과 같은 과정을 거칩니다.</p>
<pre><code class="language-bash">$ pyenv install (파이썬 버전)
$ pyenv virtualenv (파이썬 버전) (가상환경이름)
(가상환경이름) $ pip install -r requirements.txt
...
</code></pre>
<p>이를 그림으로 나타내면 이렇게 될 텐데요.</p>
<p><img src="../content/images/2017/03/virtualenv3.png" alt="로컬에 개발 환경 구성하기"></p>
<p>이 구성이 한 번에 되면 좋겠지만,</p>
<ol>
<li>실제로는 패키지 설치가 막힐 때도 있고(SSL, LDAP 관련)</li>
<li>막상 배포를 했더니 개발 환경과 서버 환경이 같지 않아서 문제가 발생하기도 하고</li>
<li>(실수가 있건 없건) 로컬 컴퓨터에 이미 존재하는 파이썬 환경과 꼬이는 경우도 발생</li>
</ol>
<p>합니다.</p>
<p>그런데 배포 환경에서는 다음과 같이 이미 도커를 활용 중이었기에, 이 구성을 개발 환경에서도 그대로 사용할 수는 없을까 생각하게 되었습니다.</p>
<p><img src="../content/images/2017/03/dockerized-production.png" alt="배포 환경에서 사용 중인 도커"></p>
<h3 id="12">1.2 시도!</h3>
<h4 id="121">1.2.1 도커 이미지 빌드</h4>
<p>먼저, 예제 프로젝트의 루트 디렉터리에서 도커 이미지를 빌드합니다.</p>
<pre><code class="language-bash">$ docker build -t django-sample .
</code></pre>
<p>이렇게 하면 <code>django-sample</code>이라는 이름을 지닌 도커 이미지가 만들어 집니다.</p>
<h4 id="122">1.2.2 앱 컨테이너 실행</h4>
<p>이제 컨테이너를 실행해봅시다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    -p 8000:8000 \
    django-sample \
    ./manage.py runserver 0:8000
</code></pre>
<p>도커의 <code>run</code> 명령은 구조가 다음과 같습니다.</p>
<pre><code>$ docker run [옵션] 이미지이름[:태그] [명령어] [전달인자]
</code></pre>
<p><code>run</code> 명령의 옵션에 익숙치 않은 분들을 위해 간단히 설명을 붙이자면,</p>
<ul>
<li><code>-it</code>: 컨테이너의 표준 입력과 로컬 컴퓨터의 키보드 입력을 연결한다고 생각하면 됩니다.</li>
<li><code>--rm</code>: 컨테이너를 종료할 때 컨테이너를 삭제합니다.</li>
<li><code>-p</code>: 컨테이너 외부와 내부를 연결할 포트입니다.</li>
<li><code>django-sample</code>: 실행할 이미지 이름입니다.</li>
<li><code>./manage.py runserver 0:8000</code>: 개발 서버 실행용 명령어입니다.</li>
</ul>
<p>이 명령은 실행이 되는 듯 하다가 데이터베이스를 찾지 못해 오류가 발생합니다. 그럼 데이터베이스 서버를 실행해 보죠.</p>
<h4 id="123">1.2.3 데이터베이스 컨테이너 실행</h4>
<p>데이터베이스 서버도 도커로 실행할 수 있습니다. 터미널 창을 하나 더 열고 다음 명령을 입력해보세요.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    postgres:9.6.1
</code></pre>
<p>데이터베이스 서버가 실행되었지만 앱 개발 서버는 여전히 동작하지 않을 겁니다.</p>
<h3 id="13">1.3 이제 동작하지 않는 원인을 살펴봅시다</h3>
<h4 id="131postgresql">1.3.1 앱 컨테이너가 PostgreSQL 컨테이너를 못 찾음</h4>
<p>조금 전에는, 앱 컨테이너를 실행한 후 PostgreSQL 컨테이너를 실행했습니다. 그런데 컨테이너는 실행 직후부터 컨테이너 외부의 상황과 격리됩니다. 따라서 PostgreSQL 컨테이너가 실행되었는지 알지 못하죠.</p>
<p>이를 위해 1. PostgreSQL 컨테이너를 먼저 실행하고, 2. PostgreSQL 컨테이너를 실행할 때 컨테이너 이름을 붙이면(<code>db</code>라고 하죠), 3. 앱 컨테이너에서는 <code>db</code>라는 이름으로 접근할 수 있습니다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    postgres:9.6.1
</code></pre>
<ul>
<li><code>--name</code>: postgres 컨테이너에 <code>db</code>이라는 이름을 부여하였습니다.</li>
<li><code>-e</code>: 환경변수를 설정하여 컨테이너를 실행할 수 있습니다. 여기서는 컨테이너 시작과 함께 djangosample 데이터베이스를 만들고(<code>POSTGRES_DB</code>) sampleuser라는 사용자에게 접속 권한을 부여(<code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code>)합니다. (<a href="https://hub.docker.com/_/postgres/">도커 허브의 공식 postgres 저장소</a>에 가보면 설정할 수 있는 환경 변수 종류를 알 수 있습니다.)</li>
</ul>
<p>이제 앱 컨테이너에서 <code>db</code>라는 이름을 사용하여 PostgreSQL 컨테이너에 접근할 수 있습니다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    django-sample \
    ./manage.py runserver 0:8000
</code></pre>
<ul>
<li><code>--link</code>: 참조할 다른 컨테이너를 선언합니다.</li>
</ul>
<p>이제 두 번째 문제로 넘어가 보죠.</p>
<h4 id="132">1.3.2 앱 코드를 수정해도, 컨테이너 속 파일에는 반영되지 않음</h4>
<p>컨테이너는 실행 직후부터 컨테이너 외부의 상황과 격리됩니다. 하지만 개발할 때는 보통 앱 코드를 수시로 바꾸고 개발 서버도 이를 감지하여 서버를 재시작합니다.</p>
<p>이를 해결하고자 격리된 컨테이너에 통로를 하나 만듭니다. 수정할 앱 코드의 디렉터리를 앱 컨테이너 내부로 연결하여, 코드를 바꿀 때마다 컨테이너 속 코드도 바뀌게 해보겠습니다. <kbd>Ctrl</kbd>+<kbd>C</kbd>를 눌러 앱 컨테이너를 종료한 후, 다시 다음 명령어를 실행합니다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    --volume=$(pwd):/app/ \
    django-sample \
    ./manage.py runserver 0:8000
</code></pre>
<ul>
<li><code>--volume</code>: 이 옵션을 사용하여 로컬 디렉터리의 특정 경로를 컨테이너 내부로 마운트할 수 있습니다. (<code>$(pwd)</code>는 명령을 실행하는 현재 디렉터리의 절대 경로입니다.)</li>
</ul>
<p>이제 마지막 문제입니다.</p>
<h4 id="133db">1.3.3 db 컨테이너를 지우면, 데이터베이스 데이터가 사라짐</h4>
<p>앞에서 db 컨테이너를 실행하면서 <code>--rm</code> 옵션을 지정했는데요. 이렇게 하면 db 컨테이너가 종료한 후 삭제되면서 컨테이너 내부에 쌓였던 데이터베이스 데이터들도 모두 사라집니다. 깔끔해서 좋긴 하지만 간혹 데이터베이스에 데이터를 남겨두면서 작업을 진행할 필요도 생기는데 말이죠.</p>
<p>이 역시 <code>--volume</code> 옵션을 사용하면 해결할 수 있습니다. db 컨테이너가 실행 중인 터미널에서 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 눌러 컨테이너를 종료한 후, 다음 명령으로 다시 실행합시다.</p>
<pre><code class="language-bash">$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    --volume=$(pwd)/docker/data:/var/lib/postgresql/data \
    postgres:9.6.1
</code></pre>
<ul>
<li><code>--volume</code>: 데이터베이스 데이터가 저장되는 컨테이너 내부의 디렉터리인 <code>/var/lib/postgresql/data</code>를 로컬 컴퓨터의 디렉터리(<code>$(pwd)/docker/data</code>)로 연결하면, 컨테이너 삭제와 상관 없이 데이터를 유지할 수 있습니다.</li>
</ul>
<h3 id="14">1.4 재도전!</h3>
<p>이제 도커의 <code>run</code> 명령어는 모두 완성된 것 같으니, 모든 컨테이너를 종료한 후 다음과 같은 순서를 따라 컨테이너들을 재시작해봅시다.</p>
<h4 id="141db">1.4.1 이번엔 db 컨테이너부터 실행</h4>
<pre><code class="language-bash">$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    --volume=$(pwd)/docker/data:/var/lib/postgresql/data \
    postgres:9.6.1
</code></pre>
<h4 id="142">1.4.2 앱 이미지 빌드</h4>
<pre><code class="language-bash">$ docker build -t django-sample .
</code></pre>
<h4 id="143">1.4.3 앱 컨테이너 실행</h4>
<pre><code class="language-bash">$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    --volume=$(pwd):/app/ \
    django-sample \
    ./manage.py runserver 0:8000
</code></pre>
<p>브라우저에서 <a href="http://127.0.0.1:8000">http://127.0.0.1:8000</a>을 열어보면 드디어 Django의 초기 화면을 만날 수 있습니다!</p>
<p><img src="../content/images/2017/03/django-it-worked.png" alt=""></p>
<p>지금까지의 구성을 그림으로 그려보면 배포 환경과 거의 비슷해지겠죠.</p>
<p><img src="../content/images/2017/03/docker-native-develoment-environment2.png" alt="도커를 활용한 개발 환경 구성 - 첫 시도"></p>
<h3 id="15">1.5 도커 방식의 불편함</h3>
<p>도커로 개발 환경을 구성하는 데 성공하긴 했지만, 이번엔 다른 불편이 발생했습니다.</p>
<h4 id="151">1.5.1 장황한 옵션</h4>
<p>첫 번째는 서버를 실행할 때마다 옵션을 적기가 귀찮습니다. 헷갈리기도 하고, 빼먹는 경우도 생깁니다. 그래서 옵션들을 미리 적어둘 수는 없을까 고민하게 되었습니다.</p>
<h4 id="152db">1.5.2 앱 컨테이너와 db 컨테이너의 실행 순서</h4>
<p>반드시 db 컨테이너를 실행한 다음에야 앱 컨테이너를 실행해야 합니다. 그렇지 않으면 앱 컨테이너에서 db 컨테이너를 찾을 수 없기 때문이죠.</p>
<h3 id="16">1.6 도커 컴포즈</h3>
<p>그때 <a href="https://docs.docker.com/compose/">도커 컴포즈(Docker Compose)</a>를 사용해 볼 마음이 생겼습니다. 컴포즈는 컨테이너 여럿을 띄우는 도커 애플리케이션을 정의하고 실행하는 도구(Tool for defining and running <strong>multi-container Docker applications</strong>)입니다.</p>
<p>컨테이너 실행에 필요한 옵션을 <code>docker-compose.yml</code>이라는 파일에 적어둘 수 있고, 컨테이너 간 의존성도 관리할 수 있어서 안성맞춤이었지요.</p>
<p>도커와 도커 컴포즈를 비교하면 다음과 같습니다.</p>
<ul>
<li><code>Dockerfile</code> vs. <code>Dockerfile-dev</code>: 서버 구성을 문서화한 것(=<strong>클래스 선언이 들어 있는 파일</strong>)</li>
<li><code>docker build</code> vs. <code>docker-compose build</code>: 도커 이미지 만들기(=<strong>클래스 선언을 애플리케이션에 로드</strong>)</li>
<li><code>docker run</code>의 옵션들 vs. <code>docker-compose.yml</code>: 이미지에 붙이는 장식들(=<strong>인스턴스의 변수들</strong>)</li>
<li><code>docker run</code> vs. <code>docker-compose up</code>: 장식 붙은 이미지를 실제로 실행(=<strong>인스턴스 생성</strong>)</li>
</ul>
<p>도커 컴포즈에서는 컨테이너 실행에 사용되는 옵션과 컨테이너 간 의존성을 모두 <code>docker-compose.yml</code>파일에 적어두고, 컴포즈용 명령어를 사용하여 컨테이너들을 실행, 관리합니다.</p>
<p>클래스와 인스턴스의 예를 들면, 어떤 인스턴스를 자주 생성해야 해서 필요한 변수를 딕셔너리로 저장해두는 것과 비슷하겠습니다. 이를 그림으로 나타내면 다음과 같습니다.</p>
<p><img src="../content/images/2017/03/docker-compose-yml.png" alt=""></p>
<h3 id="161">1.6.1 선행 조건</h3>
<p>이후의 예시를 따라하려면 도커 엔진의 버전이 1.12.0 이상이어야 하고, docker-compose의 버전은 1.6.0 이상이어야 합니다. 최근에 도커를 설치했다면 큰 문제가 없을 겁니다.</p>
<pre><code class="language-bash">$ docker version
Client:
 Version:      1.13.1
 API version:  1.26
 Go version:   go1.7.5
 Git commit:   092cba3
 Built:
 OS/Arch:      darwin/amd64

Server:
 Version:      1.13.1
 API version:  1.26 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   092cba3
 Built:        Wed Feb  8 08:47:51 2017
 OS/Arch:      linux/amd64
 Experimental: true
$ docker-compose version
docker-compose version 1.11.1, build 7c5d5e4
docker-py version: 2.0.2
CPython version: 2.7.12
OpenSSL version: OpenSSL 1.0.2j  26 Sep 2016
</code></pre>
<p>이 조건이 만족했다면 이제 <code>docker-compose.yml</code> 파일을 만들어 봅시다.</p>
<h3 id="17dockercomposeyml">1.7 docker-compose.yml</h3>
<p><code>docker-compose.yml</code>은 옵션을 미리 정의한 문서라고 볼 수 있습니다. 프로젝트 루트에 파일을 만들고, 다음 내용을 붙여 넣습니다. (<a href="https://gist.github.com/raccoonyy/2db75b86f73bc0b337a0c2c3f94709a1/79fe204485726b37ce73486fc93d73cef1b55004">gist 링크</a>)</p>
<pre><code class="language-yaml">version: '2.1'

services:
  db:
    image: postgres:9.6.1
    volumes:
      - ./docker/data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: "pg_isready -h localhost -p 5432 -q -U postgres"
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      - ./:/app/
</code></pre>
<p>이제 파일의 윗부분부터 한 줄씩 살펴봅시다.</p>
<h4 id="171version">1.7.1 version</h4>
<pre><code>version: '2.1'
</code></pre>
<p><code>docker run</code>에서는 없었던 부분입니다. <code>docker-compose.yml</code> 파일의 제일 윗부분에는 파일 규격 버전을 적습니다. 파일의 규격에 따라 지원하는 옵션이 달라지며, 최근에 "3.1"이 등장하긴 했지만 보통은 "2"나 "2.1"을 사용해도 충분합니다. (파일 규격 버전에 따른 자세한 내용은 <a href="https://docs.docker.com/compose/compose-file/compose-versioning/">compose 파일의 버전과 호환성을 안내한 공식 문서</a>를 참고하세요.)</p>
<p>여기서는 2.1 버전을 사용합니다.</p>
<h4 id="172services">1.7.2 services</h4>
<pre><code>services:
</code></pre>
<p>이 항목 밑에 실행하려는 서비스들을 정의합니다. 서비스란, 앱 컨테이너나 postgres 컨테이너 각각의 묶음입니다.</p>
<h4 id="173db">1.7.3 db</h4>
<pre><code>  db:
</code></pre>
<p>postgres 서비스의 이름을 <code>db</code>로 정하였습니다.</p>
<h4 id="174image">1.7.4 image</h4>
<pre><code>    image: postgres:9.6.1
</code></pre>
<p><code>db</code> 서비스에서 사용할 도커 이미지를 적습니다. 여기서는 <a href="https://hub.docker.com/_/postgres/">dockerhub의 공식 postgres:9.6.1 이미지</a>를 사용하였습니다.</p>
<h4 id="175volumes">1.7.5 volumes</h4>
<pre><code>    volumes:
      - ./docker/data:/var/lib/postgresql/data
</code></pre>
<p><code>docker run</code>으로 앱 컨테이너를 실행할 때 <code>--volume</code> 옵션을 사용하여 데이터베이스의 데이터를 로컬 컴퓨터에 저장했던 부분과 같습니다. 다만 <code>docker-compose.yml</code>의 <code>volumes</code>에는 상대 경로를 지정할 수 있다는 점이 다릅니다.</p>
<p><code>docker run</code>으로 앱 컨테이너를 실행할 때와 마찬가지로, 프로젝트 루트 아래의 <code>docker/data</code> 디렉터리에 데이터를 저장하기로 했습니다.</p>
<h4 id="176environment">1.7.6 environment</h4>
<pre><code>    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
</code></pre>
<p><code>docker run</code>에서 <code>-e</code> 옵션에 적었던 내용들입니다. 마지막의 <code>POSTGRES_INITDB_ARGS</code> 부분이 추가되었는데, 데이터베이스 서버의 인코딩을 설정하기 위함입니다.</p>
<h4 id="177healthcheck">1.7.7 healthcheck</h4>
<pre><code>    healthcheck:
      test: "pg_isready -h localhost -p 5432 -q -U postgres"
      interval: 3s
      timeout: 1s
      retries: 10
</code></pre>
<p>혹시 손이 빠른 분들 중에는, 앞서 <code>docker run</code> 명령으로 앱 컨테이너를 띄울 때 개발 서버가 데이터베이스 서버에 접속하지 못하는 오류를 접하신 분들도 계실지 모르겠습니다. postgres 컨테이너가 실행 중인데도 말이죠.</p>
<p>이는 postgres 컨테이너가 처음 실행되면서 데이터베이스나 사용자가 미처 생성되기 전에, 앱 컨테이너가 데이터베이스에 접근하려고 시도하기 때문입니다. 컴포즈에서도 마찬가지 문제가 발생하게 되는데요. 따라서 postgres 서비스가 제대로 실행될 뿐만 아니라 데이터베이스에 접근할 수 있는지도 파악을 해야 합니다.</p>
<p><code>healthcheck</code>는 바로 이것을 제어할 수 있습니다. 검사에 사용할 명령(<code>test</code>)을 3초 간격(<code>interval</code>)으로 열 번 시도(<code>retries</code>)하며, 각 시도에서 타임아웃은 1초(<code>timeout</code>)로 지정하였습니다.</p>
<p>여기서 사용한 <code>pg_isready</code> 명령은 데이터베이스 서버에 접근할 수 있는지를 파악합니다. (PostgreSQL 9.3부터 추가된 <code>pg_isready</code> 명령에 대해서는 <a href="https://www.postgresql.org/docs/9.3/static/app-pg-isready.html">PostgreSQL 문서의 pg_isready 부분</a>을 참고하세요.)</p>
<p>조금 장황한 듯 하지만, 앞으로는 이 옵션들을 일일이 타이핑하지 않아도 된다는 점을 생각하며 앱 서비스로 넘어가겠습니다.</p>
<h4 id="178django">1.7.8 django</h4>
<p>앱 서비스의 이름은 <code>django</code>로 지정하였습니다.</p>
<h4 id="179build">1.7.9 build</h4>
<pre><code>    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
</code></pre>
<p>db 서비스와 달리 앱 서비스는 도커 이미지를 빌드할 일이 잦기 때문에, 특정 이미지 대신 <code>build</code> 옵션을 추가합니다.</p>
<p><code>context</code>는 <code>docker build</code> 명령을 실행할 디렉터리 경로라고 보시면 됩니다.</p>
<p><code>dockerfile</code>은 <strong>'개발용' 도커 이미지</strong>를 빌드하는 데 사용할 Dockerfile을 지정하면 되는데요. 배포용 Dockerfile과 어떻게 다른지는 추후 설명하겠습니다.</p>
<h4 id="1710environment">1.7.10 environment</h4>
<pre><code>    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
</code></pre>
<p>환경 변수는 그냥 <code>docker run</code>을 할 때보다 좀더 자세하게 적었습니다. 각 값은 Django 설정 파일(<code>djangosample/settings.py</code>)에서 사용합니다.</p>
<h4 id="1711ports">1.7.11 ports</h4>
<pre><code>    ports:
      - "8000:8000"
</code></pre>
<p>도커 컴포즈로 서비스를 실행하면 기본적으로 가상의 네트워크가 하나 만들어지고, 네트워크 외부의 접근이 막힙니다. (도커 컨테이너가 그렇듯이요.) 따라서 외부에서 접근할 수 있는 포트를 지정해주어야 합니다. 여기서는 Django 개발 서버의 기본 포트는 8000을 지정하였습니다.</p>
<h4 id="1712depends_on">1.7.12 depends_on</h4>
<pre><code>    depends_on:
      db:
        condition: service_healthy
</code></pre>
<p>서비스가 하나 이상일 때, 실행 의존성을 지정할 수 있습니다. 여기서 지정한 내용은, <code>db</code> 서비스가 실행된 후에 <code>django</code> 서비스를 실행하겠다는 의미입니다. <code>contidion</code> 뒤에는 서비스 시작(<code>service_started</code>)이나 서비스 헬스체크 성공(<code>service_healthy</code>)을 지정할 수 있습니다.</p>
<p><code>db</code> 서비스의 <code>healthcheck</code> 부분과 여기서의 <code>service_healthy</code> 부분이 서로 맞물리면, <code>db</code> 서비스에서 데이터베이스 서버 접속이 가능해진 순간 이후에야, <code>django</code> 서비스가 시작합니다.</p>
<blockquote>
<p><code>depend_on</code>에서 <code>condition</code>을 지정하는 방식이 도커 컴포즈 파일 규격 3.0과 3.1에서는 제대로 작동하지 않는다고 합니다.</p>
</blockquote>
<h4 id="1713links">1.7.13 links</h4>
<pre><code>    links:
      - db
</code></pre>
<p><code>docker run</code>에서 <code>--link</code> 옵션에서 지정했던 내용입니다. 앱 컨테이너 안에서 db 서비스를 <code>db</code>라는 이름으로 참조할 수 있습니다.</p>
<h4 id="1714command">1.7.14 command</h4>
<pre><code>    command: /start-dev.sh
</code></pre>
<p><code>docker run</code>으로 앱 컨테이너를 실행할 때 가장 마지막에 적었던 <code>./manage.py runserver 0:8000</code>을 대신할 셀 스크립트 파일을 하나 만들었습니다. 다음은 <code>start-dev.sh</code>의 내용입니다.</p>
<pre><code class="language-bash">#!/bin/sh
python manage.py migrate
python manage.py runserver 0:8000
</code></pre>
<p>Django 마이그레이션을 따로 실행하기가 귀찮아서, 개발 서버 실행에 앞서 넣어두었습니다.</p>
<h4 id="1715volumes">1.7.15 volumes</h4>
<pre><code>    volumes:
      - ./:/app/
</code></pre>
<p><code>docker run</code>으로 앱 컨테이너를 실행할 때 프로젝트 루트 디렉터리를 컨테이너 안에 연결했던 부분과 같습니다.</p>
<p>이렇게 해서 <code>docker-compose.yml</code> 파일을 모두 살펴보았습니다.</p>
<h3 id="18">1.8 드디어 실행!</h3>
<p><code>docker-compose.yml</code>을 모두 작성했다면 드디어 서비스를 실행할 차례입니다.</p>
<pre><code class="language-bash">$ docker-compose up -d
Creating network "djangosample_default" with the default driver
Creating djangosample_db_1
Creating djangosample_django_1
Attaching to djangosample_db_1, djangosample_django_1
db_1          | Initializing database
... (DB 초기화 진행) ...
django_1      | Operations to perform:
django_1      |   Apply all migrations: admin, app, auth, contenttypes, myapp, sessions, sites
django_1      | Running migrations:
... (DB 마이그레이션 진행) ...
</code></pre>
<p><a href="http://127.0.0.1:8000">http://127.0.0.1:8000</a>에 접속해보면 개발 서버가 잘 작동함을 확인할 수 있습니다. 이를 그림으로 나타내면 다음과 같습니다.</p>
<p><img src="../content/images/2017/02/docker-compose-dev-env2.png" alt=""></p>
<p>각 컨테이너를 실행하던 길고 복잡한 명령어들이 사라졌고, 간단한 명령어 한 줄로 개발 서버와 데이터베이스를 모두 실행하였습니다. 이렇게 해서 개발 서버 구성이 모두 끝났습니다.</p>
<p>그런데 앞에서 개발 서버용 Dockerfile이 따로 존재한다고 말했는데요. 이것 하나만 더 짚고 넘어가겠습니다.</p>
<h3 id="19dockerfilevsdockerfiledev">1.9 Dockerfile vs. Dockerfile-dev</h3>
<p>크게 보자면, 개발 서버에는 필요 없는 내용을 지우고, 개발 서버에만 필요한 내용을 추가하면 됩니다.</p>
<p>먼저, 개발 서버용 Dockerfile-dev에 필요 없는 내용을 살펴보겠습니다.</p>
<pre><code class="language-dockerfile"># 개발 서버용 Dockerfile-dev에서 뺄 부분들

# 앱 코드 복사
ADD ./app/      /app/

# Django 정적 파일 수집
RUN ./manage.py collectstatic --noinput

# 서버 실행 명령
CMD    ['supervisord', '-n']
</code></pre>
<ul>
<li>앱 코드: 앱 코드는 컨테이너 안에 고정하지 않고 로컬 컴퓨터의 디렉터리를 참조하게 했기 때문에, 이 부분은 필요 없습니다. (<code>docker-compose.yml</code>의 <code>volume</code> 부분)</li>
<li>정적 파일: 배포 환경에서 Django는 정적 파일을 직접 서빙하지 않고, nginx나 Apache 등에 맡기는데요. 지금은 개발 서버를 실행하려는 것이므로 이 과정이 필요 없죠.</li>
<li>서버 실행: 한 컨테이너 안에서 Django용 uwsgi와 웹 서비스인 nginx를 실행하고자 프로세스 관리자인 supervisord를 사용하기도 하는데요. 개발 환경에서는 개발 서버만 실행하면 되니까 역시 삭제합니다.</li>
</ul>
<p>그 다음은 개발용 Dockerfile-dev에만 추가하는 내용입니다.</p>
<pre><code class="language-dockerfile"># 개발용 Dockerfile-dev에 추가할 부분들

# 개발 환경 구성에 필요한 파일 복사
COPY ./requirements-dev.txt /app/requirements-dev.txt
RUN  pip install -r requirements-dev.txt

# 개발 서버 실행에 필요한 파일 복사
ADD compose/django/start-dev.sh /start-dev.sh
RUN chmod +x /*.sh
</code></pre>
<ul>
<li><code>requirements-dev.txt</code>: 개발 환경 구성에 사용할 패키지들을 <code>requirements-dev.txt</code>에 정리한 후, 컨테이너에 넣고 설치(<code>pip install -r</code>)합니다.</li>
<li><code>start-dev.sh</code>: 개발 서버 실행용 명령이 들어 있습니다.</li>
</ul>
<p>그래서 최종 <code>Dockerfile-dev</code>의 내용은 다음과 같습니다. (<a href="https://gist.github.com/raccoonyy/3674be1c8f24f6299b1949a92dbe5795">gist 링크</a>)</p>
<pre><code class="language-dockerfile">FROM python:3

RUN \
    apt-get update &amp;&amp;\
    apt-get -y install \
        libpq-dev \
        python-dev

WORKDIR /app

ADD    ./manage.py                    /app/
ADD    ./requirements.txt             /app/
ADD    ./requirements-dev.txt         /app/
RUN    pip install -r requirements.txt
RUN    pip install -r requirements-dev.txt

ADD    compose/django/start-dev.sh    /start-dev.sh
RUN    chmod +x /*.sh
</code></pre>
<h3 id="110">1.10 좀더 개선하기</h3>
<h4 id="1101">1.10.1 데이터베이스 저장소 관리</h4>
<p>아울러, 기존의 <code>docker-compose.yml</code>을 살짝 개선해 보겠습니다. (<a href="https://gist.github.com/raccoonyy/2db75b86f73bc0b337a0c2c3f94709a1">gist 링크</a>)</p>
<pre><code class="language-yaml">version: '2.1'

# 변경 부분!
volumes:
  django_sample_db_dev: {}

services:
  db:
    image: postgres:9.6.1
    volumes:
      # 여기도 변경 부분!
      - django_sample_db_dev:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: "pg_isready -h localhost -p 5432 -U postgres"
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      # 마지막으로 여기도!
      - ./manage.py:/app/manage.py
      - ./requirements.txt:/app/requirements.txt
      - ./requirements-dev.txt:/app/requirements-dev.txt
      - ./djangosample:/app/djangosample
</code></pre>
<p>모두 volumes와 관련된 부분들인데요.</p>
<p>처음 바뀐 부분에서는 도커가 관리하는 가상의 디스크를 <code>django_sample_db_dev</code>라는 이름으로 만듭니다. 이렇게 만들어진 디스크는 <code>docker volume ls</code> 명령으로 확인할 수 있습니다.</p>
<p>이렇게 만든 가상 디스크를 두 번째 바뀐 부분에서 사용합니다. db 서비스가 로컬 디스크 대신 이 가상 디스크에 데이터를 쌓도록 하였습니다. (이렇게 하면 나중에 서비스를 지울 때 디스크도 함께 지울 수 있습니다.)</p>
<p>마지막 바뀐 부분에서는 프로젝트 루트 전체를 컨테이너 안에 링크하는 대신, 특정 파일이나 폴더만 지정하였습니다. npm으로 노드 모듈을 설치한 경우 프로젝트 루트 밑의 <code>node_modules</code> 디렉터리를 컨테이너 안에서도 참조하게 되는데, 이때 로컬 컴퓨터와 컨테이너 안의 유닉스 환경이 달라서 실행 파일이 제대로 실행되지 않는 문제를 피하기 위함입니다. (물론, 이는 <code>.dockerignore</code> 파일로도 제어할 수 있겠습니다.)</p>
<h4 id="1102">1.10.2 패키지 설치 볼륨 추가</h4>
<p>개발 환경이라는 특성상 의존 패키지를 추가하는 일이 잦은데요. 이때마다 도커 이미지를 새로 빌드하면서 의존 패키지를 전부 다시 설치하는 시간이 조금 낭비처럼 느껴집니다.</p>
<p>이를 개선하고자 앱 컨테이너 내부의 파이썬 패키지가 설치되는 <code>/usr/local/lib/python3.6/site-packages/</code> 디렉터리를 도커 볼륨으로 빼내겠습니다.</p>
<pre><code class="language-yaml">version: '2.1'

volumes:
  django_sample_db_dev: {}
  # 변경 부분!
  django_sample_packages: {}

services:
  db:
    image: postgres:9.6.1
    volumes:
      - django_sample_db_dev:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: "pg_isready -h localhost -p 5432 -U postgres"
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      - ./manage.py:/app/manage.py
      - ./requirements.txt:/app/requirements.txt
      - ./requirements-dev.txt:/app/requirements-dev.txt
      - ./djangosample:/app/djangosample
      - django_sample_packages:/usr/local/lib/python3.6/site-packages/
</code></pre>
<p>이 볼륨을 활용하려면 <code>Dockerfile-dev</code>와 <code>start-dev.sh</code>도 조금 바꿔야 합니다.</p>
<ul>
<li><code>Dockerfile-dev</code></li>
</ul>
<pre><code class="language-dockerfile">FROM python:3
MAINTAINER raccoony &lt;raccoonyy@gmail.com&gt;

RUN \
    apt-get update &amp;&amp;\
    apt-get -y install \
        libpq-dev \
        python-dev

WORKDIR /app

ADD    ./manage.py                    /app/
# 아래 주석 처리한 부분을 삭제합니다.
# ADD    ./requirements.txt             /app/
# RUN    pip install -r requirements.txt

ADD    compose/django/start-dev.sh       /start-dev.sh
RUN    chmod +x /*.sh
</code></pre>
<ul>
<li><code>start-dev.sh</code></li>
</ul>
<pre><code class="language-bash">#!/bin/sh
# 추가된 부분
pip install -r requirements.txt
python manage.py migrate
gunicorn --workers=3 --bind 0:8000 djangosample.wsgi
</code></pre>
<p>이제 도커 이미지를 새로 만듭니다(<code>docker-compose up --build</code>).</p>
<p>이후부터는 컨테이너가 사라져도 의존 패키지들은 도커 볼륨(<code>django_sample_packages</code>)에 모두 저장되어 있을 겁니다. <code>requirements.txt</code>에 내용을 추가한 후에는 도커 이미지를 빌드할 필요 없이, 컨테이너를 새로 띄우기만 하면(<code>docker-compose up --force-recreate</code>), 추가된 패키지가 설치됩니다.</p>
<h4 id="1103">1.10.3 컨테이너 재생성시 바이너리 파일이 없어지는 문제 수정</h4>
<p>의존 패키지를 재설치하지 않아서 좋아졌지만, 단점이 생겼습니다. 컨테이너만 재생성할 경우 pytest나 flake8 등 이미 설치한 패키지들의 바이너리 파일들이 사라졌음을 확인할 수 있을 겁니다. 이는 pytest나 flake8 패키지를 설치할 때 <code>.py</code> 파일들은 <code>django_sample_packages</code> 볼륨에 설치되지만, 실행 파일들은 <code>/usr/local/bin</code> 디렉터리에 복사되기 때문인데요.</p>
<p>이를 해결하고자 <code>PYTHONUSERBASE</code>와 <code>PATH</code> 환경변수를 추가하고, pip 패키지 설치시 이 환경변수를 사용하게 해보겠습니다.</p>
<p>먼저, <code>Dockerfile-dev</code> 파일에 다음 내용을 추가합니다.</p>
<pre><code class="language-dockerfile">ENV PYTHONUSERBASE=/usr/local/
# 파이썬 버전에 따라 중간 경로인 python3.5 부분이 달라집니다.
ENV PATH=${PYTHONUSERBASE}lib/python3.5/site-packages/bin:${PATH}
</code></pre>
<p>그리고 <code>start-dev.sh</code> 파일의 <code>pip install</code> 부분에 <code>--user</code> 옵션을 추가합니다.</p>
<pre><code class="language-bash">#!/bin/sh
pip install --user -r requirements.txt
python manage.py migrate
gunicorn --workers=3 --bind 0:8000 djangosample.wsgi
</code></pre>
<p>이렇게 하면 파이썬용 바이너리 파일들이 <code>/usr/local/bin</code> 대신 <code>/usr/local/lib/python3.5/site-packages/bin</code>에 설치됩니다. 이 디렉터리는 <code>django_sample_packages</code> 볼륨 속에 위치하기 때문에, 컨테이너가 재생성되더라도 바이너리 파일들이 삭제되지 않습니다.</p>
<h4 id="1104">1.10.4 파이썬 로그가 한 발 느리게 출력되는 문제 수정</h4>
<p>이렇게 사용하다보니 간혹 파이썬 로그가 한 발 늦게 출력된다는 느낌을 받을 때가 있었습니다. 검색을 해보니 파이썬 출력 버퍼링이 기본으로 작동하기 때문이었는데요. 이 버퍼링을 없애려면 <code>PYTHONUNBUFFERED</code> 환경변수를 추가하면 됩니다.</p>
<p><code>Dockerfile-dev</code>에 다음 내용을 추가합니다. (설정할 값은 0이든 1이든 상관 없고, 환경변수가 존재하기만 하면 됩니다.)</p>
<pre><code class="language-dockerfile">ENV PYTHONUNBUFFERED=0
</code></pre>
<p>이렇게 해서 도커 컴포즈로 개발 환경을 어떻게 구성하는지 살펴보았습니다.</p>
<p>이제 docker-compose에서 주로 사용하는 명령어들을 간략하게 훑어보겠습니다.</p>
<hr>
<h3 id="dockercompose">docker-compose의 주요 명령어</h3>
<blockquote>
<p><code>docker-compose</code> 명령어를 짧은 alias로 등록해두면 편리합니다. 저는 oh-my-zsh에서 기본으로 제공하는 <code>dco</code>를 사용하고 있습니다.</p>
</blockquote>
<h4 id="upd">up -d</h4>
<p><code>docker-compose.yml</code> 파일의 내용에 따라 이미지를 빌드하고 서비스를 실행합니다. 자세한 진행 과정은 다음과 같습니다.</p>
<ol>
<li>서비스를 띄울 네트워크 설정</li>
<li>필요한 볼륨 생성</li>
<li>필요한 이미지 pull</li>
<li>필요한 이미지 build</li>
<li>서비스 의존성에 따라 서비스 실행</li>
</ol>
<p><code>up</code> 명령에 사용할 수 있는 몇 가지 옵션도 존재합니다.</p>
<ul>
<li><code>-d</code>: 서비스 실행 후 콘솔로 빠져나옵니다. (<code>docker run</code>에서의 <code>-d</code>와 같습니다.)</li>
<li><code>--force-recreate</code>: 컨테이너를 지우고 새로 만듭니다.</li>
<li><code>--build</code>: 서비스 시작 전 이미지를 새로 만듭니다.</li>
</ul>
<h4 id="ps">ps</h4>
<p>현재 환경에서 실행 중인 서비스를 보여줍니다.</p>
<pre><code class="language-bash">$ docker-compose ps
        Name                       Command               State           Ports
--------------------------------------------------------------------------------
djangosample_db_1       /docker-entrypoint.sh postgres   Up      5432/tcp
djangosample_django_1   /start-dev.sh                    Up      0.0.0.0:8000-&gt;8000/tcp
</code></pre>
<h4 id="stopstart">stop, start</h4>
<p>서비스를 멈추거나, 멈춰 있는 서비스를 시작합니다.</p>
<pre><code class="language-bash">$ docker-compose stop
Stopping djangosample_django_1 ...
Stopping djangosample_db_1 ...

$ docker-compose start
Starting db ... done
Starting django ... done
</code></pre>
<h4 id="down">down</h4>
<p>서비스를 지웁니다. 컨테이너와 네트워크를 삭제하며, 옵션에 따라 볼륨도 지웁니다.</p>
<pre><code class="language-bash">$ docker-compose down --volume
Removing myproject_django_1 ... done
Removing myproject_db_1 ... done
Removing network djangosample_default
Removing volume django_sample_db_dev
</code></pre>
<ul>
<li><code>--volume</code>: 볼륨까지 삭제합니다.</li>
</ul>
<h4 id="exec">exec</h4>
<p>실행 중인 컨테이너에서 명령어를 실행합니다. 자동화된 마이그레이션용 파일 생성이나 유닛 테스트, lint 등을 실행할 때 사용합니다.</p>
<pre><code class="language-bash">$ docker-compose exec django ./manage.py makemigrations
...
</code></pre>
<pre><code class="language-bash">$ docker-compose exec node npm run test
&gt; expresssample@0.1.0 test /www/service
&gt; mocha $(find test -name '*.spec.js')
...
</code></pre>
<blockquote>
<p>비슷한 명령으로 <code>run</code>이 존재합니다. <code>run</code>은 새 컨테이너를 만들어서 명령어를 실행합니다. <code>docker run</code>과 마찬가지로 <code>--rm</code> 옵션을 추가하지 않으면, 컨테이너가 종료된 후에도 삭제되지 않습니다. (이런 이유 때문에 개인적으로는 <code>exec</code>를 선호합니다.)</p>
</blockquote>
<h4 id="logs">logs</h4>
<p>서비스의 로그를 확인할 수 있습니다. <code>logs</code> 뒤에 서비스 이름을 적지 않으면 도커 컴포즈가 관리하는 모든 서비스의 로그를 함께 보여줍니다.</p>
<pre><code class="language-bash">$ docker-compose logs django
Attaching to djangosample_django_1
django_1     | System check identified no issues (0 silenced).
django_1     | February 13, 2017 - 16:32:28
django_1     | Django version 1.10.4, using settings 'djangosample.settings'
django_1     | Starting development server at http://0.0.0.0:8000/
django_1     | Quit the server with CONTROL-C.
</code></pre>
<ul>
<li><code>-f</code>: 지금까지 쌓인 로그를 다 보여준 후에도 셸로 빠져나오지 않고, 로그가 쌓일 때마다 계속해서 출력합니다.</li>
</ul>
<p>마지막으로, 몇 가지 삽질 경험을 바탕으로 나름의 팁을 정리해보겠습니다.</p>
<hr>
<h3 id="">나름의 팁</h3>
<h4 id="1dockercomposeyml">1. docker-compose.yml을 수정했다면?</h4>
<p><code>docker-compose.yml</code> 파일을 수정하고 이를 서비스에 적용하려면 서비스를 멈추고(<code>stop</code>), 서비스를 지우고(<code>rm</code>), 서비스를 시작해야(<code>up</code>) 합니다.</p>
<p>하지만 <code>up</code> 명령만 실행해도, (현재 실행 중인 서비스 설정과 달라진 부분이 있다면) <strong>알아서 컨테이너를 재생성하고 서비스를 재시작</strong>해줍니다.</p>
<pre><code class="language-bash">$ docker-compose up -d [&lt;서비스 이름&gt;]
</code></pre>
<blockquote>
<p>혹시 컨테이너를 재생성하지 않는 것 같다면, <code>--force-recreate</code> 옵션을 붙이면 됩니다.</p>
</blockquote>
<h4 id="2dockerfiledev">2. Dockerfile-dev 파일을 수정했다면?</h4>
<p><code>Dockerfile-dev</code> 파일을 수정했을 땐 <code>build</code> 명령을 사용하여 도커 이미지를 새로 만들어야 합니다. 이후 서비스 중지와 삭제, 재시작을 해야 하죠.</p>
<p>하지만 <code>up</code> 명령에 다음과 같이 <code>--build</code> 옵션을 넣으면 <strong>알아서 이미지를 새로 만들고 서비스를 재시작</strong>합니다.</p>
<pre><code class="language-bash">$ docker-compose up -d --build [&lt;서비스 이름&gt;]
</code></pre>
<h4 id="3dockerfiledev">3. Dockerfile-dev도 신경 써야 함</h4>
<p>개발용 Dockerfile과 배포용 Dockerfile이 따로 존재한다는 점을 꼭 기억해야 합니다. 간혹 <code>Dockerfile</code>만 고치면서 개발 환경에서 **'외않돼?'**라고 생각한 경우가 있습니다. ;;</p>
<p>(<code>Dockerfile</code>에도 다른 <code>Dockerfile</code>을 참조한다는 개념이 있으면 좋을 텐데... 싶습니다.)</p>
<h4 id="4">4. 데이터베이스 내용도 지우고 싶다면</h4>
<p>열심히 개발하다 보면 데이터베이스에 원치 않는 데이터가 남는 경우가 있습니다. 데이터베이스에 접속해서 테이블을 삭제하거나 할 수도 있겠지만, <code>down</code> 명령에 <code>--volume</code> 옵션을 추가하면 서비스에서 사용하는 볼륨(=데이터베이스 데이터가 저장되는 곳)을 삭제하기 때문에, 데이터베이스를 깨끗하게 초기화할 수 있습니다.</p>
<pre><code>$ docker-compose down --volume
</code></pre>
<h4 id="5mysqlpostgresql">5. MySQL보다는 PostgreSQL이 조금 더 편한 듯</h4>
<p>로컬 컴퓨터에 데이터베이스 서버가 없어도, 서비스를 시작하기만 하면 알아서 데이터베이스 서버가 시작된다는 점은 굉장한 매력이었습니다. 그런데 MySQL보다는과 PostgreSQL의 초기화 과정에 걸리는 시간이 꽤 차이가 나더군요.</p>
<p>제 컴퓨터 기준이긴 하지만 MySQL보다는 초기화에는 대략 15초, PostgreSQL 초기화에 대략 5초 남짓한 시간이 걸립니다. 데이터베이스 초기화가 자주 필요한 일은 아니지만 그래도 15초와 5초의 차이는 꽤 크죠.</p>
<blockquote>
<p>아울러, 데이터를 로컬에 쌓기보다는 도커가 관리하는 가상 디스크를 사용하는 편이 속도 면에서 좀더 유리합니다.</p>
</blockquote>
<h4 id="6errornospaceleftondevice">6. <code>ERROR: 'No space left on device'</code></h4>
<p>도커를 열심히 사용하고 있는데 갑자기 다음과 같은 메시지가 뜨면서 새 이미지를 빌드할 수 없다고 하더군요.</p>
<pre><code>ERROR: 'No space left on device'
</code></pre>
<p>하드디스크에 용량이 엄청 많이 남아 있었는데도 말이죠. 부랴부랴 검색을 해보니, Docker for OS X에서 사용하는 가상 파일 시스템의 기본 최대 값이 64기가바이트여서 발생한 문제였습니다.</p>
<p><mark>주의! 다음 내용을 진행하면 도커 이미지와 컨테이너, 볼륨이 모두 사라집니다.</mark></p>
<p>이 경우 Docker for OS X의 환경 설정 <code>Reset</code> 버튼을 누르면 해결됩니다.</p>
<p><img src="../content/images/2017/03/docker-for-os-x-reset2-copy.png" alt=""></p>
<p><code>Reset</code>하기가 무섭다면, Docker for OS X를 종료한 후 다음 파일을 삭제하고서 Docker for OS X를 실행하면 됩니다.</p>
<p><code>/Users/(LOGIN_ID)/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/Docker.qcow2</code></p>
<p>정확한 위치는 Docker for OS X의 환경 설정에서 Advanced 탭에 들어가 보면 알 수 있습니다.</p>
<p><img src="../content/images/2017/03/docker-for-os-x-location-copy.png" alt=""></p>
<h4 id="7pyenv23">7. pyenv 없이 파이썬2와 파이썬3을 오갈 수 있음</h4>
<p>회사에서 개발한 라이브러리에 파이썬3 호환성을 추가할 때도 이 방식을 사용해보았습니다. 파이썬3을 로컬 컴퓨터에 설치하지 않고 간단한 <code>docker-compose.yml</code>을 작성하여(사용한 이미지는 도커 공식 저장소의 <code>python:3</code>) 서비스를 띄운 후 테스트를 실행해가며, 호환성이 없는 부분을 찾아내고 수정할 수 있었습니다.</p>
<h4 id="8ghost">8. 로컬에서 Ghost 블로그 운영하기</h4>
<p>자세한 내용은 다음 블로그 글을 참고하세요. :)</p>
<p><strong><a href="../docker-for-ghost-blogging/index.html">Docker 활용법 - Ghost 블로그 운영하기 by raccoony</a></strong><br>
<a href="../docker-for-ghost-blogging/index.html"><img src="../content/images/2017/01/docker-for-ghost-blogging.png" alt=""></a></p>
<hr>
<p>이렇게 해서 개발 환경 구성하기를 마쳤습니다. 장황해보이지만, 실제로는 한 번 잘 구성해 두면 다른 프로젝트에는 그저 옮겨 붙이는 정도로 쉽게 적용할 수 있을 겁니다.</p>
<p>마지막으로, 글을 미리 읽고 검토해주신 <a href="https://twitter.com/@nacyo_t">@nacyo_t</a>님께 감사의 마음을 전합니다.</p>
<blockquote>
<p>도커를 배우고 나면<br>모든 것이 컨테이너로 보인다<br>
<small>--raccoony</small></p>
</blockquote>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->
            </section>


            <footer class="post-full-footer">

                <section class="author-card">
                        <img class="author-profile-image" src="http://www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s=250&amp;d=mm&amp;r=x" alt="raccoony">
                    <section class="author-card-content">
                        <h4 class="author-card-name"><a href="../author/raccoony/index.html">raccoony</a></h4>
                            <p>Read <a href="../author/raccoony/index.html">more posts</a> by this author.</p>
                    </section>
                </section>
                <div class="post-full-footer-right">
                    <a class="author-card-button" href="../author/raccoony/index.html">Read More</a>
                </div>

            </footer>


        </article>

    </div>
</main>

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card" style="background-image: url(../content/images/2017/03/pexels-photo-116191-2.jpg)">
                    <header class="read-next-card-header">
                        <small class="read-next-card-header-sitetitle">— raccoony's cave —</small>
                        <h3 class="read-next-card-header-title"><a href="../tag/docker/index.html">docker</a></h3>
                    </header>
                    <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg>
</div>
                    <div class="read-next-card-content">
                        <ul>
                            <li><a href="../docker-for-ghost-blogging/index.html">Docker 활용법 - Ghost 블로그 Github에서 운영하기</a></li>
                            <li><a href="../whats-new-in-docker-1-13-korean/index.html">Docker 1.13 릴리스 요약</a></li>
                            <li><a href="../2016-retrospective/index.html">2016년 돌아보기</a></li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/docker/index.html">See all 5 posts →</a>
                    </footer>
                </article>

                <article class="post-card post tag-paisseon-sosig tag-python-news tag-teseuteu tag-python-gil tag-restful-api tag-selenium tag-xpath tag-tongroimiji">
        <a class="post-card-image-link" href="../python-news-for-korean-2017-2nd-week-mar/index.html">
            <div class="post-card-image" style="background-image: url(../content/images/2017/01/python-news-for-korean-cover-2017.jpg)"></div>
        </a>
    <div class="post-card-content">
        <a class="post-card-content-link" href="../python-news-for-korean-2017-2nd-week-mar/index.html">
            <header class="post-card-header">
                    <span class="post-card-tags">파이썬 소식</span>
                <h2 class="post-card-title">한국의 파이썬 소식(2017년 3월 둘째 주)</h2>
            </header>
            <section class="post-card-excerpt">
                <p>한국에서 일어나는 파이썬 관련 소식을 전합니다. 블로그 Python GIL by hans mj님 파이썬 성능 저하의 원인으로 자주 지목되는 GIL(Global Interpreter Lock)이 무엇이고, 실제 성능은 어떤지에 대해 hans mj님이 설명하였습니다. RESTful API</p>
            </section>
        </a>
        <footer class="post-card-meta">
                <img class="author-profile-image" src="http://www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s=250&amp;d=mm&amp;r=x" alt="raccoony">
            <span class="post-card-author"><a href="../author/raccoony/index.html">raccoony</a></span>
        </footer>
    </div>
</article>

                <article class="post-card post tag-paisseon-sosig tag-python-news tag-2017-paisseon-koria tag-balpyojuje tag-paisseoneseo-seoljeong-gabs-gwanri">
        <a class="post-card-image-link" href="../python-news-for-korean-2017-1st-week-mar/index.html">
            <div class="post-card-image" style="background-image: url(../content/images/2017/01/python-news-for-korean-cover-2017.jpg)"></div>
        </a>
    <div class="post-card-content">
        <a class="post-card-content-link" href="../python-news-for-korean-2017-1st-week-mar/index.html">
            <header class="post-card-header">
                    <span class="post-card-tags">파이썬 소식</span>
                <h2 class="post-card-title">한국의 파이썬 소식(2017년 3월 첫 주)</h2>
            </header>
            <section class="post-card-excerpt">
                <p>한국에서 일어나는 파이썬 관련 소식을 전합니다. 블로그 2017 파이썬 코리아, 발표주제를 정해보자. by 김연태 님 미국과 일본 파이콘의 발표를 주제별로 분류한 후, 어떤 발표 주제를 선정하면 좋을지에 대해서 2017 파이썬 코리아의 준비 위원인</p>
            </section>
        </a>
        <footer class="post-card-meta">
                <img class="author-profile-image" src="http://www.gravatar.com/avatar/357fbea2b22fc72b351478c2c3a1ab23?s=250&amp;d=mm&amp;r=x" alt="raccoony">
            <span class="post-card-author"><a href="../author/raccoony/index.html">raccoony</a></span>
        </footer>
    </div>
</article>

        </div>
    </div>
</aside>

<div class="floating-header">
    <div class="floating-header-logo">
        <a href="http://raccoonyy.github.io">
                <img src="../content/images/2017/08/rac.png" alt="raccoony's cave icon">
            <span>raccoony's cave</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">Docker (Compose) 활용법 - 개발 환경 구성하기</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=Docker%20(Compose)%20%ED%99%9C%EC%9A%A9%EB%B2%95%20-%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD%20%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0&amp;url=http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/" onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>
        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/" onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>
        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>




        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://raccoonyy.github.io">raccoony's cave</a> © 2019</section>
                <nav class="site-footer-nav">
                    <a href="http://raccoonyy.github.io">Latest Posts</a>
                    <a href="https://www.facebook.com/raccoonyy" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/raccoonyy" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="../assets/js/jquery.fitvids.js?v=67668d0519"></script>


    <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>


    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/languages/dockerfile.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/languages/yaml.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/languages/django.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-35614951-4', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>