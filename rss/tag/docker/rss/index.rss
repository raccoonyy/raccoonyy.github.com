<!DOCTYPE html>
<html><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>docker - raccoony's cave</title><description>Raccoony writes about programming, book and etc.</description><link>http://raccoonyy.github.io/</link><image><url>http://raccoonyy.github.io/favicon.png</url><title>docker - raccoony's cave</title><link>http://raccoonyy.github.io/</link></image><generator>Ghost 2.19</generator><lastBuildDate>Tue, 09 Apr 2019 21:39:39 GMT</lastBuildDate><atom:link href="http://raccoonyy.github.io/tag/docker/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Docker (Compose) 활용법 - 개발 환경 구성하기</title><description>배포 환경에 Docker를 사용하고 있을 때 개발 환경에서도 Docker를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다. 슬라이드 버전 - https://goo.gl/MquH4r</description><link>http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/</link><guid isPermaLink="false">59815cfcdd47a80001bb9f12</guid><category>docker</category><category>ghost</category><category>docker-compose</category><category>개발 환경</category><dc:creator>raccoony</dc:creator><pubDate>Mon, 13 Mar 2017 01:08:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2017/02/docker-usages-dev-environment-setup.png" medium="image"/><content:encoded>&lt;!--kg-card-begin: markdown--&gt;&lt;h2 id=""&gt;개정 알림&lt;/h2&gt;
&lt;img src="http://raccoonyy.github.io/content/images/2017/02/docker-usages-dev-environment-setup.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;p&gt;이 글의 개정본을 &lt;a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose"&gt;도커 컴포즈를 활용하여 완벽한 개발 환경 구성하기&lt;/a&gt;에서 읽으실 수 있습니다. 개정본에서는 도커 컴포즈의 최신 버전에 맞춰 필요 없는 설명을 일부 삭제했고, 도커 자체에 대한 설명도 &lt;a href="https://www.44bits.io/ko/post/why-should-i-use-docker-container"&gt;왜 굳이 도커를 써야 하나요?&lt;/a&gt;로 분리하였습니다.&lt;/p&gt;
&lt;!--kg-card-end: markdown--&gt;&lt;!--kg-card-begin: hr--&gt;&lt;hr&gt;&lt;!--kg-card-end: hr--&gt;&lt;!--kg-card-begin: markdown--&gt;&lt;!--kg-card-begin: markdown--&gt;&lt;blockquote&gt;
&lt;p&gt;배포 환경에 도커를 사용하고 있을 때 개발 환경에서도 도커를 활용하면, 배포 환경과 개발 환경(테스트 환경까지도)이 최대한 일치하는 장점을 누릴 수 있을 것 같아서 시도를 해보았습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;일러두기: 글보다 슬라이드가 편한 분들은 아래 슬라이드를 보시면 되겠습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;iframe src="https://www.slideshare.net/slideshow/embed_code/key/5adOWwGkwzaw2w" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt; &lt;/iframe&gt; &lt;div style="margin-bottom:5px"&gt; &lt;strong&gt; &lt;a href="https://www.slideshare.net/raccoonyy/docker-compose-usages" title="Docker compose usages" target="_blank"&gt;Docker 활용법 - 개발 환경 구성하기&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a target="_blank" href="https://www.slideshare.net/raccoonyy"&gt;raccoony&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;
&lt;h3 id="20170905"&gt;2017-09-05 수정 내역&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;파이썬용 바이너리 파일(pytest, flake8 등)들의 설치 위치를 수정하여, &lt;a href="http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/./#1103"&gt;컨테이너 재생성시 바이너리 파일이 없어지는 문제 수정&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/./#1104"&gt;파이썬 로그가 빠릿하게 출력되지 않는 문제 수정&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="20170321"&gt;2017-03-21 수정 내역&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;의존 패키지를 하나 추가하더라도 패키지 전체를 다시 설치해야 하는 불편을 없애고자, &lt;a href="http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/./#1102"&gt;패키지 관리용 볼륨 설정 내용을 추가&lt;/a&gt;했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id="0"&gt;0 (사전 학습) 도커가 뭐야?&lt;/h1&gt;
&lt;p&gt;아직 도커를 잘 모르는 분께는 &lt;a href="https://subicura.com/"&gt;subicura&lt;/a&gt;님이 작성하신 연재 글을 추천합니다.&lt;/p&gt;
&lt;h3 id="01"&gt;0.1 초보를 위한 도커 안내서 시리즈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html"&gt;1. 도커란 무엇인가?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html"&gt;2. 설치하고 컨테이너 실행하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html"&gt;3. 이미지 만들고 배포하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="02"&gt;0.2 사족&lt;/h3&gt;
&lt;p&gt;subicura님의 안내서로 부족하진 않겠지만 혹시라도 이해를 도울 수 있을까 싶어서,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;도커를 프로그래밍에 빗대어 보겠습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Dockerfile&lt;/code&gt;: 서버 구성을 문서화한 것(=&lt;strong&gt;클래스 선언이 들어 있는 파일&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker build&lt;/code&gt;: 도커 이미지 만들기(=&lt;strong&gt;클래스 선언을 애플리케이션에 로드&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run&lt;/code&gt;의 옵션들: 이미지에 붙이는 장식들(=&lt;strong&gt;인스턴스의 변수들&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run&lt;/code&gt;: 장식 붙은 이미지를 실제로 실행(=&lt;strong&gt;인스턴스 생성&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이를 그림으로 나타내면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/03/docker-like-as-class-and-instance.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;p&gt;프로그래밍에서는 User 클래스를 파일에 적고, 이를 애플리케이션에서 불러와서, name과 id를 할당하고, 새 인스턴스를 만들어 사용하다가, 용도가 다 하면 삭제하겠죠.&lt;/p&gt;
&lt;p&gt;마찬가지로, 도커 이미지에 들어갈 내용을 정의하고(&lt;code&gt;Dockerfile&lt;/code&gt;), 이미지를 빌드한 다음(&lt;code&gt;docker build&lt;/code&gt;), 각종 옵션을 붙여 컨테이너를 실행(&lt;code&gt;docker run&lt;/code&gt;)하여 사용하다가, 용도가 다 하면 컨테이너를 삭제한다고 생각하시면 됩니다.&lt;/p&gt;
&lt;p&gt;그럼, 더 이상의 자세한 설명은 생략하고 본론으로 넘어가겠습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;설명을 따라하기 위한 예제 프로젝트는 다음의 깃헙 저장소에서 다운받을 수 있습니다. (Django용과 Express용을 준비했습니다.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;파이썬/Django용 예제 프로젝트&lt;/strong&gt;&lt;/p&gt;
&lt;div class="github-card" data-github="raccoonyy/django-sample-for-docker-compose" data-width="640" data-height="173" data-theme="default"&gt;&lt;/div&gt;
&lt;script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"&gt;&lt;/script&gt;
&lt;p&gt;&lt;strong&gt;노드/Express용 예제 프로젝트&lt;/strong&gt;&lt;/p&gt;
&lt;div class="github-card" data-github="raccoonyy/express-sample-for-docker-compose" data-width="640" data-height="173" data-theme="default"&gt;&lt;/div&gt;
&lt;script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"&gt;&lt;/script&gt;
&lt;hr&gt;
&lt;h1 id="1dockercompose"&gt;1 개발 환경에 docker-compose 적용하기&lt;/h1&gt;
&lt;h3 id="11"&gt;1.1 개발 환경 구성은 항상 까다롭다&lt;/h3&gt;
&lt;p&gt;새 프로젝트를 시작하거나 기존 프로젝트에 참여한 후 가장 먼저 하는 일은 바로, 개발 환경 구성일 겁니다. 파이썬과 Django를 사용하는 프로젝트라면 보통 다음과 같은 과정을 거칩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ pyenv install (파이썬 버전)
$ pyenv virtualenv (파이썬 버전) (가상환경이름)
(가상환경이름) $ pip install -r requirements.txt
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 그림으로 나타내면 이렇게 될 텐데요.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/03/virtualenv3.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;p&gt;이 구성이 한 번에 되면 좋겠지만,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;실제로는 패키지 설치가 막힐 때도 있고(SSL, LDAP 관련)&lt;/li&gt;
&lt;li&gt;막상 배포를 했더니 개발 환경과 서버 환경이 같지 않아서 문제가 발생하기도 하고&lt;/li&gt;
&lt;li&gt;(실수가 있건 없건) 로컬 컴퓨터에 이미 존재하는 파이썬 환경과 꼬이는 경우도 발생&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;합니다.&lt;/p&gt;
&lt;p&gt;그런데 배포 환경에서는 다음과 같이 이미 도커를 활용 중이었기에, 이 구성을 개발 환경에서도 그대로 사용할 수는 없을까 생각하게 되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/03/dockerized-production.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;h3 id="12"&gt;1.2 시도!&lt;/h3&gt;
&lt;h4 id="121"&gt;1.2.1 도커 이미지 빌드&lt;/h4&gt;
&lt;p&gt;먼저, 예제 프로젝트의 루트 디렉터리에서 도커 이미지를 빌드합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker build -t django-sample .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 &lt;code&gt;django-sample&lt;/code&gt;이라는 이름을 지닌 도커 이미지가 만들어 집니다.&lt;/p&gt;
&lt;h4 id="122"&gt;1.2.2 앱 컨테이너 실행&lt;/h4&gt;
&lt;p&gt;이제 컨테이너를 실행해봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run -it --rm \
    -p 8000:8000 \
    django-sample \
    ./manage.py runserver 0:8000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;도커의 &lt;code&gt;run&lt;/code&gt; 명령은 구조가 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run [옵션] 이미지이름[:태그] [명령어] [전달인자]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 명령의 옵션에 익숙치 않은 분들을 위해 간단히 설명을 붙이자면,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-it&lt;/code&gt;: 컨테이너의 표준 입력과 로컬 컴퓨터의 키보드 입력을 연결한다고 생각하면 됩니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--rm&lt;/code&gt;: 컨테이너를 종료할 때 컨테이너를 삭제합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;: 컨테이너 외부와 내부를 연결할 포트입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;django-sample&lt;/code&gt;: 실행할 이미지 이름입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./manage.py runserver 0:8000&lt;/code&gt;: 개발 서버 실행용 명령어입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 명령은 실행이 되는 듯 하다가 데이터베이스를 찾지 못해 오류가 발생합니다. 그럼 데이터베이스 서버를 실행해 보죠.&lt;/p&gt;
&lt;h4 id="123"&gt;1.2.3 데이터베이스 컨테이너 실행&lt;/h4&gt;
&lt;p&gt;데이터베이스 서버도 도커로 실행할 수 있습니다. 터미널 창을 하나 더 열고 다음 명령을 입력해보세요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run -it --rm \
    postgres:9.6.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;데이터베이스 서버가 실행되었지만 앱 개발 서버는 여전히 동작하지 않을 겁니다.&lt;/p&gt;
&lt;h3 id="13"&gt;1.3 이제 동작하지 않는 원인을 살펴봅시다&lt;/h3&gt;
&lt;h4 id="131postgresql"&gt;1.3.1 앱 컨테이너가 PostgreSQL 컨테이너를 못 찾음&lt;/h4&gt;
&lt;p&gt;조금 전에는, 앱 컨테이너를 실행한 후 PostgreSQL 컨테이너를 실행했습니다. 그런데 컨테이너는 실행 직후부터 컨테이너 외부의 상황과 격리됩니다. 따라서 PostgreSQL 컨테이너가 실행되었는지 알지 못하죠.&lt;/p&gt;
&lt;p&gt;이를 위해 1. PostgreSQL 컨테이너를 먼저 실행하고, 2. PostgreSQL 컨테이너를 실행할 때 컨테이너 이름을 붙이면(&lt;code&gt;db&lt;/code&gt;라고 하죠), 3. 앱 컨테이너에서는 &lt;code&gt;db&lt;/code&gt;라는 이름으로 접근할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    postgres:9.6.1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--name&lt;/code&gt;: postgres 컨테이너에 &lt;code&gt;db&lt;/code&gt;이라는 이름을 부여하였습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;: 환경변수를 설정하여 컨테이너를 실행할 수 있습니다. 여기서는 컨테이너 시작과 함께 djangosample 데이터베이스를 만들고(&lt;code&gt;POSTGRES_DB&lt;/code&gt;) sampleuser라는 사용자에게 접속 권한을 부여(&lt;code&gt;POSTGRES_USER&lt;/code&gt;, &lt;code&gt;POSTGRES_PASSWORD&lt;/code&gt;)합니다. (&lt;a href="https://hub.docker.com/_/postgres/"&gt;도커 허브의 공식 postgres 저장소&lt;/a&gt;에 가보면 설정할 수 있는 환경 변수 종류를 알 수 있습니다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제 앱 컨테이너에서 &lt;code&gt;db&lt;/code&gt;라는 이름을 사용하여 PostgreSQL 컨테이너에 접근할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    django-sample \
    ./manage.py runserver 0:8000
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--link&lt;/code&gt;: 참조할 다른 컨테이너를 선언합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제 두 번째 문제로 넘어가 보죠.&lt;/p&gt;
&lt;h4 id="132"&gt;1.3.2 앱 코드를 수정해도, 컨테이너 속 파일에는 반영되지 않음&lt;/h4&gt;
&lt;p&gt;컨테이너는 실행 직후부터 컨테이너 외부의 상황과 격리됩니다. 하지만 개발할 때는 보통 앱 코드를 수시로 바꾸고 개발 서버도 이를 감지하여 서버를 재시작합니다.&lt;/p&gt;
&lt;p&gt;이를 해결하고자 격리된 컨테이너에 통로를 하나 만듭니다. 수정할 앱 코드의 디렉터리를 앱 컨테이너 내부로 연결하여, 코드를 바꿀 때마다 컨테이너 속 코드도 바뀌게 해보겠습니다. &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt;를 눌러 앱 컨테이너를 종료한 후, 다시 다음 명령어를 실행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    --volume=$(pwd):/app/ \
    django-sample \
    ./manage.py runserver 0:8000
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--volume&lt;/code&gt;: 이 옵션을 사용하여 로컬 디렉터리의 특정 경로를 컨테이너 내부로 마운트할 수 있습니다. (&lt;code&gt;$(pwd)&lt;/code&gt;는 명령을 실행하는 현재 디렉터리의 절대 경로입니다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이제 마지막 문제입니다.&lt;/p&gt;
&lt;h4 id="133db"&gt;1.3.3 db 컨테이너를 지우면, 데이터베이스 데이터가 사라짐&lt;/h4&gt;
&lt;p&gt;앞에서 db 컨테이너를 실행하면서 &lt;code&gt;--rm&lt;/code&gt; 옵션을 지정했는데요. 이렇게 하면 db 컨테이너가 종료한 후 삭제되면서 컨테이너 내부에 쌓였던 데이터베이스 데이터들도 모두 사라집니다. 깔끔해서 좋긴 하지만 간혹 데이터베이스에 데이터를 남겨두면서 작업을 진행할 필요도 생기는데 말이죠.&lt;/p&gt;
&lt;p&gt;이 역시 &lt;code&gt;--volume&lt;/code&gt; 옵션을 사용하면 해결할 수 있습니다. db 컨테이너가 실행 중인 터미널에서 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt;를 눌러 컨테이너를 종료한 후, 다음 명령으로 다시 실행합시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    --volume=$(pwd)/docker/data:/var/lib/postgresql/data \
    postgres:9.6.1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--volume&lt;/code&gt;: 데이터베이스 데이터가 저장되는 컨테이너 내부의 디렉터리인 &lt;code&gt;/var/lib/postgresql/data&lt;/code&gt;를 로컬 컴퓨터의 디렉터리(&lt;code&gt;$(pwd)/docker/data&lt;/code&gt;)로 연결하면, 컨테이너 삭제와 상관 없이 데이터를 유지할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="14"&gt;1.4 재도전!&lt;/h3&gt;
&lt;p&gt;이제 도커의 &lt;code&gt;run&lt;/code&gt; 명령어는 모두 완성된 것 같으니, 모든 컨테이너를 종료한 후 다음과 같은 순서를 따라 컨테이너들을 재시작해봅시다.&lt;/p&gt;
&lt;h4 id="141db"&gt;1.4.1 이번엔 db 컨테이너부터 실행&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run -it --rm \
    --name db \
    -e POSTGRES_DB=djangosample \
    -e POSTGRES_USER=sampleuser \
    -e POSTGRES_PASSWORD=samplesecret \
    --volume=$(pwd)/docker/data:/var/lib/postgresql/data \
    postgres:9.6.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="142"&gt;1.4.2 앱 이미지 빌드&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker build -t django-sample .
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="143"&gt;1.4.3 앱 컨테이너 실행&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run -it --rm \
    -p 8000:8000 \
    --link db \
    -e DJANGO_DB_HOST=db \
    -e DJANGO_DEBUG=True \
    --volume=$(pwd):/app/ \
    django-sample \
    ./manage.py runserver 0:8000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;브라우저에서 &lt;a href="http://127.0.0.1:8000"&gt;http://127.0.0.1:8000&lt;/a&gt;을 열어보면 드디어 Django의 초기 화면을 만날 수 있습니다!&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/03/django-it-worked.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;p&gt;지금까지의 구성을 그림으로 그려보면 배포 환경과 거의 비슷해지겠죠.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/03/docker-native-develoment-environment2.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;h3 id="15"&gt;1.5 도커 방식의 불편함&lt;/h3&gt;
&lt;p&gt;도커로 개발 환경을 구성하는 데 성공하긴 했지만, 이번엔 다른 불편이 발생했습니다.&lt;/p&gt;
&lt;h4 id="151"&gt;1.5.1 장황한 옵션&lt;/h4&gt;
&lt;p&gt;첫 번째는 서버를 실행할 때마다 옵션을 적기가 귀찮습니다. 헷갈리기도 하고, 빼먹는 경우도 생깁니다. 그래서 옵션들을 미리 적어둘 수는 없을까 고민하게 되었습니다.&lt;/p&gt;
&lt;h4 id="152db"&gt;1.5.2 앱 컨테이너와 db 컨테이너의 실행 순서&lt;/h4&gt;
&lt;p&gt;반드시 db 컨테이너를 실행한 다음에야 앱 컨테이너를 실행해야 합니다. 그렇지 않으면 앱 컨테이너에서 db 컨테이너를 찾을 수 없기 때문이죠.&lt;/p&gt;
&lt;h3 id="16"&gt;1.6 도커 컴포즈&lt;/h3&gt;
&lt;p&gt;그때 &lt;a href="https://docs.docker.com/compose/"&gt;도커 컴포즈(Docker Compose)&lt;/a&gt;를 사용해 볼 마음이 생겼습니다. 컴포즈는 컨테이너 여럿을 띄우는 도커 애플리케이션을 정의하고 실행하는 도구(Tool for defining and running &lt;strong&gt;multi-container Docker applications&lt;/strong&gt;)입니다.&lt;/p&gt;
&lt;p&gt;컨테이너 실행에 필요한 옵션을 &lt;code&gt;docker-compose.yml&lt;/code&gt;이라는 파일에 적어둘 수 있고, 컨테이너 간 의존성도 관리할 수 있어서 안성맞춤이었지요.&lt;/p&gt;
&lt;p&gt;도커와 도커 컴포즈를 비교하면 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Dockerfile&lt;/code&gt; vs. &lt;code&gt;Dockerfile-dev&lt;/code&gt;: 서버 구성을 문서화한 것(=&lt;strong&gt;클래스 선언이 들어 있는 파일&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker build&lt;/code&gt; vs. &lt;code&gt;docker-compose build&lt;/code&gt;: 도커 이미지 만들기(=&lt;strong&gt;클래스 선언을 애플리케이션에 로드&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run&lt;/code&gt;의 옵션들 vs. &lt;code&gt;docker-compose.yml&lt;/code&gt;: 이미지에 붙이는 장식들(=&lt;strong&gt;인스턴스의 변수들&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run&lt;/code&gt; vs. &lt;code&gt;docker-compose up&lt;/code&gt;: 장식 붙은 이미지를 실제로 실행(=&lt;strong&gt;인스턴스 생성&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;도커 컴포즈에서는 컨테이너 실행에 사용되는 옵션과 컨테이너 간 의존성을 모두 &lt;code&gt;docker-compose.yml&lt;/code&gt;파일에 적어두고, 컴포즈용 명령어를 사용하여 컨테이너들을 실행, 관리합니다.&lt;/p&gt;
&lt;p&gt;클래스와 인스턴스의 예를 들면, 어떤 인스턴스를 자주 생성해야 해서 필요한 변수를 딕셔너리로 저장해두는 것과 비슷하겠습니다. 이를 그림으로 나타내면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/03/docker-compose-yml.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;h3 id="161"&gt;1.6.1 선행 조건&lt;/h3&gt;
&lt;p&gt;이후의 예시를 따라하려면 도커 엔진의 버전이 1.12.0 이상이어야 하고, docker-compose의 버전은 1.6.0 이상이어야 합니다. 최근에 도커를 설치했다면 큰 문제가 없을 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker version
Client:
 Version:      1.13.1
 API version:  1.26
 Go version:   go1.7.5
 Git commit:   092cba3
 Built:
 OS/Arch:      darwin/amd64

Server:
 Version:      1.13.1
 API version:  1.26 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   092cba3
 Built:        Wed Feb  8 08:47:51 2017
 OS/Arch:      linux/amd64
 Experimental: true
$ docker-compose version
docker-compose version 1.11.1, build 7c5d5e4
docker-py version: 2.0.2
CPython version: 2.7.12
OpenSSL version: OpenSSL 1.0.2j  26 Sep 2016
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 조건이 만족했다면 이제 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 만들어 봅시다.&lt;/p&gt;
&lt;h3 id="17dockercomposeyml"&gt;1.7 docker-compose.yml&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;은 옵션을 미리 정의한 문서라고 볼 수 있습니다. 프로젝트 루트에 파일을 만들고, 다음 내용을 붙여 넣습니다. (&lt;a href="https://gist.github.com/raccoonyy/2db75b86f73bc0b337a0c2c3f94709a1/79fe204485726b37ce73486fc93d73cef1b55004"&gt;gist 링크&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: '2.1'

services:
  db:
    image: postgres:9.6.1
    volumes:
      - ./docker/data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: &amp;quot;pg_isready -h localhost -p 5432 -q -U postgres&amp;quot;
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - &amp;quot;8000:8000&amp;quot;
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      - ./:/app/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 파일의 윗부분부터 한 줄씩 살펴봅시다.&lt;/p&gt;
&lt;h4 id="171version"&gt;1.7.1 version&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;version: '2.1'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;에서는 없었던 부분입니다. &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일의 제일 윗부분에는 파일 규격 버전을 적습니다. 파일의 규격에 따라 지원하는 옵션이 달라지며, 최근에 &amp;quot;3.1&amp;quot;이 등장하긴 했지만 보통은 &amp;quot;2&amp;quot;나 &amp;quot;2.1&amp;quot;을 사용해도 충분합니다. (파일 규격 버전에 따른 자세한 내용은 &lt;a href="https://docs.docker.com/compose/compose-file/compose-versioning/"&gt;compose 파일의 버전과 호환성을 안내한 공식 문서&lt;/a&gt;를 참고하세요.)&lt;/p&gt;
&lt;p&gt;여기서는 2.1 버전을 사용합니다.&lt;/p&gt;
&lt;h4 id="172services"&gt;1.7.2 services&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;services:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 항목 밑에 실행하려는 서비스들을 정의합니다. 서비스란, 앱 컨테이너나 postgres 컨테이너 각각의 묶음입니다.&lt;/p&gt;
&lt;h4 id="173db"&gt;1.7.3 db&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  db:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;postgres 서비스의 이름을 &lt;code&gt;db&lt;/code&gt;로 정하였습니다.&lt;/p&gt;
&lt;h4 id="174image"&gt;1.7.4 image&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    image: postgres:9.6.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;db&lt;/code&gt; 서비스에서 사용할 도커 이미지를 적습니다. 여기서는 &lt;a href="https://hub.docker.com/_/postgres/"&gt;dockerhub의 공식 postgres:9.6.1 이미지&lt;/a&gt;를 사용하였습니다.&lt;/p&gt;
&lt;h4 id="175volumes"&gt;1.7.5 volumes&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    volumes:
      - ./docker/data:/var/lib/postgresql/data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;으로 앱 컨테이너를 실행할 때 &lt;code&gt;--volume&lt;/code&gt; 옵션을 사용하여 데이터베이스의 데이터를 로컬 컴퓨터에 저장했던 부분과 같습니다. 다만 &lt;code&gt;docker-compose.yml&lt;/code&gt;의 &lt;code&gt;volumes&lt;/code&gt;에는 상대 경로를 지정할 수 있다는 점이 다릅니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;으로 앱 컨테이너를 실행할 때와 마찬가지로, 프로젝트 루트 아래의 &lt;code&gt;docker/data&lt;/code&gt; 디렉터리에 데이터를 저장하기로 했습니다.&lt;/p&gt;
&lt;h4 id="176environment"&gt;1.7.6 environment&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;에서 &lt;code&gt;-e&lt;/code&gt; 옵션에 적었던 내용들입니다. 마지막의 &lt;code&gt;POSTGRES_INITDB_ARGS&lt;/code&gt; 부분이 추가되었는데, 데이터베이스 서버의 인코딩을 설정하기 위함입니다.&lt;/p&gt;
&lt;h4 id="177healthcheck"&gt;1.7.7 healthcheck&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    healthcheck:
      test: &amp;quot;pg_isready -h localhost -p 5432 -q -U postgres&amp;quot;
      interval: 3s
      timeout: 1s
      retries: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;혹시 손이 빠른 분들 중에는, 앞서 &lt;code&gt;docker run&lt;/code&gt; 명령으로 앱 컨테이너를 띄울 때 개발 서버가 데이터베이스 서버에 접속하지 못하는 오류를 접하신 분들도 계실지 모르겠습니다. postgres 컨테이너가 실행 중인데도 말이죠.&lt;/p&gt;
&lt;p&gt;이는 postgres 컨테이너가 처음 실행되면서 데이터베이스나 사용자가 미처 생성되기 전에, 앱 컨테이너가 데이터베이스에 접근하려고 시도하기 때문입니다. 컴포즈에서도 마찬가지 문제가 발생하게 되는데요. 따라서 postgres 서비스가 제대로 실행될 뿐만 아니라 데이터베이스에 접근할 수 있는지도 파악을 해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;healthcheck&lt;/code&gt;는 바로 이것을 제어할 수 있습니다. 검사에 사용할 명령(&lt;code&gt;test&lt;/code&gt;)을 3초 간격(&lt;code&gt;interval&lt;/code&gt;)으로 열 번 시도(&lt;code&gt;retries&lt;/code&gt;)하며, 각 시도에서 타임아웃은 1초(&lt;code&gt;timeout&lt;/code&gt;)로 지정하였습니다.&lt;/p&gt;
&lt;p&gt;여기서 사용한 &lt;code&gt;pg_isready&lt;/code&gt; 명령은 데이터베이스 서버에 접근할 수 있는지를 파악합니다. (PostgreSQL 9.3부터 추가된 &lt;code&gt;pg_isready&lt;/code&gt; 명령에 대해서는 &lt;a href="https://www.postgresql.org/docs/9.3/static/app-pg-isready.html"&gt;PostgreSQL 문서의 pg_isready 부분&lt;/a&gt;을 참고하세요.)&lt;/p&gt;
&lt;p&gt;조금 장황한 듯 하지만, 앞으로는 이 옵션들을 일일이 타이핑하지 않아도 된다는 점을 생각하며 앱 서비스로 넘어가겠습니다.&lt;/p&gt;
&lt;h4 id="178django"&gt;1.7.8 django&lt;/h4&gt;
&lt;p&gt;앱 서비스의 이름은 &lt;code&gt;django&lt;/code&gt;로 지정하였습니다.&lt;/p&gt;
&lt;h4 id="179build"&gt;1.7.9 build&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;db 서비스와 달리 앱 서비스는 도커 이미지를 빌드할 일이 잦기 때문에, 특정 이미지 대신 &lt;code&gt;build&lt;/code&gt; 옵션을 추가합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;context&lt;/code&gt;는 &lt;code&gt;docker build&lt;/code&gt; 명령을 실행할 디렉터리 경로라고 보시면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dockerfile&lt;/code&gt;은 &lt;strong&gt;'개발용' 도커 이미지&lt;/strong&gt;를 빌드하는 데 사용할 Dockerfile을 지정하면 되는데요. 배포용 Dockerfile과 어떻게 다른지는 추후 설명하겠습니다.&lt;/p&gt;
&lt;h4 id="1710environment"&gt;1.7.10 environment&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;환경 변수는 그냥 &lt;code&gt;docker run&lt;/code&gt;을 할 때보다 좀더 자세하게 적었습니다. 각 값은 Django 설정 파일(&lt;code&gt;djangosample/settings.py&lt;/code&gt;)에서 사용합니다.&lt;/p&gt;
&lt;h4 id="1711ports"&gt;1.7.11 ports&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    ports:
      - &amp;quot;8000:8000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;도커 컴포즈로 서비스를 실행하면 기본적으로 가상의 네트워크가 하나 만들어지고, 네트워크 외부의 접근이 막힙니다. (도커 컨테이너가 그렇듯이요.) 따라서 외부에서 접근할 수 있는 포트를 지정해주어야 합니다. 여기서는 Django 개발 서버의 기본 포트는 8000을 지정하였습니다.&lt;/p&gt;
&lt;h4 id="1712depends_on"&gt;1.7.12 depends_on&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    depends_on:
      db:
        condition: service_healthy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;서비스가 하나 이상일 때, 실행 의존성을 지정할 수 있습니다. 여기서 지정한 내용은, &lt;code&gt;db&lt;/code&gt; 서비스가 실행된 후에 &lt;code&gt;django&lt;/code&gt; 서비스를 실행하겠다는 의미입니다. &lt;code&gt;contidion&lt;/code&gt; 뒤에는 서비스 시작(&lt;code&gt;service_started&lt;/code&gt;)이나 서비스 헬스체크 성공(&lt;code&gt;service_healthy&lt;/code&gt;)을 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db&lt;/code&gt; 서비스의 &lt;code&gt;healthcheck&lt;/code&gt; 부분과 여기서의 &lt;code&gt;service_healthy&lt;/code&gt; 부분이 서로 맞물리면, &lt;code&gt;db&lt;/code&gt; 서비스에서 데이터베이스 서버 접속이 가능해진 순간 이후에야, &lt;code&gt;django&lt;/code&gt; 서비스가 시작합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;depend_on&lt;/code&gt;에서 &lt;code&gt;condition&lt;/code&gt;을 지정하는 방식이 도커 컴포즈 파일 규격 3.0과 3.1에서는 제대로 작동하지 않는다고 합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="1713links"&gt;1.7.13 links&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    links:
      - db
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;에서 &lt;code&gt;--link&lt;/code&gt; 옵션에서 지정했던 내용입니다. 앱 컨테이너 안에서 db 서비스를 &lt;code&gt;db&lt;/code&gt;라는 이름으로 참조할 수 있습니다.&lt;/p&gt;
&lt;h4 id="1714command"&gt;1.7.14 command&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    command: /start-dev.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;으로 앱 컨테이너를 실행할 때 가장 마지막에 적었던 &lt;code&gt;./manage.py runserver 0:8000&lt;/code&gt;을 대신할 셀 스크립트 파일을 하나 만들었습니다. 다음은 &lt;code&gt;start-dev.sh&lt;/code&gt;의 내용입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;#!/bin/sh
python manage.py migrate
python manage.py runserver 0:8000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Django 마이그레이션을 따로 실행하기가 귀찮아서, 개발 서버 실행에 앞서 넣어두었습니다.&lt;/p&gt;
&lt;h4 id="1715volumes"&gt;1.7.15 volumes&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;    volumes:
      - ./:/app/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt;으로 앱 컨테이너를 실행할 때 프로젝트 루트 디렉터리를 컨테이너 안에 연결했던 부분과 같습니다.&lt;/p&gt;
&lt;p&gt;이렇게 해서 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 모두 살펴보았습니다.&lt;/p&gt;
&lt;h3 id="18"&gt;1.8 드디어 실행!&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;을 모두 작성했다면 드디어 서비스를 실행할 차례입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose up -d
Creating network &amp;quot;djangosample_default&amp;quot; with the default driver
Creating djangosample_db_1
Creating djangosample_django_1
Attaching to djangosample_db_1, djangosample_django_1
db_1          | Initializing database
... (DB 초기화 진행) ...
django_1      | Operations to perform:
django_1      |   Apply all migrations: admin, app, auth, contenttypes, myapp, sessions, sites
django_1      | Running migrations:
... (DB 마이그레이션 진행) ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="http://127.0.0.1:8000"&gt;http://127.0.0.1:8000&lt;/a&gt;에 접속해보면 개발 서버가 잘 작동함을 확인할 수 있습니다. 이를 그림으로 나타내면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/02/docker-compose-dev-env2.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;p&gt;각 컨테이너를 실행하던 길고 복잡한 명령어들이 사라졌고, 간단한 명령어 한 줄로 개발 서버와 데이터베이스를 모두 실행하였습니다. 이렇게 해서 개발 서버 구성이 모두 끝났습니다.&lt;/p&gt;
&lt;p&gt;그런데 앞에서 개발 서버용 Dockerfile이 따로 존재한다고 말했는데요. 이것 하나만 더 짚고 넘어가겠습니다.&lt;/p&gt;
&lt;h3 id="19dockerfilevsdockerfiledev"&gt;1.9 Dockerfile vs. Dockerfile-dev&lt;/h3&gt;
&lt;p&gt;크게 보자면, 개발 서버에는 필요 없는 내용을 지우고, 개발 서버에만 필요한 내용을 추가하면 됩니다.&lt;/p&gt;
&lt;p&gt;먼저, 개발 서버용 Dockerfile-dev에 필요 없는 내용을 살펴보겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-dockerfile"&gt;# 개발 서버용 Dockerfile-dev에서 뺄 부분들

# 앱 코드 복사
ADD ./app/      /app/

# Django 정적 파일 수집
RUN ./manage.py collectstatic --noinput

# 서버 실행 명령
CMD    ['supervisord', '-n']
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;앱 코드: 앱 코드는 컨테이너 안에 고정하지 않고 로컬 컴퓨터의 디렉터리를 참조하게 했기 때문에, 이 부분은 필요 없습니다. (&lt;code&gt;docker-compose.yml&lt;/code&gt;의 &lt;code&gt;volume&lt;/code&gt; 부분)&lt;/li&gt;
&lt;li&gt;정적 파일: 배포 환경에서 Django는 정적 파일을 직접 서빙하지 않고, nginx나 Apache 등에 맡기는데요. 지금은 개발 서버를 실행하려는 것이므로 이 과정이 필요 없죠.&lt;/li&gt;
&lt;li&gt;서버 실행: 한 컨테이너 안에서 Django용 uwsgi와 웹 서비스인 nginx를 실행하고자 프로세스 관리자인 supervisord를 사용하기도 하는데요. 개발 환경에서는 개발 서버만 실행하면 되니까 역시 삭제합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그 다음은 개발용 Dockerfile-dev에만 추가하는 내용입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-dockerfile"&gt;# 개발용 Dockerfile-dev에 추가할 부분들

# 개발 환경 구성에 필요한 파일 복사
COPY ./requirements-dev.txt /app/requirements-dev.txt
RUN  pip install -r requirements-dev.txt

# 개발 서버 실행에 필요한 파일 복사
ADD compose/django/start-dev.sh /start-dev.sh
RUN chmod +x /*.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;requirements-dev.txt&lt;/code&gt;: 개발 환경 구성에 사용할 패키지들을 &lt;code&gt;requirements-dev.txt&lt;/code&gt;에 정리한 후, 컨테이너에 넣고 설치(&lt;code&gt;pip install -r&lt;/code&gt;)합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start-dev.sh&lt;/code&gt;: 개발 서버 실행용 명령이 들어 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그래서 최종 &lt;code&gt;Dockerfile-dev&lt;/code&gt;의 내용은 다음과 같습니다. (&lt;a href="https://gist.github.com/raccoonyy/3674be1c8f24f6299b1949a92dbe5795"&gt;gist 링크&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-dockerfile"&gt;FROM python:3

RUN \
    apt-get update &amp;amp;&amp;amp;\
    apt-get -y install \
        libpq-dev \
        python-dev

WORKDIR /app

ADD    ./manage.py                    /app/
ADD    ./requirements.txt             /app/
ADD    ./requirements-dev.txt         /app/
RUN    pip install -r requirements.txt
RUN    pip install -r requirements-dev.txt

ADD    compose/django/start-dev.sh    /start-dev.sh
RUN    chmod +x /*.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="110"&gt;1.10 좀더 개선하기&lt;/h3&gt;
&lt;h4 id="1101"&gt;1.10.1 데이터베이스 저장소 관리&lt;/h4&gt;
&lt;p&gt;아울러, 기존의 &lt;code&gt;docker-compose.yml&lt;/code&gt;을 살짝 개선해 보겠습니다. (&lt;a href="https://gist.github.com/raccoonyy/2db75b86f73bc0b337a0c2c3f94709a1"&gt;gist 링크&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: '2.1'

# 변경 부분!
volumes:
  django_sample_db_dev: {}

services:
  db:
    image: postgres:9.6.1
    volumes:
      # 여기도 변경 부분!
      - django_sample_db_dev:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: &amp;quot;pg_isready -h localhost -p 5432 -U postgres&amp;quot;
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - &amp;quot;8000:8000&amp;quot;
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      # 마지막으로 여기도!
      - ./manage.py:/app/manage.py
      - ./requirements.txt:/app/requirements.txt
      - ./requirements-dev.txt:/app/requirements-dev.txt
      - ./djangosample:/app/djangosample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모두 volumes와 관련된 부분들인데요.&lt;/p&gt;
&lt;p&gt;처음 바뀐 부분에서는 도커가 관리하는 가상의 디스크를 &lt;code&gt;django_sample_db_dev&lt;/code&gt;라는 이름으로 만듭니다. 이렇게 만들어진 디스크는 &lt;code&gt;docker volume ls&lt;/code&gt; 명령으로 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이렇게 만든 가상 디스크를 두 번째 바뀐 부분에서 사용합니다. db 서비스가 로컬 디스크 대신 이 가상 디스크에 데이터를 쌓도록 하였습니다. (이렇게 하면 나중에 서비스를 지울 때 디스크도 함께 지울 수 있습니다.)&lt;/p&gt;
&lt;p&gt;마지막 바뀐 부분에서는 프로젝트 루트 전체를 컨테이너 안에 링크하는 대신, 특정 파일이나 폴더만 지정하였습니다. npm으로 노드 모듈을 설치한 경우 프로젝트 루트 밑의 &lt;code&gt;node_modules&lt;/code&gt; 디렉터리를 컨테이너 안에서도 참조하게 되는데, 이때 로컬 컴퓨터와 컨테이너 안의 유닉스 환경이 달라서 실행 파일이 제대로 실행되지 않는 문제를 피하기 위함입니다. (물론, 이는 &lt;code&gt;.dockerignore&lt;/code&gt; 파일로도 제어할 수 있겠습니다.)&lt;/p&gt;
&lt;h4 id="1102"&gt;1.10.2 패키지 설치 볼륨 추가&lt;/h4&gt;
&lt;p&gt;개발 환경이라는 특성상 의존 패키지를 추가하는 일이 잦은데요. 이때마다 도커 이미지를 새로 빌드하면서 의존 패키지를 전부 다시 설치하는 시간이 조금 낭비처럼 느껴집니다.&lt;/p&gt;
&lt;p&gt;이를 개선하고자 앱 컨테이너 내부의 파이썬 패키지가 설치되는 &lt;code&gt;/usr/local/lib/python3.6/site-packages/&lt;/code&gt; 디렉터리를 도커 볼륨으로 빼내겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;version: '2.1'

volumes:
  django_sample_db_dev: {}
  # 변경 부분!
  django_sample_packages: {}

services:
  db:
    image: postgres:9.6.1
    volumes:
      - django_sample_db_dev:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: &amp;quot;pg_isready -h localhost -p 5432 -U postgres&amp;quot;
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - &amp;quot;8000:8000&amp;quot;
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      - ./manage.py:/app/manage.py
      - ./requirements.txt:/app/requirements.txt
      - ./requirements-dev.txt:/app/requirements-dev.txt
      - ./djangosample:/app/djangosample
      - django_sample_packages:/usr/local/lib/python3.6/site-packages/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 볼륨을 활용하려면 &lt;code&gt;Dockerfile-dev&lt;/code&gt;와 &lt;code&gt;start-dev.sh&lt;/code&gt;도 조금 바꿔야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Dockerfile-dev&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-dockerfile"&gt;FROM python:3
MAINTAINER raccoony &amp;lt;raccoonyy@gmail.com&amp;gt;

RUN \
    apt-get update &amp;amp;&amp;amp;\
    apt-get -y install \
        libpq-dev \
        python-dev

WORKDIR /app

ADD    ./manage.py                    /app/
# 아래 주석 처리한 부분을 삭제합니다.
# ADD    ./requirements.txt             /app/
# RUN    pip install -r requirements.txt

ADD    compose/django/start-dev.sh       /start-dev.sh
RUN    chmod +x /*.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;start-dev.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;#!/bin/sh
# 추가된 부분
pip install -r requirements.txt
python manage.py migrate
gunicorn --workers=3 --bind 0:8000 djangosample.wsgi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 도커 이미지를 새로 만듭니다(&lt;code&gt;docker-compose up --build&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;이후부터는 컨테이너가 사라져도 의존 패키지들은 도커 볼륨(&lt;code&gt;django_sample_packages&lt;/code&gt;)에 모두 저장되어 있을 겁니다. &lt;code&gt;requirements.txt&lt;/code&gt;에 내용을 추가한 후에는 도커 이미지를 빌드할 필요 없이, 컨테이너를 새로 띄우기만 하면(&lt;code&gt;docker-compose up --force-recreate&lt;/code&gt;), 추가된 패키지가 설치됩니다.&lt;/p&gt;
&lt;h4 id="1103"&gt;1.10.3 컨테이너 재생성시 바이너리 파일이 없어지는 문제 수정&lt;/h4&gt;
&lt;p&gt;의존 패키지를 재설치하지 않아서 좋아졌지만, 단점이 생겼습니다. 컨테이너만 재생성할 경우 pytest나 flake8 등 이미 설치한 패키지들의 바이너리 파일들이 사라졌음을 확인할 수 있을 겁니다. 이는 pytest나 flake8 패키지를 설치할 때 &lt;code&gt;.py&lt;/code&gt; 파일들은 &lt;code&gt;django_sample_packages&lt;/code&gt; 볼륨에 설치되지만, 실행 파일들은 &lt;code&gt;/usr/local/bin&lt;/code&gt; 디렉터리에 복사되기 때문인데요.&lt;/p&gt;
&lt;p&gt;이를 해결하고자 &lt;code&gt;PYTHONUSERBASE&lt;/code&gt;와 &lt;code&gt;PATH&lt;/code&gt; 환경변수를 추가하고, pip 패키지 설치시 이 환경변수를 사용하게 해보겠습니다.&lt;/p&gt;
&lt;p&gt;먼저, &lt;code&gt;Dockerfile-dev&lt;/code&gt; 파일에 다음 내용을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-dockerfile"&gt;ENV PYTHONUSERBASE=/usr/local/
# 파이썬 버전에 따라 중간 경로인 python3.5 부분이 달라집니다.
ENV PATH=${PYTHONUSERBASE}lib/python3.5/site-packages/bin:${PATH}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 &lt;code&gt;start-dev.sh&lt;/code&gt; 파일의 &lt;code&gt;pip install&lt;/code&gt; 부분에 &lt;code&gt;--user&lt;/code&gt; 옵션을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;#!/bin/sh
pip install --user -r requirements.txt
python manage.py migrate
gunicorn --workers=3 --bind 0:8000 djangosample.wsgi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 파이썬용 바이너리 파일들이 &lt;code&gt;/usr/local/bin&lt;/code&gt; 대신 &lt;code&gt;/usr/local/lib/python3.5/site-packages/bin&lt;/code&gt;에 설치됩니다. 이 디렉터리는 &lt;code&gt;django_sample_packages&lt;/code&gt; 볼륨 속에 위치하기 때문에, 컨테이너가 재생성되더라도 바이너리 파일들이 삭제되지 않습니다.&lt;/p&gt;
&lt;h4 id="1104"&gt;1.10.4 파이썬 로그가 한 발 느리게 출력되는 문제 수정&lt;/h4&gt;
&lt;p&gt;이렇게 사용하다보니 간혹 파이썬 로그가 한 발 늦게 출력된다는 느낌을 받을 때가 있었습니다. 검색을 해보니 파이썬 출력 버퍼링이 기본으로 작동하기 때문이었는데요. 이 버퍼링을 없애려면 &lt;code&gt;PYTHONUNBUFFERED&lt;/code&gt; 환경변수를 추가하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Dockerfile-dev&lt;/code&gt;에 다음 내용을 추가합니다. (설정할 값은 0이든 1이든 상관 없고, 환경변수가 존재하기만 하면 됩니다.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-dockerfile"&gt;ENV PYTHONUNBUFFERED=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 해서 도커 컴포즈로 개발 환경을 어떻게 구성하는지 살펴보았습니다.&lt;/p&gt;
&lt;p&gt;이제 docker-compose에서 주로 사용하는 명령어들을 간략하게 훑어보겠습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="dockercompose"&gt;docker-compose의 주요 명령어&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;docker-compose&lt;/code&gt; 명령어를 짧은 alias로 등록해두면 편리합니다. 저는 oh-my-zsh에서 기본으로 제공하는 &lt;code&gt;dco&lt;/code&gt;를 사용하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="upd"&gt;up -d&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일의 내용에 따라 이미지를 빌드하고 서비스를 실행합니다. 자세한 진행 과정은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;서비스를 띄울 네트워크 설정&lt;/li&gt;
&lt;li&gt;필요한 볼륨 생성&lt;/li&gt;
&lt;li&gt;필요한 이미지 pull&lt;/li&gt;
&lt;li&gt;필요한 이미지 build&lt;/li&gt;
&lt;li&gt;서비스 의존성에 따라 서비스 실행&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;up&lt;/code&gt; 명령에 사용할 수 있는 몇 가지 옵션도 존재합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;: 서비스 실행 후 콘솔로 빠져나옵니다. (&lt;code&gt;docker run&lt;/code&gt;에서의 &lt;code&gt;-d&lt;/code&gt;와 같습니다.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--force-recreate&lt;/code&gt;: 컨테이너를 지우고 새로 만듭니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--build&lt;/code&gt;: 서비스 시작 전 이미지를 새로 만듭니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="ps"&gt;ps&lt;/h4&gt;
&lt;p&gt;현재 환경에서 실행 중인 서비스를 보여줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose ps
        Name                       Command               State           Ports
--------------------------------------------------------------------------------
djangosample_db_1       /docker-entrypoint.sh postgres   Up      5432/tcp
djangosample_django_1   /start-dev.sh                    Up      0.0.0.0:8000-&amp;gt;8000/tcp
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="stopstart"&gt;stop, start&lt;/h4&gt;
&lt;p&gt;서비스를 멈추거나, 멈춰 있는 서비스를 시작합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose stop
Stopping djangosample_django_1 ...
Stopping djangosample_db_1 ...

$ docker-compose start
Starting db ... done
Starting django ... done
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="down"&gt;down&lt;/h4&gt;
&lt;p&gt;서비스를 지웁니다. 컨테이너와 네트워크를 삭제하며, 옵션에 따라 볼륨도 지웁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose down --volume
Removing myproject_django_1 ... done
Removing myproject_db_1 ... done
Removing network djangosample_default
Removing volume django_sample_db_dev
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--volume&lt;/code&gt;: 볼륨까지 삭제합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="exec"&gt;exec&lt;/h4&gt;
&lt;p&gt;실행 중인 컨테이너에서 명령어를 실행합니다. 자동화된 마이그레이션용 파일 생성이나 유닛 테스트, lint 등을 실행할 때 사용합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose exec django ./manage.py makemigrations
...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose exec node npm run test
&amp;gt; expresssample@0.1.0 test /www/service
&amp;gt; mocha $(find test -name '*.spec.js')
...
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;비슷한 명령으로 &lt;code&gt;run&lt;/code&gt;이 존재합니다. &lt;code&gt;run&lt;/code&gt;은 새 컨테이너를 만들어서 명령어를 실행합니다. &lt;code&gt;docker run&lt;/code&gt;과 마찬가지로 &lt;code&gt;--rm&lt;/code&gt; 옵션을 추가하지 않으면, 컨테이너가 종료된 후에도 삭제되지 않습니다. (이런 이유 때문에 개인적으로는 &lt;code&gt;exec&lt;/code&gt;를 선호합니다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="logs"&gt;logs&lt;/h4&gt;
&lt;p&gt;서비스의 로그를 확인할 수 있습니다. &lt;code&gt;logs&lt;/code&gt; 뒤에 서비스 이름을 적지 않으면 도커 컴포즈가 관리하는 모든 서비스의 로그를 함께 보여줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose logs django
Attaching to djangosample_django_1
django_1     | System check identified no issues (0 silenced).
django_1     | February 13, 2017 - 16:32:28
django_1     | Django version 1.10.4, using settings 'djangosample.settings'
django_1     | Starting development server at http://0.0.0.0:8000/
django_1     | Quit the server with CONTROL-C.
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;: 지금까지 쌓인 로그를 다 보여준 후에도 셸로 빠져나오지 않고, 로그가 쌓일 때마다 계속해서 출력합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;마지막으로, 몇 가지 삽질 경험을 바탕으로 나름의 팁을 정리해보겠습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=""&gt;나름의 팁&lt;/h3&gt;
&lt;h4 id="1dockercomposeyml"&gt;1. docker-compose.yml을 수정했다면?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 수정하고 이를 서비스에 적용하려면 서비스를 멈추고(&lt;code&gt;stop&lt;/code&gt;), 서비스를 지우고(&lt;code&gt;rm&lt;/code&gt;), 서비스를 시작해야(&lt;code&gt;up&lt;/code&gt;) 합니다.&lt;/p&gt;
&lt;p&gt;하지만 &lt;code&gt;up&lt;/code&gt; 명령만 실행해도, (현재 실행 중인 서비스 설정과 달라진 부분이 있다면) &lt;strong&gt;알아서 컨테이너를 재생성하고 서비스를 재시작&lt;/strong&gt;해줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose up -d [&amp;lt;서비스 이름&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;혹시 컨테이너를 재생성하지 않는 것 같다면, &lt;code&gt;--force-recreate&lt;/code&gt; 옵션을 붙이면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="2dockerfiledev"&gt;2. Dockerfile-dev 파일을 수정했다면?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Dockerfile-dev&lt;/code&gt; 파일을 수정했을 땐 &lt;code&gt;build&lt;/code&gt; 명령을 사용하여 도커 이미지를 새로 만들어야 합니다. 이후 서비스 중지와 삭제, 재시작을 해야 하죠.&lt;/p&gt;
&lt;p&gt;하지만 &lt;code&gt;up&lt;/code&gt; 명령에 다음과 같이 &lt;code&gt;--build&lt;/code&gt; 옵션을 넣으면 &lt;strong&gt;알아서 이미지를 새로 만들고 서비스를 재시작&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose up -d --build [&amp;lt;서비스 이름&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="3dockerfiledev"&gt;3. Dockerfile-dev도 신경 써야 함&lt;/h4&gt;
&lt;p&gt;개발용 Dockerfile과 배포용 Dockerfile이 따로 존재한다는 점을 꼭 기억해야 합니다. 간혹 &lt;code&gt;Dockerfile&lt;/code&gt;만 고치면서 개발 환경에서 **'외않돼?'**라고 생각한 경우가 있습니다. ;;&lt;/p&gt;
&lt;p&gt;(&lt;code&gt;Dockerfile&lt;/code&gt;에도 다른 &lt;code&gt;Dockerfile&lt;/code&gt;을 참조한다는 개념이 있으면 좋을 텐데... 싶습니다.)&lt;/p&gt;
&lt;h4 id="4"&gt;4. 데이터베이스 내용도 지우고 싶다면&lt;/h4&gt;
&lt;p&gt;열심히 개발하다 보면 데이터베이스에 원치 않는 데이터가 남는 경우가 있습니다. 데이터베이스에 접속해서 테이블을 삭제하거나 할 수도 있겠지만, &lt;code&gt;down&lt;/code&gt; 명령에 &lt;code&gt;--volume&lt;/code&gt; 옵션을 추가하면 서비스에서 사용하는 볼륨(=데이터베이스 데이터가 저장되는 곳)을 삭제하기 때문에, 데이터베이스를 깨끗하게 초기화할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker-compose down --volume
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="5mysqlpostgresql"&gt;5. MySQL보다는 PostgreSQL이 조금 더 편한 듯&lt;/h4&gt;
&lt;p&gt;로컬 컴퓨터에 데이터베이스 서버가 없어도, 서비스를 시작하기만 하면 알아서 데이터베이스 서버가 시작된다는 점은 굉장한 매력이었습니다. 그런데 MySQL보다는과 PostgreSQL의 초기화 과정에 걸리는 시간이 꽤 차이가 나더군요.&lt;/p&gt;
&lt;p&gt;제 컴퓨터 기준이긴 하지만 MySQL보다는 초기화에는 대략 15초, PostgreSQL 초기화에 대략 5초 남짓한 시간이 걸립니다. 데이터베이스 초기화가 자주 필요한 일은 아니지만 그래도 15초와 5초의 차이는 꽤 크죠.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아울러, 데이터를 로컬에 쌓기보다는 도커가 관리하는 가상 디스크를 사용하는 편이 속도 면에서 좀더 유리합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="6errornospaceleftondevice"&gt;6. &lt;code&gt;ERROR: 'No space left on device'&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;도커를 열심히 사용하고 있는데 갑자기 다음과 같은 메시지가 뜨면서 새 이미지를 빌드할 수 없다고 하더군요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR: 'No space left on device'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하드디스크에 용량이 엄청 많이 남아 있었는데도 말이죠. 부랴부랴 검색을 해보니, Docker for OS X에서 사용하는 가상 파일 시스템의 기본 최대 값이 64기가바이트여서 발생한 문제였습니다.&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;주의! 다음 내용을 진행하면 도커 이미지와 컨테이너, 볼륨이 모두 사라집니다.&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;이 경우 Docker for OS X의 환경 설정 &lt;code&gt;Reset&lt;/code&gt; 버튼을 누르면 해결됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/03/docker-for-os-x-reset2-copy.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reset&lt;/code&gt;하기가 무섭다면, Docker for OS X를 종료한 후 다음 파일을 삭제하고서 Docker for OS X를 실행하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/Users/(LOGIN_ID)/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/Docker.qcow2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;정확한 위치는 Docker for OS X의 환경 설정에서 Advanced 탭에 들어가 보면 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/03/docker-for-os-x-location-copy.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/p&gt;
&lt;h4 id="7pyenv23"&gt;7. pyenv 없이 파이썬2와 파이썬3을 오갈 수 있음&lt;/h4&gt;
&lt;p&gt;회사에서 개발한 라이브러리에 파이썬3 호환성을 추가할 때도 이 방식을 사용해보았습니다. 파이썬3을 로컬 컴퓨터에 설치하지 않고 간단한 &lt;code&gt;docker-compose.yml&lt;/code&gt;을 작성하여(사용한 이미지는 도커 공식 저장소의 &lt;code&gt;python:3&lt;/code&gt;) 서비스를 띄운 후 테스트를 실행해가며, 호환성이 없는 부분을 찾아내고 수정할 수 있었습니다.&lt;/p&gt;
&lt;h4 id="8ghost"&gt;8. 로컬에서 Ghost 블로그 운영하기&lt;/h4&gt;
&lt;p&gt;자세한 내용은 다음 블로그 글을 참고하세요. :)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://raccoonyy.github.io/docker-for-ghost-blogging/"&gt;Docker 활용법 - Ghost 블로그 운영하기 by raccoony&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
&lt;a href="http://raccoonyy.github.io/docker-for-ghost-blogging/"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/01/docker-for-ghost-blogging.png" alt="Docker (Compose) 활용법 - 개발 환경 구성하기"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;이렇게 해서 개발 환경 구성하기를 마쳤습니다. 장황해보이지만, 실제로는 한 번 잘 구성해 두면 다른 프로젝트에는 그저 옮겨 붙이는 정도로 쉽게 적용할 수 있을 겁니다.&lt;/p&gt;
&lt;p&gt;마지막으로, 글을 미리 읽고 검토해주신 &lt;a href="https://twitter.com/@nacyo_t"&gt;@nacyo_t&lt;/a&gt;님께 감사의 마음을 전합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;도커를 배우고 나면&lt;br&gt;모든 것이 컨테이너로 보인다&lt;br&gt;
&lt;small&gt;--raccoony&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--kg-card-end: markdown--&gt;&lt;!--kg-card-end: markdown--&gt;</content:encoded></item><item><title>Docker 활용법 - Ghost 블로그 Github에서 운영하기</title><description>Docker를 활용하여 블로깅 도구인 [Ghost](https://ghost.org/)와 정적 사이트 생성을 편리하게 구축해 보았습니다. # 처음엔 Ghost + Buster # 다음엔 Docker 도입 # 마지막으로 Docker-Compose까지 도입</description><link>http://raccoonyy.github.io/docker-for-ghost-blogging/</link><guid isPermaLink="false">59815cfcdd47a80001bb9f09</guid><category>docker</category><category>ghost</category><category>blogging</category><category>docker-compose</category><category>buster</category><category>github</category><dc:creator>raccoony</dc:creator><pubDate>Thu, 02 Feb 2017 02:09:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2017/01/docker-for-ghost-blogging.png" medium="image"/><content:encoded>&lt;blockquote&gt;
&lt;img src="http://raccoonyy.github.io/content/images/2017/01/docker-for-ghost-blogging.png" alt="Docker 활용법 - Ghost 블로그 Github에서 운영하기"&gt;&lt;p&gt;Docker를 활용하여 블로깅 도구인 &lt;a href="https://ghost.org/"&gt;Ghost&lt;/a&gt;와 &lt;a href="https://github.com/raccoonyy/buster"&gt;Buster&lt;/a&gt;를 활용하여 정적 블로그 생성을 편리하게 구축해 보았습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=""&gt;요약&lt;/h2&gt;
&lt;p&gt;다음 깃헙 저장소를 다운받은 후, &lt;code&gt;.env&lt;/code&gt; 파일을 수정하고 나서 &lt;code&gt;docker-compose up -d&lt;/code&gt;하면 블로깅 환경 완성! (필요한 건 오직 Docker뿐.)&lt;/p&gt;
&lt;div class="github-card" data-github="raccoonyy/docker-compose-ghost-buster" data-width="640" data-height="173" data-theme="default"&gt;&lt;/div&gt;
&lt;script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"&gt;&lt;/script&gt;
&lt;h2 id=""&gt;이 글에서 사용하는 도구들&lt;/h2&gt;
&lt;h4 id="ghost"&gt;&lt;a href="https://ghost.org"&gt;Ghost&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://ghost.org"&gt;Ghost&lt;/a&gt;는 깔끔한 외관과 편리한 관리 기능으로 많은 분들에게 사랑을 받고 있는 Node.js 기반의 블로깅 도구입니다. 호스팅형은 사용료가 월 $29여서 꽤 부담이 되지만, &lt;a href="https://github.com/TryGhost/Ghost/"&gt;오픈소스로 공개된 소스코드&lt;/a&gt;를 직접 설치하는 경우에는 무료라서 처음에는 설치형을 많이들 선택합니다.&lt;/p&gt;
&lt;h4 id="buster"&gt;&lt;a href="https://github.com/axitkhurana/buster"&gt;Buster&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Ghost를 로컬에서 실행한 후, 여기서 만들어진 HTML 파일을 긁어서(=정적 사이트 생성) 깃헙에 올리는 방식으로 블로그를 운영하는 경우도 많은데요. Buster는 이때 사용하는 파이썬 기반 도구입니다.&lt;/p&gt;
&lt;h2 id=""&gt;일반적인 구성&lt;/h2&gt;
&lt;p&gt;Ghost와 Buster를 사용하여 정적 사이트를 생성하는 가장 일반적인 방법은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ghost용 Node 설치, Buster용 파이썬 설치&lt;/li&gt;
&lt;li&gt;Ghost와 Buster를 로컬에 설치&lt;/li&gt;
&lt;li&gt;Ghost 서버를 띄워 글 작성&lt;/li&gt;
&lt;li&gt;Buster로 정적 사이트 생성 후 깃헙에 푸시&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이를 명령어로 정리하면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;# Ghost 설치 (Node v4 필요)
$ git clone git://github.com/tryghost/ghost.git
$ cd ghost
$ npm install --production

# Buster 설치 (파이썬 2 필요)
$ pip install buster

# Ghost 실행
$ npm start

# Buster 설정
$ python buster setup --gh-repo=...

# 정적 사이트 생성
$ python buster generate 

# 깃헙에 푸시
$ python buster deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 그림으로 정리하면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#1 복잡해 보이는 Ghost - Buster 구성&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/01/ghost-buster-native-4.png" alt="Docker 활용법 - Ghost 블로그 Github에서 운영하기"&gt;&lt;/p&gt;
&lt;h4 id=""&gt;일반적인 구성의 불편함&lt;/h4&gt;
&lt;p&gt;저도 처음엔 이 구성을 사용했지만, 크게 두 가지 문제를 겪었습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ghost 업그레이드에 따른 Node 버전 관리&lt;/li&gt;
&lt;li&gt;Buster 개발 중단&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ghost는 초기에 Node 0.10을 사용했고, 한동안 0.12에 머물다가 최근 들어 Node v4를 지원하고 있습니다. (&lt;a href="http://support.ghost.org/supported-node-versions/"&gt;Ghost가 지원하는 Node 버전 안내&lt;/a&gt;를 참고) 이것이 크게 문제는 아니었지만 당시엔 제가 Node에 익숙하지 않아서, Ghost 서버를 실행할 때마다 &lt;code&gt;nvm use 0.12&lt;/code&gt;를 까먹곤 했습니다.&lt;/p&gt;
&lt;p&gt;더 불편한 것은 Buster가 Ghost 최신 버전에 맞춰 바뀌지 않는다는 점이었습니다. 마지막 커밋이 무려 2년 전에 머물러 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/01/Screenshot-2017-01-21-10.20.01.png" alt="Docker 활용법 - Ghost 블로그 Github에서 운영하기"&gt;&lt;/p&gt;
&lt;p&gt;하지만 지난 2년 간 Ghost는 버전 업을 거듭했고, 이에 따라 오리지널 Buster는 HTML 파싱을 제대로 못하거나 RSS 생성이 안 되는 등 다양한 문제가 발생하였습니다. 이를 해결하고자 처음엔 로컬에 설치된 Buster 소스를 조금씩 고쳐갔는데, 고치다보니 버전 관리도 안 되고 해서 아예 &lt;a href="https://github.com/raccoonyy/buster"&gt;제 저장소로 포크&lt;/a&gt;를 했습니다.&lt;/p&gt;
&lt;p&gt;그리고, 원본 Buster의 &lt;a href="https://github.com/axitkhurana/buster/network"&gt;포크 기록&lt;/a&gt;을 보면서 최신 Ghost에 맞춰 수정한 커밋들을 참고하여 제 저장소도 수정했습니다.&lt;/p&gt;
&lt;p&gt;마지막으론 Buster에서 자주 사용하는 명령들을 모아 &lt;code&gt;fabfile.py&lt;/code&gt;도 작성하였습니다.&lt;/p&gt;
&lt;p&gt;이렇게 블로그를 운영하던 중 2016년 말에 맥북을 바꾸게 되었는데, 또다시 블로깅 환경을 구성하는 지옥을 경험하기 싫었기에 Docker를 도입해 보기로 했습니다.&lt;/p&gt;
&lt;h2 id="docker"&gt;Docker 도입&lt;/h2&gt;
&lt;p&gt;일단 Docker로 Ghost를 띄워 보기로 했습니다. 마침 &lt;a href="https://hub.docker.com/"&gt;Docker Hub&lt;/a&gt;에 &lt;a href="https://hub.docker.com/_/ghost/"&gt;Ghost 공식 이미지&lt;/a&gt;가 존재해서 다음과 같이 시도해보았습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run \
    --publish 2368:2368
    --name my-ghost \
    -d ghost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--publish&lt;/code&gt; 옵션을 사용하여 로컬의 2368 포트와 컨테이너의 2368 포트를 연결했고요. 컨테이너 이름은 &lt;code&gt;my-ghost&lt;/code&gt;라고 정했습니다. 저렇게 실행하고 &lt;a href="http://127.0.0.1:2368/ghost"&gt;http://127.0.0.1:2368/ghost&lt;/a&gt;에 접속했더니 Ghost 관리자 등록 화면이 저를 반겨주더군요.&lt;/p&gt;
&lt;h4 id="dockerfile"&gt;Dockerfile&lt;/h4&gt;
&lt;p&gt;이제 Buster를 Docker 환경으로 꾸밀 차례입니다. 다음과 같은 &lt;code&gt;Dockerfile&lt;/code&gt;을 작성했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-dockerfile"&gt;# Dockerfile
FROM python:2
USER root
ENV LOGNAME raccoony

RUN pip install git+https://github.com/raccoonyy/buster.git#egg=buster
RUN mkdir /deploy

WORKDIR /deploy
COPY scripts/      /deploy/
RUN  chmod a+x     /deploy/*.sh

CMD [&amp;quot;./run.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Buster는 파이썬 2 기반이므로 공식 파이썬 2 이미지를 사용했고, &lt;a href="https://github.com/raccoonyy/buster"&gt;제 저장소에 포크한 Buster&lt;/a&gt;를 설치하였습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fabfile.py&lt;/code&gt;에서 처리하던 명령들은 &lt;code&gt;scripts&lt;/code&gt; 디렉터리 아래의 스크립트 파일들로 옮겼습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="runsh"&gt;run.sh&lt;/h4&gt;
&lt;p&gt;다음은 &lt;code&gt;run.sh&lt;/code&gt; 파일의 내용입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;#!/usr/bin/env bash

git config --global push.default simple
git config --global user.name raccoony
git config --global user.email raccoonyy@gmail.com

cd /deploy
git clone git@github.com:raccoonyy/raccoonyy.github.com.git static
cd /deploy/static
git branch --track master origin/master

python -m SimpleHTTPServer 1234
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;run.sh&lt;/code&gt;는 Buster용 컨테이너의 기초 작업을 수행합니다.&lt;/li&gt;
&lt;li&gt;Git 설정을 마치면, 제 블로그용 저장소를 받아오고, 더미용 파이썬 웹 서버를 하나 띄웁니다. (웹 서버는 그저 컨테이너를 실행 상태로 유지시키는 일만 합니다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="generatesh"&gt;generate.sh&lt;/h4&gt;
&lt;p&gt;다음은 &lt;code&gt;generate.sh&lt;/code&gt; 파일의 내용입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;#!/usr/bin/env bash

wget -O ./static/rss/index.rss http://ghost:2368/rss/

buster generate --github-id=raccoonyy --domain=http://ghost:2368/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;generate.sh&lt;/code&gt;는 my-ghost 컨테이너에서 실행 중인 Ghost 서버를 크롤링하여 &lt;code&gt;/deploy/static&lt;/code&gt; 디렉터리에 정적 사이트 파일을 생성합니다.&lt;/li&gt;
&lt;li&gt;Buster에서 RSS 파일을 크롤링하지 못하는 듯 하여, wget 명령으로 미리 RSS 파일을 만들기도 했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="previewsh"&gt;preview.sh&lt;/h4&gt;
&lt;p&gt;다음은 &lt;code&gt;preview.sh&lt;/code&gt; 파일의 내용입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;#!/usr/bin/env bash

buster preview
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;preview.sh&lt;/code&gt;는 미리보기용 Buster 웹 서버를 띄웁니다. (9000 포트로 접근할 수 있습니다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="deploysh"&gt;deploy.sh&lt;/h4&gt;
&lt;p&gt;다음은 &lt;code&gt;deploy.sh&lt;/code&gt; 파일의 내용입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;#!/usr/bin/env bash

buster deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;deploy.sh&lt;/code&gt;는 컨테이너 내부의 &lt;code&gt;/deploy/static&lt;/code&gt; 디렉터리를 블로그용 저장소에 푸시하는 Buster 명령을 실행합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=""&gt;실제 운영&lt;/h4&gt;
&lt;p&gt;이제 앞에서 만든 &lt;code&gt;Dockerfile&lt;/code&gt;을 사용하여 Docker 이미지를 만들고...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker build -t raccoony/buster .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음 명령으로 Buster 실행용 컨테이너를 실행하였습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker run --rm \
    --link my-ghost:ghost \
    --volume /SSH/:/root/.ssh/ \
    --name buster \
    -d raccoony/buster
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--link&lt;/code&gt; 옵션에서는 &lt;code&gt;my-ghost&lt;/code&gt; 컨테이너를 &lt;code&gt;ghost&lt;/code&gt;라는 이름으로 참조하겠다고 명시했습니다.&lt;/li&gt;
&lt;li&gt;개인적으로는 깃헙에 푸시할 때 개인키 로그인 방식을 사용하고 있습니다. 이를 buster 컨테이너 안에서도 사용하기 위해 &lt;code&gt;--volume&lt;/code&gt; 옵션에서 로컬의 개인키 디렉터리를 컨테이너 안으로 연결했고요. (개인키는 &lt;code&gt;buster deploy&lt;/code&gt;에 필요합니다. &lt;code&gt;/SSH/&lt;/code&gt; 부분은 로컬 컴퓨터의 개인키 저장 위치입니다.)&lt;/li&gt;
&lt;li&gt;컨테이너 이름은 &lt;code&gt;buster&lt;/code&gt;로 지정하였습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이렇게 컨테이너를 띄운 후 실제 사용할 때는 다음처럼 buster 컨테이너에 붙어 셸 스크립트를 실행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;# 정적 사이트 생성
$ docker exec buster ./generage.sh

# 미리보기
$ docker exec buster ./preview.sh

# 배포
$ docker exec buster ./deploy.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기까지의 상황을 그림으로 정리하면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#2 구성은 단순해졌지만 명령어가 복잡해진 Ghost - Buster with Docker 구성&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/01/ghost-buster-docker-2.png" alt="Docker 활용법 - Ghost 블로그 Github에서 운영하기"&gt;&lt;/p&gt;
&lt;p&gt;설치부터 실행까지의 명령어가 단촐해졌음을 확인할 수 있습니다.&lt;/p&gt;
&lt;h4 id="docker"&gt;Docker 구성의 불편함&lt;/h4&gt;
&lt;p&gt;이제 끝내고 싶었지만 또다른 불편함이 있었습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;복잡한 옵션을 매번 적기가 귀찮음&lt;/li&gt;
&lt;li&gt;Ghost 컨테이너 띄우고, 이어서 Buster 컨테이너를 띄우는 작업을 한 명령으로 처리할 수는 없을까?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;다른 것보다는 복잡한 옵션들을 매번 적어주기가 귀찮았습니다. 그러던 차에 Docker Compose라는 도구가 떠올랐습니다. 얼핏 보기엔 옵션을 미리 적어둘 수 있고, 컨테이너를 여럿 묶어서 순서대로 실행하기에도 편한 도구라고 생각했습니다.&lt;/p&gt;
&lt;h2 id="dockercompose"&gt;Docker Compose 도입&lt;/h2&gt;
&lt;p&gt;역시나 Ghost를 Docker Compose로 띄워보기 위해 다음과 같은 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 작성하였습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;# docker-compose.yml
version: '2'

services:
  ghost:
    image: ghost
    ports:
     - &amp;quot;2368:2368&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 다음과 같은 명령으로 컨테이너를 실행할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose up
ghost_1   | npm info it worked if it ends with ok
ghost_1   | npm info using npm@2.15.11
ghost_1   | npm info using node@v4.7.2
ghost_1   | npm info prestart ghost@0.11.4
ghost_1   | npm info start ghost@0.11.4
ghost_1   |
ghost_1   | &amp;gt; ghost@0.11.4 start /usr/src/ghost
ghost_1   | &amp;gt; node index
ghost_1   |
ghost_1   | WARNING: Ghost is attempting to use a direct method to send email.
ghost_1   | It is recommended that you explicitly configure an email service.
ghost_1   | Help and documentation can be found at http://support.ghost.org/mail.
ghost_1   |
ghost_1   | Ghost is running in production...
ghost_1   | Your blog is now available on http://raccoonyy.github.io
ghost_1   | Ctrl+C to shut down
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기에 Buster 컨테이너도 함께 띄우기 위해 &lt;code&gt;docker-compose.yml&lt;/code&gt; 파일을 수정하였습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;# docker-compose.yml (수정)
version: '2'

services:
  ghost:
    image: ghost
    ports:
     - &amp;quot;2368:2368&amp;quot;

  buster:
    image: raccoony/buster
    links:
      - ghost
    depends_on:
      - ghost
    environment:
      - PUBLIC_URL=raccoonyy.github.io
      - GIT_REPO=git@github.com:raccoonyy/raccoonyy.github.com.git
    volumes:
      - ~/.ssh/id_rsa:/root/.ssh/id_rsa
      - ~/.ssh/known_hosts:/root/.ssh/known_hosts
    ports:
      - &amp;quot;9000:9000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 컨테이너를 다시 띄워봅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose down &amp;amp;&amp;amp; docker-compose up
Attaching to blog_ghost_1, blog_buster_1
ghost_1   | npm info it worked if it ends with ok
buster_1  | Cloning into 'static'...
ghost_1   | npm info using npm@2.15.11
ghost_1   | npm info using node@v4.7.2
ghost_1   | npm info prestart ghost@0.11.4
ghost_1   | npm info start ghost@0.11.4
ghost_1   |
ghost_1   | &amp;gt; ghost@0.11.4 start /usr/src/ghost
ghost_1   | &amp;gt; node index
ghost_1   |
ghost_1   | WARNING: Ghost is attempting to use a direct method to send email.
ghost_1   | It is recommended that you explicitly configure an email service.
ghost_1   | Help and documentation can be found at http://support.ghost.org/mail.
ghost_1   |
ghost_1   | Ghost is running in production...
ghost_1   | Your blog is now available on http://raccoonyy.github.io
ghost_1   | Ctrl+C to shut down
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;buster 컨테이너에 들어가 보겠습니다. &lt;code&gt;/deploy&lt;/code&gt; 디렉터리에는 buster 운영에 필요한 스크립트들이 들어 있고, &lt;code&gt;/deploy/static&lt;/code&gt; 디렉터리에는 블로그용 저장소의 최신 버전이 다운로드되어 있습니다. (인터넷 연결이 끊긴 상태에서는 블로그용 저장소를 연결하지 못해서 &lt;code&gt;/deploy/static&lt;/code&gt; 디렉터리가 생성되지 않습니다.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ docker-compose exec buster bash
root@ec7c576f1615:/deploy# ls
deploy.sh  generate.sh  preview.sh  run.sh  static
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 상태에서 바로 &lt;code&gt;generate.sh&lt;/code&gt;를 실행해도 되고, 이미 컨테이너 접속을 끊은 상태라면 &lt;code&gt;docker-compose exec buster ./generate.sh&lt;/code&gt;처럼 실행할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;블로그 운영 관련 명령들은 다음과 같이 바뀌었습니다. (개인적으론 docker-compose를 많이 사용하게 되면서 &lt;code&gt;dco&lt;/code&gt;라는 축약어로 등록하였습니다.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;# 정적 사이트 생성
$ docker-compose exec buster ./generage.sh

# 미리보기
$ docker-compose exec buster ./preview.sh

# 배포
$ docker-compose exec buster ./deploy.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;구성은 크게 바뀌지 않았지만, 실행해야 하는 명령어들은 좀더 단촐해졌습니다. (저한테는 이 부분이 컸습니다.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#3 구성과 명령어 모두 단촐해진 Ghost - Buster with Docker Compose 구성&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2017/01/ghost-buster-docker-compose-3.png" alt="Docker 활용법 - Ghost 블로그 Github에서 운영하기"&gt;&lt;/p&gt;
&lt;h2 id=""&gt;결말&lt;/h2&gt;
&lt;p&gt;블로그 하나 운영하면서 뭐 이렇게 복잡한 과정을 거치냐고 생각하실 수도 있겠지만, 이제는 맥북을 바꾸거나 심지어 윈도 10 환경에서도 블로깅을 할 수 있다는 장점이 가장 크다고 생각합니다.&lt;/p&gt;
&lt;p&gt;지금까지 진행한 내용은 다음 저장소에 모두 정리해두었고, 개인 정보들은 환경변수로 만들어 두었습니다. 필요한 분들은 저장소를 다운받은 후 &lt;code&gt;.env&lt;/code&gt; 파일을 수정하고서 &lt;code&gt;docker-compose up -d&lt;/code&gt;하시면 되겠습니다. (아! 물론 Docker가 설치되어 있어야 합니다. 다른 건 다 필요 없고 Docker만요!)&lt;/p&gt;
&lt;div class="github-card" data-github="raccoonyy/docker-compose-ghost-buster" data-width="640" data-height="173" data-theme="default"&gt;&lt;/div&gt;
&lt;script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"&gt;&lt;/script&gt;</content:encoded></item><item><title>Docker 1.13 릴리스 요약</title><description>1월 19일에 출시된 Docker 1.13에서 바뀐 점을 요약하였습니다. #1 swarm 실행시 compose 파일 사용 #2 데몬과 클라이언트 호환성 향상 #3 청소용 명령어 #4 명령어 구조 변경 #5 swarm 모니터링 개선 #6 빌드 개선 #7 AWS, Azure 지원(베타)</description><link>http://raccoonyy.github.io/whats-new-in-docker-1-13-korean/</link><guid isPermaLink="false">59815cfcdd47a80001bb9f0f</guid><category>docker</category><category>1.13</category><category>릴리스 노트</category><dc:creator>raccoony</dc:creator><pubDate>Fri, 20 Jan 2017 02:15:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2017/01/docker1-13.png" medium="image"/><content:encoded>&lt;blockquote&gt;
&lt;img src="http://raccoonyy.github.io/content/images/2017/01/docker1-13.png" alt="Docker 1.13 릴리스 요약"&gt;&lt;p&gt;1월 19일에 출시된 Docker 1.13에서 바뀐 점을 요약하였습니다. &lt;a href="https://blog.docker.com/2017/01/whats-new-in-docker-1-13/"&gt;Introducing Docker 1.13&lt;/a&gt;을 참고하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="1swarmcompose"&gt;1. swarm으로 클러스터를 띄울 때 compose 파일을 사용할 수 있습니다.&lt;/h3&gt;
&lt;p&gt;swarm으로 서비스를 관리할 때 옵션 지정하기가 번잡했던 부분을 해소할 수 있겠습니다.&lt;/p&gt;
&lt;h3 id="2"&gt;2. 예전 버전과의 호환성 유지&lt;/h3&gt;
&lt;p&gt;Docker 데몬보다 클라이언트가 최신 버전인 경우 &lt;code&gt;Error response from daemon: client is newer than server&lt;/code&gt; 에러를 만나곤 했는데요. 1.13 버전부터는 호환성이 유지된다고 합니다.&lt;/p&gt;
&lt;h3 id="3"&gt;3. 청소용 명령어 추가&lt;/h3&gt;
&lt;p&gt;많은 사람들이 원했던 두 명령어가 추가되었습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker system df&lt;/code&gt;: 도커가 디스크 용량을 얼마나 차지하는지 알려줍니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-language-sh"&gt;$ docker system df
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              85                  7                   8.59 GB             4.618 GB (53%)
Containers          9                   3                   407 MB              323.5 MB (79%)
Local Volumes       65                  6                   6.675 GB            5.968 GB (89%)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker system prune&lt;/code&gt;: 정지한 컨테이너, 연결이 끊긴 볼륨, 연결이 끊긴 네트워크, 외톨이(dangling) 이미지가 삭제됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-language-sh"&gt;$ docker system prune
WARNING! This will remove:
	- all stopped containers
	- all volumes not used by at least one container
	- all networks not used by at least one container
	- all dangling images
Are you sure you want to continue? [y/N]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="4"&gt;4. 명령어 구조 변경&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker container&lt;/code&gt;와 &lt;code&gt;docker image&lt;/code&gt; 등의 명령어 모음을 추가하면서 구조를 변경하고 있습니다. 예를 들어 &lt;code&gt;docker images&lt;/code&gt; 같은 명령어는 뜻이 더 분명해 보이는 &lt;code&gt;docker image list&lt;/code&gt;로도 실행할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker container&lt;/code&gt;: 컨테이너와 관련된 명령어가 들어 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ docker container
Commands:
  attach      Attach to a running container
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes on a container's filesystem
  exec        Run a command in a running container
  export      Export a container's filesystem as a tar archive
  inspect     Display detailed information on one or more containers
  kill        Kill one or more running containers
  logs        Fetch the logs of a container
  ls          List containers
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  prune       Remove all stopped containers
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  run         Run a command in a new container
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  wait        Block until one or more containers stop, then print their exit codes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 중에 &lt;code&gt;docker container list&lt;/code&gt;만 실행을 해보면...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker container list
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
b769009a1693        raccoony/buster     &amp;quot;./run.sh&amp;quot;               3 hours ago         Up 2 hours          0.0.0.0:9000-&amp;gt;9000/tcp   blog_buster_1
5aeaf1187adc        ghost               &amp;quot;/entrypoint.sh np...&amp;quot;   3 hours ago         Up 2 hours          0.0.0.0:2368-&amp;gt;2368/tcp   blog_ghost_1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker image&lt;/code&gt;: 이미지와 관련된 명령어가 들어 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ docker image
Commands:
  build       Build an image from a Dockerfile
  history     Show the history of an image
  import      Import the contents from a tarball to create a filesystem image
  inspect     Display detailed information on one or more images
  load        Load an image from a tar archive or STDIN
  ls          List images
  prune       Remove unused images
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rm          Remove one or more images
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 중에 &lt;code&gt;docker image prune&lt;/code&gt;을 실행해보았습니다. 1.5GB를 아꼈네요. :)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker image prune
WARNING! This will remove all dangling images.
Are you sure you want to continue? [y/N] y
Deleted Images:
deleted: sha256:9e36c6055df2ada
...
Total reclaimed space: 1.579 GB
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="5swarm"&gt;5. swarm 모니터링 개선&lt;/h3&gt;
&lt;p&gt;swarm으로 실행한 클러스터들의 로그를 모아서 보여주는 &lt;code&gt;docker service logs&lt;/code&gt; 명령이 추가되었습니다.&lt;/p&gt;
&lt;h3 id="6"&gt;6. 빌드 개선&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt;를 실행할 때 &lt;code&gt;--squash&lt;/code&gt; 옵션을 추가하면, 겹겹이 쌓인 파일시스템 레이어를 하나로 합쳐줍니다. &lt;code&gt;--squash&lt;/code&gt;를 사용하면, 이미지 레이어를 최소화해서 얻는 장점도 있는 반면, 여러 이미지들이 공유하던 중간 레이어들을 공유할 수 없다는 단점도 생깁니다.&lt;/p&gt;
&lt;p&gt;또, &lt;code&gt;--compress&lt;/code&gt; 옵션도 추가되었습니다. 원격에 있는 데몬과 통신하면서 이미지를 빌드할 때, 오가는 데이터를 압축하여 빌드 속도를 높인다고 합니다.&lt;/p&gt;
&lt;h3 id="7awsazure"&gt;7. AWS, Azure 지원(베타)&lt;/h3&gt;
&lt;p&gt;AWS와 Azure에서 퍼블릭 베타 형태로 Docker를 지원합니다.&lt;/p&gt;
</content:encoded></item><item><title>2016년 돌아보기</title><description>2016년 돌아보기. 요약 : 아는 만큼 모르게 된다. (내가 뽑은) 올해의 키워드, (내가 뽑은) 올해의 기술, 올해 계획과 성과, 진행했던 일들</description><link>http://raccoonyy.github.io/2016-retrospective/</link><guid isPermaLink="false">59815cfcdd47a80001bb9f05</guid><category>2016</category><category>retrospective</category><category>remembrance</category><category>docker</category><category>민주주의</category><category>회고</category><category>돌아보기</category><category>반성</category><dc:creator>raccoony</dc:creator><pubDate>Fri, 30 Dec 2016 01:50:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2016/12/2016-retrospective.png" medium="image"/><content:encoded>&lt;blockquote&gt;
&lt;img src="http://raccoonyy.github.io/content/images/2016/12/2016-retrospective.png" alt="2016년 돌아보기"&gt;&lt;p&gt;2016년을 돌아보자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;한 줄 요약 : 아는 만큼 모르게 된다.&lt;/p&gt;
&lt;h3 id=""&gt;내가 뽑은 올해의 키워드 : 민주주의&lt;/h3&gt;
&lt;p&gt;작년부터 조금씩 민주주의식 회의 제도나 조직 같은 것에 관심이 있었고, 올해는 정의당 서울시당에서 주관한 &lt;a href="https://www.justice21.org/newhome/region/board_view.html?cafe_code=0010&amp;amp;bbs_code=7&amp;amp;num=43739"&gt;정치 아카데미&lt;/a&gt;를 통해 민주주의 공부를 조금이나마 시작한 상태에서, 4500만명이 경악하는 사건이 터졌다. (500만명은 시각이 다르다.) 사건의 흐름과 이면에서 흐르는 이야기들을 다양한 시각으로 해석해 볼 수도 있었고, 내가 민주주의를 정말로 잘 모르고 있다는 점도 깨달은 한 해였다.&lt;/p&gt;
&lt;h3 id="docker"&gt;내가 뽑은 올해의 기술 : Docker&lt;/h3&gt;
&lt;p&gt;처음엔 '왜 이런 고통을 내게...'라는 느낌이었지만, 한 번 빠져들자 헤어나오지 못하고 있다. 내 컴퓨터에서 어떤 도구를 실행할 때, 관련 패키지를 설치하지 않아도 된다는 점이 굉장히 매력적이다. mysql, postgresql 같은 db는 말할 것도 없고, node나 python 같은 언어도 굳이 설치할 필요가 없다. (&lt;s&gt;지속가능하게 깨끗한 개발환경?&lt;/s&gt;)&lt;/p&gt;
&lt;p&gt;배포 환경에 올릴 때는 패키지 의존성이나 서버 환경을 크게 고민하지 않아도 되고, 코드 속 민감한 정보들은 환경 변수로 관리하기 쉬워지니 이 역시 좋다.&lt;/p&gt;
&lt;h3 id=""&gt;계획과 성과&lt;/h3&gt;
&lt;p&gt;아래는 2016년에 하고 싶었던 일 목록이다. 계획대로 진행한 건 &lt;code&gt;+++&lt;/code&gt;, 약간이나마 손을 댄 것은 &lt;code&gt;+&lt;/code&gt;, 손 대지 못한 건 &lt;code&gt;-&lt;/code&gt;로 표시해보았다.&lt;/p&gt;
&lt;h5 id=""&gt;공부&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ES6 + React:&lt;/strong&gt; &lt;code&gt;+&lt;/code&gt; 회사 프로젝트를 ES6로 진행하면서 살짝 손을 대 보았다. 짝 코딩해준 아웃사이더님이 탁월한 node 개발자셔서 많이 배웠으나, 이후로 더 손대지 않고 있어서... 일부러 이슈도 하나 맡아 보고, 로컬 개발 환경에 docker-compose도 끼얹어 보고 하고 있다. '기본이 비동기'라는 철학이 아직 낯설다. (자꾸 까먹는 &lt;code&gt;return&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AsciiDoc:&lt;/strong&gt; &lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="http://raccoonyy.github.io/2016-write-the-docs-seoul-meetup-epilogue/"&gt;WriteTheDocs 서울 모임&lt;/a&gt;:&lt;/strong&gt; 2016년에 할 수 있을 거라곤 생각하지 못했는데, 파이콘 APAC에서 장소를 제공받을 수 있어서 진행한 모임. 나는 AsciiDoc 문서를 인디자인으로 바로 옮길 수 있을까 싶어 실험했던 내용으로, &lt;a href="http://www.slideshare.net/raccoonyy/ss-65033495"&gt;인디자인을 활용한 자동 조판 실험&lt;/a&gt;이라는 발표를 했는데 완결성 면에서 조금 떨어졌던 것 같다. 2017년엔 좀더 발전하고 다듬어서 다시 이야기할 수 있었으면 좋겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2016/12/wtd-seoul.jpg" alt="2016년 돌아보기"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Google Analytics:&lt;/strong&gt; &lt;code&gt;-&lt;/code&gt; 책은 많이 샀는데...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python + Django:&lt;/strong&gt; &lt;code&gt;+++&lt;/code&gt;  Django ORM과 관련된 블로그 글이나 사내 발표 등을 준비하면서 좀더 깊이 들여다보게 된 듯. Django 소스코드도 조금 살펴보았다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://medium.com/infovis-kr/%EC%A0%95%EB%B3%B4%EC%8B%9C%EA%B0%81%ED%99%94-%EA%B3%A0%EC%A0%84-%EB%8F%85%EC%84%9C-%EB%AA%A8%EC%9E%84-c9b1ef976405#.blkwwpmwp"&gt;Data Visualization&lt;/a&gt;:&lt;/strong&gt; &lt;code&gt;+++&lt;/code&gt; 스터디 모임에서 회계를 맡고 있어서, 책임감 때문에라도 꼭꼭 참석했다. (&lt;s&gt;단, 모임에 나갔다고 해서 다 이해하고 돌아온 것 아니... ㅡㅜ&lt;/s&gt;) 아래는 스터디 했던 책.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;에드워드 터프티의 &lt;a href="https://www.amazon.com/Visual-Display-Quantitative-Information/dp/0961392142/"&gt;The Visual Display of Quantitative Information&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;콜린 웨어의 &lt;a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=62616251"&gt;데이터 시각화, 인지과학을 만나다&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;자크 베르탱의 &lt;a href="https://www.amazon.com/Semiology-Graphics-Diagrams-Networks-Maps/dp/1589482611/"&gt;Semiology of Graphics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;이 스터디가 내게 끼친 영향은 아마도 회사 다음일 거다. 모인 분들이 다양한 지식을 전해줄 뿐만 아니라, 상황을 바라보는 시야도 넓혀주었다. 책 별로는, 터프티가 제일 재미있었고, 콜린 웨어는 조금 관심사가 맞지 않았고, 자크 베르탱은 어렵지만 존경할 만한 분이었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;English:&lt;/strong&gt; &lt;code&gt;-&lt;/code&gt; 새해엔 전화 영어를 등록해야지.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sociocracy:&lt;/strong&gt; &lt;code&gt;+++&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://www.justice21.org/newhome/region/board_view.html?cafe_code=0010&amp;amp;bbs_code=7&amp;amp;num=43739"&gt;정치 아카데미&lt;/a&gt;:&lt;/strong&gt; 민주주의에 대해 오해하고 있던 부분들, 모르던 부분들을 알게 되어서 정말 재미있었다. &lt;a href="http://politicalpowerplant.kr"&gt;정치발전소&lt;/a&gt; 박상훈 박사님을 알게 된 것도 큰 수확. (완전 팬이 되었다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Maturing people:&lt;/strong&gt; &lt;code&gt;-&lt;/code&gt; 알면 알수록 모르는 게 더 많아지니, 섣불리 누구에게 뭘 가르쳐 줄 수가 없다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Public Audio:&lt;/strong&gt; &lt;code&gt;+&lt;/code&gt; &lt;a href="https://www.facebook.com/groups/usedaudioequip"&gt;중고 음향 기기 그룹&lt;/a&gt;과 &lt;a href="https://www.facebook.com/groups/SoundWorkshop/"&gt;장호준 음향 워크샵 그룹&lt;/a&gt;에 가입하면서, 그간 발전한 Public Audio의 세계에 놀라고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;프로젝트&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/raccoonyy/getting_real_kr"&gt;Getting Real KR&lt;/a&gt;:&lt;/strong&gt; &lt;code&gt;-&lt;/code&gt; 어쩜 하나도 손을... 새해엔 좀더 해보자꾸나.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/raccoonyy/sslchecker"&gt;SSL Checker&lt;/a&gt; +a:&lt;/strong&gt; &lt;code&gt;-&lt;/code&gt; 코어 라이브러리를 개발할 필요가 사라졌다. 그러면 프론트 개발이 더 빨라져야 했을 텐데? (반성)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SC 2nd:&lt;/strong&gt; &lt;code&gt;-&lt;/code&gt; CCLI에서 API를 제공한다고 해서 연락만 해 둔 상황.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hubtee:&lt;/strong&gt; &lt;code&gt;#&lt;/code&gt; 하나 붙이기에 조금 민망하긴 하지만 어쨌든...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://medium.com/%EC%95%BC%EC%8B%A0-poject/%E9%87%8E%E4%BF%A1-%EC%95%BC%EC%8B%A0-project-6ecbf0af5b61#.fxr9j1f05"&gt;야신프로젝트&lt;/a&gt;:&lt;/strong&gt; &lt;code&gt;-&lt;/code&gt; 잠정 중단.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;그 외&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015년보다 블로그 포스트 더 많이 올리기:&lt;/strong&gt; &lt;code&gt;+++&lt;/code&gt; 한국의 파이썬 소식을 주 1회 올리고 있다. 처음엔 가볍게 생각했는데, 이젠 죽을 지경이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;책 좀 읽자:&lt;/strong&gt; &lt;code&gt;+&lt;/code&gt; 샤오미 미패드2를 사면서, 지르기만 했던 전자책을 조금은 보게 되었다. 조금은.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기념일 징크스 벗어나기:&lt;/strong&gt; &lt;code&gt;+++&lt;/code&gt; 기념일마다 아내를 실망시키지 않고자 최선을 다했다. 통장 상황은 그에 반비례한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;예기치 않은 일&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;offline:&lt;/strong&gt; 작년 유아교육전의 악몽을 반복하기 싫어서, 8월 유아교육전 전에 쌍피님, 후얌얌님과 함께 급조한 창고 물류 관리 프로젝트. 즐거웠던 개발 과정은 &lt;a href="http://engineering.smartstudy.co.kr/2016/08/23/how-programmer-works-at-smartstudy/"&gt;창고 관리 서비스 개발 후기 - 스마트스터디의 '개발자'가 일하는 방식&lt;/a&gt;이란 글에서 자세히 설명하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/raccoonyy/buster"&gt;buster&lt;/a&gt;:&lt;/strong&gt;  ghost를 로컬에서 작동시킨 후 static 사이트를 만들 때 사용하는 도구다. &lt;a href="https://github.com/axitkhurana/buster"&gt;원 저장소&lt;/a&gt;는 2년 전부터 업데이트가 되지 않아서 ghost 최신 버전에서는 문제가 있다. 이를 해결하고자 개인 저장소에 포크한 후 몇 가지 커밋을 추가했다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;release.sh:&lt;/strong&gt; 사내 릴리스 규칙을 사람이 일일이 따라하다보면 빠지는 과정도 있겠고 실수도 생길 여지가 많아서, 이를 자동으로 처리해주는 셸 스크립트를 만들었다. 셸의 유용성을 발견한 게 너무 신나서 재미있게 작업했던 프로젝트. 내년엔 node 프로젝트에도 적용해보려 한다. (이거 공개할 수 있을까?)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동화모음:&lt;/strong&gt; 아이들이 다니는 어린이집에서 사용하는 동화책을 재편집/재조판했다. 동화책치고는 독특하게 그림이 전혀 없었는데, 그 덕에 편집하고 조판하는 과정이 그리 어렵진 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2016/12/fairytales.jpg" alt="2016년 돌아보기"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://shop.weirdx.io/product-category/magazine/"&gt;월간 이상한 모임&lt;/a&gt;:&lt;/strong&gt; 이상한 모임에서 한 해 동안 진행했던 잡지 프로젝트. 교정/교열 감을 잃지 않고 싶어서 참가했지만, 책에서 중요한 부분은 역시나 기획. 기여도가 점점 떨어져서 다른 편집위원들께 굉장히 미안했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;건강&lt;/h5&gt;
&lt;p&gt;작년 연말에 식도염으로 고생했는데, 올해 11월 말부터 식도염 증세가 도졌다. 두세 달 약을 먹어야 하고 그래도 낫지 않으면 내시경을 받아야... ㅡㅜ 먹고픈 음식은 많은데 먹지를 못하니 괴롭다. 날이 따뜻해지면 자전거도 좀 타고 하면서 건강해지자.&lt;/p&gt;
&lt;h5 id=""&gt;회사 생활&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;코드 리뷰:&lt;/strong&gt; 올해 중반부터 회사에서 개발 중인 코드는 팀원 모두가 리뷰하고 나서 머지하자고 합의했다. 내 똥 코드를 코드답게 바꿔주시는 덕에, 코드 품질에 신경을 많이 쓰게 되었다. 또, 커밋도 깔끔하게 rebase하는 습관을 기를 수 있고. (아직도 깔끔한지는 모르겠지만...)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;팀웍:&lt;/strong&gt; 이보다 좋은 팀원들이 있을까 싶은데, 그래서 내가 너무 의존적이 되는 건 아닌가 걱정도 된다. 구름 위 어딘가에서 코딩하시는 것 같은 초월적 존재 스카리님, 프론트와 백엔드를 오가며 거대한 똥덩어리를 홀로 막아내고 계신 쌍피님, 나는 아무리 들어도 이해가 되지 않는 코덱들을 능수능란하게 다루시는 후얌얌님, 언제 읽고 보고 쓰는지 도무지 알 길이 없지만 모든 걸 알고 계신 토토님, 입사 한 달 만에 일 년을 같이 일한 것 같은 팀웍을 보여주신 아웃사이더님. &lt;strong&gt;항상 고맙고 고맙고 고맙습니다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;팀 외부:&lt;/strong&gt; 파이님이 퇴사하셨다. 내게 Django다운 Django를 알려주신 분. 아쉽지만 회사 밖에서 더 자주 만날 수 있길. 밀크티를 매개로 친해진 분께서 나를 진짜 홍차의 세계로 인도해 주셨다. 이 외에도 서로 존재는 알지만 대화는 해보지 않은 정의당 당원, 살짝 친해지나 싶었는데 이직하신 분, 예전보다 대화 횟수가 급격히 줄어든 몇몇 분이 머릿속을 스친다. 회사가 많이 커졌다. 이젠 성함과 별명을 모두 알지 못하겠다. 사내 아이디 생성은 여전히 나를 거치고 있음에도, 회사 외부에서 지나치면 동료인 줄 모를 것 같은 사람들이 늘고 있다. 그래서 신규 입사자의 첫 출근일에는 가급적 재택이나 휴가를 쓰지 않고, 얼굴을 한 번이라도 뵙고자 노력 중이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;총평&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;내가 모르는 것이 점점 많아지고 있다&lt;/code&gt;는 건, 내가 배우고 있다는 뜻이기도 하겠지. 올해 초엔 살짝 정체기였지만, 봄을 지나면서는 내가 모르는 것이 뭔지 찾아내고 있다. 문제는, 학습 의욕은 넘치는데 막상 학습까지 이어진 경우가 드물었다는 점.&lt;/p&gt;
&lt;p&gt;올해 넓혀둔 지경에, 내년에는 발자국을 남겨보자.&lt;/p&gt;
</content:encoded></item><item><title>(컴파일 없이) nginx에서 환경 변수 불러오기</title><description>nginx에서 환경 변수를 읽어들이는 방법을 찾아보니 perl 모듈이나 lua 모듈을 사용하라는데, 그러기 싫어서 셸 스크립트를 활용해 보았다.</description><link>http://raccoonyy.github.io/using_env_variables_in_nginx_conf_without_lua_or_perl_module/</link><guid isPermaLink="false">59815cfcdd47a80001bb9eeb</guid><category>nginx</category><category>shell script</category><category>environment variable</category><category>ECS</category><category>docker</category><category>elb</category><dc:creator>raccoony</dc:creator><pubDate>Thu, 04 Aug 2016 09:56:51 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2016/08/without-any-module.jpg" medium="image"/><content:encoded>&lt;h1 id=""&gt;요약&lt;/h1&gt;
&lt;img src="http://raccoonyy.github.io/content/images/2016/08/without-any-module.jpg" alt="(컴파일 없이) nginx에서 환경 변수 불러오기"&gt;&lt;p&gt;lua 모듈 쓰면 겁나 편하지만, 사정상 사용할 수 없다면 셸 스크립트 방식도 고려해보자.&lt;/p&gt;
&lt;h1 id=""&gt;상황&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;nginx에서 특정 url에 대해 ip를 제한해야 하는데, ip 설정을 동적으로 하고 싶었다. (하지만 &lt;strong&gt;db 설정 없이&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;nginx에서 환경 변수를 읽어들이는 방법을 찾아보니 perl 모듈이나 lua 모듈을 사용하라는데, nginx를 직접 컴파일해야 한다는 점이 걸렸다. (&lt;strong&gt;컴파일 공포증&lt;/strong&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;아무것도 컴파일하지 않고, 추가로 설치하는 일도 없이 할 수는 없을까?를 고민하다가 최근 재미 들린 셸 스크립트를 활용해보기로 했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;서비스는 docker 이미지로 만들어져, aws의 ECS에 올라가 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="1ipurl"&gt;1. ip로 url 접근 제한하기&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;/admin/&lt;/code&gt; url에 대해서 특정 ip만 접근하도록 해보자.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;nginx.conf&lt;/code&gt;의 /admin 부분에 주석문(&lt;code&gt;# admin_ip_whitelist&lt;/code&gt;)을 하나 추가했다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-nginx"&gt;# nginx.conf
...
# 로드 밸런서를 사용하는 경우 이 부분들이 필요하다.
set_real_ip_from   172.17.0.0/16;  # 로드 밸런서의 ip 대역을 넣어준다.
real_ip_header     X-Forwarded-For;
...
# 로드 밸런서가 없다면 아래 부분만 있어도 된다.
location /admin {
    uwsgi_pass unix:///var/run/default-uwsgi.sock;
    include uwsgi_params;
    # admin_ip_whitelist
}
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그 다음 docker 이미지의 CMD 부분에 셸 스크립트를 넣는다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-docker"&gt;# Dockerfile
...
ADD    ./run.sh /
CMD    /run.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 &lt;code&gt;run.sh&lt;/code&gt; 파일을 작성한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;#!/bin/bash

if [ -n &amp;quot;$IP_WHITELIST_FOR_ADMIN&amp;quot; ]; then
    IP_WHITELIST=&amp;quot;allow ${IP_WHITELIST_FOR_ADMIN};\n&amp;quot;
    IP_WHITELIST+=&amp;quot;deny all;&amp;quot;

    sed -i &amp;quot;s@# admin_ip_whitelist@${IP_WHITELIST}@g&amp;quot; /etc/nginx/nginx.conf
fi

supervisord -n  # 이건 원래 Dockerfile의 CMD 부분에서 실행하던 명령어
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 ECS의 Task Definition에서 &lt;code&gt;IP_WHITE_LIST_FOR_ADMIN&lt;/code&gt; 환경변수를 추가하면 해당 IP만 &lt;code&gt;/admin&lt;/code&gt;에 접근할 수 있다.&lt;/p&gt;
&lt;h3 id="2elbvpcurl"&gt;2. ELB의 vpc 대역으로 특정 url 접근 제한하기&lt;/h3&gt;
&lt;p&gt;이번에는 &lt;code&gt;/api/special&lt;/code&gt;에 대해 같은 vpc 내부의 요청만 허용해보자. (1번 작업을 해두었다고 가정한다.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nginx.conf&lt;/code&gt;의 /api/special 부분에 주석문(&lt;code&gt;# vpc_ip_range&lt;/code&gt;)을 추가한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-nginx"&gt;location /api/special {
    uwsgi_pass unix:///var/run/default-uwsgi.sock;
    include uwsgi_params;
    # vpc_ip_range
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 &lt;code&gt;run.sh&lt;/code&gt;에 다음 내용을 추가한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;# run.sh
...
if [ -n &amp;quot;WRITE_API_ACCESS_ONLY_VPC&amp;quot; ]; then
    # 서버의 IP 네트워크 내역을 검출하는 방법.
    # 주의! 네트워크가 여럿인 경우엔 결과 값도 여러 개로 나오므로, 이를 배열에 저장하여 사용해야 함
    VPC_SUBNET_MASK=`ip -o -f inet addr show | awk '/scope global/ {print $4}'`

    VPC_IP_RANGE=&amp;quot;allow ${VPC_SUBNET_MASK};\n&amp;quot;
    VPC_IP_RANGE=&amp;quot;deny all;&amp;quot;

    sed -i &amp;quot;s@# vpc_ip_range@${VPC_IP_RANGE}@g&amp;quot; /etc/nginx/nginx.conf
fi
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 ECS의 Task Definition에서 &lt;code&gt;WRITE_API_ACCESS_ONLY_VPC&lt;/code&gt; 값을 설정하면(어떤 값으로든), &lt;code&gt;/api/special&lt;/code&gt;이라는 경로는 VPC 내부에서만 접근할 수 있게 된다.&lt;/p&gt;
&lt;h1 id=""&gt;배운 점&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;shell script를 좀더 제대로 배워보고 싶어졌다. 알면 알수록 활용성이 올라갈 듯.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sed 같은 유닉스 기본 명령도 많이 알아보자.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker와 환경 변수 독립이라는 개념이 유닉스나 시스템 엔지니어링에 익숙하지 않은 사람(=나)에게 큰 도움이 되는 듯.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>docker 안에서 주기적인 작업(cron) 처리하기</title><description>&lt;blockquote&gt;
&lt;p&gt;문제 : docker 컨테이너 안에서 cron job을 돌리고 싶었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h5 id="201637"&gt;2016년 3월 7일 업데이트&lt;/h5&gt;
&lt;p&gt;이 문제를 DockerKorea 모임에 문의했더니 cron 처리를 위한 별도의 프로그램을 추천해주셨습니다. &lt;a href="https://pypi.python.org/pypi/python-crontab/"&gt;python-crontab&lt;/a&gt;이나 &lt;a href="https://github.com/anarcher/go-cron"&gt;go-cron&lt;/a&gt; 등이요.&lt;/p&gt;
&lt;p&gt;한편, 주기적인 작업에는 cron 대신 &lt;a href="https://syncano.io/blog/configuring-running-django-celery-docker-containers-pt-1/"&gt;celery를 사용하는 방법&lt;/a&gt;도 많이 사용된답니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="dockercron"&gt;docker 내에서 일반적인 cron 설정 방법&lt;/h3&gt;
&lt;p&gt;일단 제가 찾아 본 일반적인 설정은&lt;/p&gt;</description><link>http://raccoonyy.github.io/cron-job-with-uwsgi-in-docker-container/</link><guid isPermaLink="false">59815cfcdd47a80001bb9ecf</guid><category>docker</category><category>cron</category><category>uwsgi</category><dc:creator>raccoony</dc:creator><pubDate>Thu, 03 Mar 2016 00:57:52 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2016/03/rotate.jpg" medium="image"/><content:encoded>&lt;blockquote&gt;
&lt;img src="http://raccoonyy.github.io/content/images/2016/03/rotate.jpg" alt="docker 안에서 주기적인 작업(cron) 처리하기"&gt;&lt;p&gt;문제 : docker 컨테이너 안에서 cron job을 돌리고 싶었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h5 id="201637"&gt;2016년 3월 7일 업데이트&lt;/h5&gt;
&lt;p&gt;이 문제를 DockerKorea 모임에 문의했더니 cron 처리를 위한 별도의 프로그램을 추천해주셨습니다. &lt;a href="https://pypi.python.org/pypi/python-crontab/"&gt;python-crontab&lt;/a&gt;이나 &lt;a href="https://github.com/anarcher/go-cron"&gt;go-cron&lt;/a&gt; 등이요.&lt;/p&gt;
&lt;p&gt;한편, 주기적인 작업에는 cron 대신 &lt;a href="https://syncano.io/blog/configuring-running-django-celery-docker-containers-pt-1/"&gt;celery를 사용하는 방법&lt;/a&gt;도 많이 사용된답니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="dockercron"&gt;docker 내에서 일반적인 cron 설정 방법&lt;/h3&gt;
&lt;p&gt;일단 제가 찾아 본 일반적인 설정은 다음과 같습니다.&lt;/p&gt;
&lt;h5 id="1dockercroncron"&gt;1. docker 이미지에 cron 설치 (cron 없는 이미지도 있으니까)&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-language-docker"&gt;# Dockerfile
RUN apt-get install -y cron
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="2cronjobtxt"&gt;2. &lt;code&gt;cronjob.txt&lt;/code&gt; 파일 생성&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# cronjob.txt
*/5 * * * * root echo &amp;quot;hello cron&amp;quot; &amp;gt;&amp;gt; /dev/stdout
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="3cronjobtxtetccrond"&gt;3. &lt;code&gt;cronjob.txt&lt;/code&gt;을 &lt;code&gt;/etc/cron.d/&lt;/code&gt;에 복사&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-language-docker"&gt;# Dockerfile
ADD ./etc/cronjob.txt   /etc/cron.d/
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="4supervisorcron"&gt;4. supervisor 등의 프로세스 관리자에 cron을 등록&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# supervisord.conf
[program:cron]
command = cron -f -L 15
autostart = true
autorestart = true
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="5"&gt;5. 컨테이너 실행&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;$ docker run -d image_name 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 저는 이게 잘 안 되더군요. (혹시 틀린 부분이 있다면 알려주세요. 다시 시도해보겠습니다. ㅠㅠ)&lt;/p&gt;
&lt;p&gt;그러던 중에 &lt;a href="https://dittos.github.io/2015/10/24/advanced-uwsgi/"&gt;uwsgi에서 cron을 지원한다는 이야기&lt;/a&gt;를 들었습니다. 어차피 고통받는 상황이니, 밑져야 본전이라는 생각으로 시도를 해봤습니다.&lt;/p&gt;
&lt;h3 id="uwsgicron"&gt;uwsgi에서 cron 설정하기&lt;/h3&gt;
&lt;h5 id="1uwsgiini"&gt;1. &lt;code&gt;uwsgi.ini&lt;/code&gt; 파일에 다음 내용을 추가합니다.&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;[uwsgi]
-5 -1 -1 -1 -1 echo &amp;quot;hello cron&amp;quot; &amp;gt;&amp;gt; /dev/stdout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;crontab에서 *로 설정하는 부분을 uwsgi에서는 -1로 설정하고, 주기적인 작업을 위해 */5로 설정하는 부분을 uwsgi에서는 -5로 설정하면 됩니다. (더 인간 친화적인 설정 방법도 있으니 &lt;a href="http://uwsgi-docs.readthedocs.org/en/latest/Cron.html"&gt;문서&lt;/a&gt;를 참고하세요~)&lt;/p&gt;
&lt;p&gt;끝입니다. -_-;&lt;/p&gt;
&lt;p&gt;테스트할 땐, 출력을 &lt;code&gt;/dev/stdout&lt;/code&gt;이 아닌 &lt;code&gt;/var/log/cron.log&lt;/code&gt; 같은 로컬 파일로 바꾼 다음에 확인을 해봤습니다. 잘 되더군요.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론: uwsgi 설치된 서버에서 cron 작업할 땐 uwsgi 쓸게요.&lt;/strong&gt;&lt;/p&gt;
</content:encoded></item></channel></rss></html>