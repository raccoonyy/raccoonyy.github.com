<!DOCTYPE html>
<html><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>test - raccoony's cave</title><description>Raccoony writes about programming, book and etc.</description><link>http://raccoonyy.github.io/</link><image><url>http://raccoonyy.github.io/favicon.png</url><title>test - raccoony's cave</title><link>http://raccoonyy.github.io/</link></image><generator>Ghost 1.21</generator><lastBuildDate>Wed, 28 Mar 2018 00:18:28 GMT</lastBuildDate><atom:link href="http://raccoonyy.github.io/tag/test/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>한국의 파이썬 소식(3월 다섯째 주)</title><description>한국에서 일어나는 파이썬 관련 소식을 전합니다. #1 자료 구조 정의용 라이브러리 Meta #2 Test First! (이모콘 발표 영상)</description><link>http://raccoonyy.github.io/python-news-for-korean-5th-week-mar/</link><guid isPermaLink="false">59815cfcdd47a80001bb9ed3</guid><category>파이썬</category><category>파이썬 소식</category><category>python</category><category>python-news</category><category>test</category><category>meta</category><dc:creator>raccoony</dc:creator><pubDate>Mon, 28 Mar 2016 02:22:07 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2016/01/IMG_0005.jpg" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;blockquote&gt;
&lt;img src="http://raccoonyy.github.io/content/images/2016/01/IMG_0005.jpg" alt="한국의 파이썬 소식(3월 다섯째 주)"&gt;&lt;p&gt;한국에서 일어나는 파이썬 관련 소식을 전합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=""&gt;라이브러리&lt;/h1&gt;
&lt;h3 id="meta"&gt;&lt;a href="https://github.com/flowdas/meta"&gt;Meta&lt;/a&gt;(자료 구조 정의용 라이브러리)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.flowdas.com/about/"&gt;flowdas&lt;/a&gt;의 오동권 님께서 자료 구조 정의용 라이브러리를 공개해주었습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://raccoonyy.github.io/content/images/2016/03/Screenshot-2016-03-28-11-18-01.png" alt="한국의 파이썬 소식(3월 다섯째 주)"&gt;&lt;/p&gt;
&lt;h1 id=""&gt;발표&lt;/h1&gt;
&lt;h3 id="testfirstbyahastudio"&gt;&lt;a href="https://www.youtube.com/watch?v=tLG0X-4xB64&amp;amp;list=PLJ0BuvoGAkXuie_CllvOg5c6H39-tsXer&amp;amp;index=1"&gt;Test First!&lt;/a&gt; by ahastudio&lt;/h3&gt;
&lt;p&gt;Test 코드를 통해 소프트웨어 명세를 실행 가능한 형태로 관리하는 방법을 ahastudio님이 &lt;a href="https://www.youtube.com/playlist?list=PLJ0BuvoGAkXuie_CllvOg5c6H39-tsXer"&gt;이모콘&lt;/a&gt;에서 발표하였습니다. (아래는 소개글)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;소프트웨어의 검증 방법을 미리 준비하는 접근 방식인 Test First를 소개합니다. 소프트웨어 명세로 작성한 문서는 지속성을 유지하기 어려워서 살아있는 문서화(living document)에 대한 중요성이 이전보다 더욱 강조되고 있습니다. 요구 명세를 실행 가능한 형태, 즉 테스트 케이스로 만들면 빠른 피드백을 받을 수 있어 모두 만족할 수 있는 코드를 작성할 수 있게 됩니다. Test First, 어떻게 작성해야 하는지 예제와 함께 살펴봅니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</content:encoded></item><item><title>테스트용 객체 생성을 편하게 - model_mommy</title><description>django에서 테스트용 객체를 생성하기가 좀 귀찮았다. 테스트 픽스처를 만들기도 귀찮았다. 그냥 더미 객체들 좀 알아서 만들어주면 안 되나? model_mommy 도입으로 해결!</description><link>http://raccoonyy.github.io/generating-dynamic-test-fixture-with-model_mommy/</link><guid isPermaLink="false">59815cfbdd47a80001bb9ea8</guid><category>test</category><category>파이썬</category><category>Django</category><category>django-test</category><category>model_mommy</category><category>테스트</category><dc:creator>raccoony</dc:creator><pubDate>Tue, 26 Jan 2016 23:21:53 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2016/01/model_mommy.jpg" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2016/01/model_mommy.jpg" alt="테스트용 객체 생성을 편하게 - model_mommy"&gt;&lt;p&gt;개인적으로 테스트를 작성하면서 귀찮다고 여겼던 부분 중 하나는 테스트용 데이터(테스트 픽스처) 구축이었다. Django에서 테스트 전에 테스트 픽스처를 불러들이는 기능을 제공하지만, 이걸 만드는 일 자체가 귀찮기도 하고 어떤 데이터인지 확인하려면 json 파일을 열어봐야 하니까.&lt;/p&gt;
&lt;p&gt;그러던 중에 &lt;strong&gt;Object Factory&lt;/strong&gt;라는 도구를 알게 되었다. 여러 가지가 있지만(대표적으론 &lt;a href="https://factoryboy.readthedocs.org/en/latest/"&gt;Factory Boy&lt;/a&gt;) 가장 간단해서 사용하게 된 &lt;a href="http://model-mommy.readthedocs.org/"&gt;model_mommy&lt;/a&gt;를 소개해볼까 한다.&lt;/p&gt;
&lt;h2 id=""&gt;설치&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ pip install model_mommy
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;테스트용 객체 만들기&lt;/h2&gt;
&lt;p&gt;다음과 같은 Author 모델이 있다고 하자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# models.py
class Author(models.Model):
    name = models.CharField(max_length=35)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 model_mommy를 사용하여 테스트용 객체를 만들 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# test_models.py
from django.test import TestCase
from model_mommy import mommy

class TestAuthor(TestCase):
    def setUp(self):
        self.author = mommy.make('Author')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이때 Author 모델의 name 속성은 임의의 글자 35개(&lt;code&gt;max_length=35&lt;/code&gt;)로 생성되는데, 이를 직접 지정할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;self.author = mommy.make(
    'Author', 
    name='test_name'
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;외부키 연결&lt;/h2&gt;
&lt;p&gt;이제 &lt;code&gt;models.py&lt;/code&gt;에 Book 모델을 추가하고, Author 모델과 연결했다고 하자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# models.py
class Book(models.Model):
    title = models.CharField(max_length=150)
    author = models.ForeignKey('Author')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 테스트에서 특정 Author 객체와 연결된 Book 모델을 만들고 싶다면,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# test_models.py
# ... (생략) ...
class TestBook(TestCase):
    def setUp(self):
        self.author = mommy.make('Author')
        self.book = mommy.make('Book', author=self.author)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;연결된 모델의 속성도 지정할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;self.book = mommy.make(
    'Book',
    author__name='test_related_name'
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;한꺼번에 여러 객체 만들기&lt;/h3&gt;
&lt;p&gt;객체를 한꺼번에 하나 이상 만들고 싶다면,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;books = mommy.make(
    'Book',
    _quantity=100
)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;너무 많이 만들면(10,000개 이상?) 테스트 실행 시간도 늘어난다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 외에도 &lt;a href="http://model-mommy.readthedocs.org/en/latest/recipes.html"&gt;Recipe&lt;/a&gt;를 만들어 두고 재활용하거나, 만드는 순서에 따라 번호를 매기는 &lt;a href="http://model-mommy.readthedocs.org/en/latest/recipes.html#sequences-in-recipes"&gt;Sequence&lt;/a&gt; 등의 기능도 있으니 참고하길.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>django 테스트를 pytest로 실행시키기</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;버전 1.7부터 django에서 기본으로 제공하는 테스트 러너가 마이그레이션 과정을 거치기 시작했다. 당연히 테스트 과정에 드는 시간은 늘어났고. 1.8에서는 &lt;code&gt;--keepdb&lt;/code&gt;라는 옵션을 &lt;a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-option---keepdb"&gt;제공&lt;/a&gt;하여 마이그레이션을 회피할 수 있는 듯 하다. 1.7에서도 작동하는 우회법(&lt;a href="https://pypi.python.org/pypi/django-test-without-migrations"&gt;1&lt;/a&gt;, &lt;a href="https://gist.github.com/nealtodd/2869341f38f5b1eeb86d"&gt;2&lt;/a&gt;)들도 존재한다.&lt;/p&gt;
&lt;p&gt;하지만 이참에 &lt;a href="http://pytest.org/latest/"&gt;pytest&lt;/a&gt;를 사용해보기로 했다.&lt;/p&gt;
&lt;h3 id=""&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DB 파일을 매번 새로&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://raccoonyy.github.io/pytest-for-django-test/</link><guid isPermaLink="false">59815cfbdd47a80001bb9eab</guid><category>Django</category><category>pytest</category><category>test</category><category>django-test</category><dc:creator>raccoony</dc:creator><pubDate>Tue, 24 Mar 2015 14:35:54 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;버전 1.7부터 django에서 기본으로 제공하는 테스트 러너가 마이그레이션 과정을 거치기 시작했다. 당연히 테스트 과정에 드는 시간은 늘어났고. 1.8에서는 &lt;code&gt;--keepdb&lt;/code&gt;라는 옵션을 &lt;a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-option---keepdb"&gt;제공&lt;/a&gt;하여 마이그레이션을 회피할 수 있는 듯 하다. 1.7에서도 작동하는 우회법(&lt;a href="https://pypi.python.org/pypi/django-test-without-migrations"&gt;1&lt;/a&gt;, &lt;a href="https://gist.github.com/nealtodd/2869341f38f5b1eeb86d"&gt;2&lt;/a&gt;)들도 존재한다.&lt;/p&gt;
&lt;p&gt;하지만 이참에 &lt;a href="http://pytest.org/latest/"&gt;pytest&lt;/a&gt;를 사용해보기로 했다.&lt;/p&gt;
&lt;h3 id=""&gt;장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DB 파일을 매번 새로 만들지 않는다. (=테스트 실행 속도 향상)&lt;/li&gt;
&lt;li&gt;테스트 간 의존성을 관리할 수 있다.&lt;/li&gt;
&lt;li&gt;테스트 동시 실행도 가능한다. (pytest-xdist 필요)&lt;/li&gt;
&lt;li&gt;기존 테스트들과 호환된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;설치&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ pip install pytest-django
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 pytest 뿐만 아니라 django의 테스트 코드를 인식하는 플러그인도 설치된다.&lt;/p&gt;
&lt;h3 id=""&gt;설정&lt;/h3&gt;
&lt;p&gt;테스트를 실행할 디렉터리에 (보통은 &lt;code&gt;manage.py&lt;/code&gt; 파일이 위치하는 디렉터리) &lt;code&gt;pytest.ini&lt;/code&gt; 파일을 생성하고, 테스트에 사용하는 설정 파일을 지정해준다. (아래는 설정 파일이 &lt;code&gt;./settings/test.py&lt;/code&gt;인 경우)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ini"&gt;[pytest]
DJANGO_SETTINGS_MODULE=settings.test
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;사용&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ py.test

=========================== test session starts ============================
platform darwin -- Python 2.7.8 -- py-1.4.26 -- pytest-2.6.4
plugins: django
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;현재 플랫폼에 설치된 파이썬과 pytest의 버전이 출력된 다음 django 테스트들이 실행된다. 하지만 마이그레이션이 먼저 실행되면서 시간을 잡아먹거나 오류를 발생시킨다. 이럴 땐, &lt;code&gt;--nomigrations&lt;/code&gt; 옵션을 붙이면 마이그레이션 과정을 건너 뛴다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ py.test --nomigrations
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;병렬 실행&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pytest-xdist&lt;/code&gt; 플러그인을 설치하면 테스트들을 병렬적으로 실행할 수도 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ pip install pytest-xdist
$ py.test -n 3  # 테스트가 3개씩 병렬적으로 실행됨
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="continuoustest"&gt;Continuous Test&lt;/h3&gt;
&lt;p&gt;소스코드가 바뀌었을 때 자동으로 테스트를 실행할 수는 없을까? &lt;code&gt;pytest-xdixt&lt;/code&gt; 플러그인이 설치된 상태에서 &lt;code&gt;-f&lt;/code&gt; 옵션을 사용하면 가능하다. 똑똑하게도 바뀐 소스에 대한 테스트만 먼저 실행하고, 이를 통과하면 전체 테스트를 수행한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ py.test -f   # 소스코드가 바뀌면 자동으로 테스트가 실행된다 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;디버거와 함께&lt;/h3&gt;
&lt;p&gt;테스트 실행 도중 특정 위치에서 디버거를 켜고 싶을 수도 있다. &lt;code&gt;--pdb&lt;/code&gt; 옵션을 사용하자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;--pdb&lt;/code&gt;와 &lt;code&gt;-f&lt;/code&gt; 옵션은 함께 사용할 수 없다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ py.test --pdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 테스트 코드 중간에 다음과 같은 코드를 삽입한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pytest
pytest.set_trace()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테스트가 실행되다가 해당 부분에서 멈추고 디버거를 보여준다.&lt;/p&gt;
&lt;p&gt;이 외에도 유용한 기능들은 &lt;a href="https://pytest.org/latest/usage.html"&gt;pytest 사용법(영문)&lt;/a&gt; 페이지를 참고하자.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss></html>