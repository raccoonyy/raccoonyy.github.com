<!DOCTYPE html>
<html><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>translate - raccoony's cave</title><description>Raccoony writes about programming, book and etc.</description><link>http://raccoonyy.github.io/</link><image><url>http://raccoonyy.github.io/favicon.png</url><title>translate - raccoony's cave</title><link>http://raccoonyy.github.io/</link></image><generator>Ghost 1.21</generator><lastBuildDate>Wed, 28 Mar 2018 00:18:23 GMT</lastBuildDate><atom:link href="http://raccoonyy.github.io/tag/translate/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>파이썬에서 유니코드 스트림 다루기</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;원문 - &lt;a href="http://blog.etianen.com/blog/2013/10/05/python-unicode-streams/"&gt;Working with unicode streams in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 Dave Hall 님께 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;파이썬에서 유니코드를 다룰 때는 일반적으로 &lt;code&gt;str.decode()&lt;/code&gt;와 &lt;code&gt;unicode.encode()&lt;/code&gt; 메서드를 사용하여 &lt;code&gt;unicode&lt;/code&gt; 타입과 &lt;code&gt;str&lt;/code&gt; 타입을 상호 변환한다.&lt;/p&gt;
&lt;p&gt;아래 예시에서는 'utf-16'으로 작성된 파일을 열어, 수직 탭(vertical tab) 코드포인트를 지운 다음, 'utf-8'로 저장한다. (깨진&lt;/p&gt;&lt;/div&gt;</description><link>http://raccoonyy.github.io/working-with-unicode-streams-in-python-korean/</link><guid isPermaLink="false">59815cfbdd47a80001bb9ea2</guid><category>translate</category><category>unicode-stream</category><category>python</category><dc:creator>raccoony</dc:creator><pubDate>Mon, 16 Mar 2015 01:11:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;원문 - &lt;a href="http://blog.etianen.com/blog/2013/10/05/python-unicode-streams/"&gt;Working with unicode streams in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 Dave Hall 님께 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;파이썬에서 유니코드를 다룰 때는 일반적으로 &lt;code&gt;str.decode()&lt;/code&gt;와 &lt;code&gt;unicode.encode()&lt;/code&gt; 메서드를 사용하여 &lt;code&gt;unicode&lt;/code&gt; 타입과 &lt;code&gt;str&lt;/code&gt; 타입을 상호 변환한다.&lt;/p&gt;
&lt;p&gt;아래 예시에서는 'utf-16'으로 작성된 파일을 열어, 수직 탭(vertical tab) 코드포인트를 지운 다음, 'utf-8'로 저장한다. (깨진 XML을 다룰 때 이 방식이 매우 중요하다.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 파일 내용을 읽는다
with open(&amp;quot;input.txt&amp;quot;, &amp;quot;rb&amp;quot;) as input:
    data = input.read()

# 바이너리 데이터를 utf-16으로 디코딩한다
data = data.decode(&amp;quot;utf-16&amp;quot;)

# 수직 탭을 삭제한다
data = data.replace(u&amp;quot;\u000B&amp;quot;, u&amp;quot;&amp;quot;)

# 유니코드 데이터를 utf-8로 인코딩한다
data = data.encode(&amp;quot;utf-8&amp;quot;)

# 데이터를 utf-8로 저장한다
with open(&amp;quot;output.txt&amp;quot;, &amp;quot;wb&amp;quot;) as output:
    output.write(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;엄청나게 큰 파일을 다룰 때가 아니라면 이 정도로도 충분하다. 하지만 큰 파일을 다룰 땐 모든 데이터가 메모리에 올라간다는 사실이 문제가 된다.&lt;/p&gt;
&lt;h2 id=""&gt;스트리밍 인코더/디코더 사용하기&lt;/h2&gt;
&lt;p&gt;파이썬 기본 라이브러리에는 &lt;code&gt;codecs&lt;/code&gt; 모듈이 포함되어 있다. 이 모듈을 사용하면 파일을 조금씩 읽을 수 있고, 메모리에도 약간의 유니코드 데이터만 올라가게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;codecs.open()&lt;/code&gt; 헬퍼 메서드를 사용하여 위의 예시를 최소한만 고쳐보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import codecs

# 입력 스트림과 출력 스트림을 연다
input = codecs.open(&amp;quot;input.txt&amp;quot;, &amp;quot;rb&amp;quot;, encoding=&amp;quot;utf-16&amp;quot;)
output = codecs.open(&amp;quot;output.txt&amp;quot;, &amp;quot;wb&amp;quot;, encoding=&amp;quot;utf-8&amp;quot;)

# 유니코드 데이터 조각들을 스트리밍한다
with input, output:
    while True:
        # 데이터 조각을 읽고
        chunk = input.read(4096)
        if not chunk:
            break
        # 수직 탭을 삭제한다
        chunk = chunk.replace(u&amp;quot;\u000B&amp;quot;, u&amp;quot;&amp;quot;)
        # 데이터 조각을 쓴다
        output.write(chunk)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;파일은 끔찍해! 이터레이터 사용하기&lt;/h2&gt;
&lt;p&gt;파일은 다루기가 좀 지루하다. 복잡한 처리 과정에는 유니코드 데이터의 이터레이터를 다루는 편이 깔끔할 것이다.&lt;/p&gt;
&lt;p&gt;아래는 &lt;code&gt;iterdecode()&lt;/code&gt;를 사용하여, 파일을 유니코드 데이터 조각의 이터레이터로 읽는 효과적인 방법이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from functools import partial
from codecs import iterdecode

# 특정 path의 파일을 유니코드 조각의 이터레이터로 리턴한다
def iter_unicode_chunks(path, encoding):
    # 읽을 파일을 연다
    with open(path, &amp;quot;rb&amp;quot;) as input:
        # 바이너리 파일을 바이너리 조각으로 변환한다
        binary_chunks = iter(partial(input.read, 1), &amp;quot;&amp;quot;)
        # 바이너리 조각을 유니코드 조각으로 변환한다
        for unicode_chunk in iterdecode(binary_chunks, encoding):
            yield unicode_chunk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 &lt;code&gt;iterencode()&lt;/code&gt; 메서드를 사용하여, 유니코드 조각의 이터레이터를 파일에 써보자.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from codecs import iterencode

# 유니코드 조각의 이터레이터를 특정 path의 파일에 쓴다
def write_unicode_chunks(path, unicode_chunks, encoding):
    # 쓸 파일을 연다
    with open(path, &amp;quot;wb&amp;quot;) as output:
        # 유니코드 조각을 바이너리로 변환한다
        for binary_chunk in iterencode(unicode_chunks, encoding):
            output.write(binary_chunk)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 두 함수와 함께 유니코드 데이터의 스트림에서 수직 탭을 없애는 일이 마법 같이 끝난다(just becomes a case of plumbing everything together).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 파일을 유니코드 조각 형태로 읽는다
unicode_chunks = iter_unicode_chunks(&amp;quot;input.txt&amp;quot;, encoding=&amp;quot;utf-16&amp;quot;)

# 유니코드 조각을 수정한다
unicode_chunks = (
    chunk.replace(u&amp;quot;\u000B&amp;quot;, u&amp;quot;&amp;quot;)
    for chunk
    in unicode_chunks
)

# 유니코드 조각을 파일에 저장한다
write_unicode_chunks(&amp;quot;output.txt&amp;quot;, unicode_chunks, encoding=&amp;quot;utf-8&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="codecs"&gt;거창하게 &lt;code&gt;codecs&lt;/code&gt; 모듈을 사용해야 할까?&lt;/h2&gt;
&lt;p&gt;얼핏 그냥, &lt;code&gt;str.decode()&lt;/code&gt;와 &lt;code&gt;unicode.encode()&lt;/code&gt; 메서드를 사용하여 큰 &lt;code&gt;file&lt;/code&gt; 객체를 바이너리 조각으로 읽고, 인코딩하고 디코딩하는 편이 간단하다고 생각할 수도 있겠다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 나쁜 예시. 이렇게 하지 마시오!

# 입력 스트림과 출력 스트림을 연다
with open(&amp;quot;input.txt&amp;quot;, &amp;quot;rb&amp;quot;) as input, open(&amp;quot;output.txt&amp;quot;, &amp;quot;wb&amp;quot;) as output:
    # 바이너리 데이터 조각들을 순회한다
    while True:
        # 데이터 조각을 읽는다
        chunk = input.read(4096)
        if not chunk:
            break
        # 위험: 바이너리 데이터를 utf-16으로 디코딩한다
        chunk = chunk.decode(&amp;quot;utf-16&amp;quot;)
        # 수직 탭을 삭제한다
        chunk = chunk.replace(u&amp;quot;\u000B&amp;quot;, u&amp;quot;&amp;quot;)
        # 유니코드 데이터를 utf-8로 인코딩한다
        chunk = chunk.encode(&amp;quot;utf-8&amp;quot;)
        # 데이터 조각을 쓴다
        output.write(chunk)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;불행히도 몇몇 유니코드 코드포인트는 바이너리 데이터의 한 바이트 이상으로 인코딩된다. 따라서 단순히 파일에서 바이트 조각들을 읽어서 &lt;code&gt;decode()&lt;/code&gt; 메서드를 적용하면 예기치 않게 &lt;code&gt;UnicodeDecodeError&lt;/code&gt;가 발생할 수도 있다. 이는 바이트 한 조각이 여러 바이트의 코드포인트로 분리되었기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;codecs&lt;/code&gt; 모듈의 도구들을 사용하면 이러한 예기치 않은 충돌을 예방할 수 있다.&lt;/p&gt;
&lt;h2 id="3"&gt;파이썬 3에서는?&lt;/h2&gt;
&lt;p&gt;파이썬 3에서는 훨씬 단순하게 유니코드 파일을 다룰 수 있다. 빌트인 메서드인 &lt;code&gt;open()&lt;/code&gt;은 유니코드 데이터를 수정하거나 인코딩을 변경하는 데 필요한 기능을 포함하고 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 입력 스트림과 출력 스트림을 연다
input = open(&amp;quot;input.txt&amp;quot;, &amp;quot;rt&amp;quot;, encoding=&amp;quot;utf-16&amp;quot;)
output = open(&amp;quot;output.txt&amp;quot;, &amp;quot;wt&amp;quot;, encoding=&amp;quot;utf-8&amp;quot;)

# 유니코드 데이터 조각들을 스트리밍한다
with input, output:
    while True:
        # 데이터 조각을 읽고
        chunk = input.read(4096)
        if not chunk:
            break
        # 수직 탭을 삭제한다
        chunk = chunk.replace(&amp;quot;\u000B&amp;quot;, &amp;quot;&amp;quot;)
        # 데이터 조각을 쓴다
        output.write(chunk)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;파이썬 3의 시대다! 즐겁게 코딩하길!&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>DRF3 튜토리얼 6 - 뷰셋과 라우터</title><description>(django-rest-framework 공식 문서를 번역함) django rest framework가 제공하는 뷰셋을 사용하여, 지금까지 만든 뷰들을 리팩터링합니다. 자주 작성해야 하는 코드들이 굉장히 간단해 집니다.</description><link>http://raccoonyy.github.io/drf3-tutorial-6/</link><guid isPermaLink="false">59815cfbdd47a80001bb9ea0</guid><category>django rest framework 3</category><category>DRF3</category><category>translate</category><category>Router</category><category>ViewSet</category><category>Django</category><dc:creator>raccoony</dc:creator><pubDate>Wed, 11 Mar 2015 05:02:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" alt="DRF3 튜토리얼 6 - 뷰셋과 라우터"&gt;&lt;p&gt;원문 - &lt;a href="http://www.django-rest-framework.org/tutorial/6-viewsets-and-routers"&gt;Viewsets and Routers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 &lt;a href="https://twitter.com/_tomchristie"&gt;Tom Christie&lt;/a&gt;에게 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="6"&gt;튜토리얼 6: 뷰셋 &amp;amp; 라우터&lt;/h1&gt;
&lt;p&gt;REST 프레임워크는 &lt;code&gt;ViewSets&lt;/code&gt;이라는 추상 클래스를 제공합니다. 이를 통해 개발자는 API의 상호작용이나 상태별 모델링에 집중할 수 있고, URL 구조는 기본 관례에 따라 자동으로 설정됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ViewSet&lt;/code&gt; 클래스는 &lt;code&gt;View&lt;/code&gt; 클래스와 거의 비슷하지만, &lt;code&gt;get&lt;/code&gt;과 &lt;code&gt;put&lt;/code&gt; 메서드는 지원하지 않고 &lt;code&gt;read&lt;/code&gt;와 &lt;code&gt;update&lt;/code&gt; 메서드를 지원합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ViewSet&lt;/code&gt; 클래스는 따지고 보면, 앞 장에서 만든 핸들러 메서드가 실제 뷰로 구체화될 때 이를 연결해주기만 합니다. 이때 보통은 &lt;code&gt;Router&lt;/code&gt; 클래스를 사용하여 복잡한 URL 설정을 처리합니다.&lt;/p&gt;
&lt;h2 id=""&gt;뷰셋을 사용하여 리팩터링하기&lt;/h2&gt;
&lt;p&gt;지금까지 만든 뷰들을 살펴보면서 뷰셋을 사용해서 리팩터링을 해봅시다.&lt;/p&gt;
&lt;p&gt;가장 먼저 리팩터링할 뷰는 &lt;code&gt;UserList&lt;/code&gt;와 &lt;code&gt;UserDetail&lt;/code&gt; 뷰입니다. &lt;code&gt;UserViewSet&lt;/code&gt; 하나로 모아보죠. 두 뷰의 코드를 삭제한 다음 아래의 클래스 하나를 입력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from rest_framework import viewsets

class UserViewSet(viewsets.ReadOnlyModelViewSet):
    &amp;quot;&amp;quot;&amp;quot;
    이 뷰셋은 `list`와 `detail` 기능을 자동으로 지원합니다
    &amp;quot;&amp;quot;&amp;quot;
    queryset = User.objects.all()
    serializer_class = UserSerializer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 사용한 &lt;code&gt;ReadOnlyModelViewSet&lt;/code&gt; 클래스는 '읽기 전용' 기능을 자동으로 지원합니다. &lt;code&gt;queryset&lt;/code&gt;과 &lt;code&gt;serializer_class&lt;/code&gt; 속성은 여전히 설정을 해야 하지만, 두 개의 클래스에 중복으로 설정할 필요는 없어졌습니다.&lt;/p&gt;
&lt;p&gt;다음으로는 &lt;code&gt;SnippetList&lt;/code&gt;와 &lt;code&gt;SnippetDetail&lt;/code&gt;, &lt;code&gt;SnippetHighlight&lt;/code&gt; 뷰를 리팩터링해보죠. 이 뷰들을 삭제하고, 아래의 클래스를 입력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from rest_framework.decorators import detail_route

class SnippetViewSet(viewsets.ModelViewSet):
    &amp;quot;&amp;quot;&amp;quot;
    이 뷰셋은 `list`와 `create`, `retrieve`, `update`, 'destroy` 기능을 자동으로 지원합니다

	여기에 `highlight` 기능의 코드만 추가로 작성했습니다
    &amp;quot;&amp;quot;&amp;quot;
    queryset = Snippet.objects.all()
    serializer_class = SnippetSerializer
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,
                          IsOwnerOrReadOnly,)

    @detail_route(renderer_classes=[renderers.StaticHTMLRenderer])
    def highlight(self, request, *args, **kwargs):
        snippet = self.get_object()
        return Response(snippet.highlighted)

    def perform_create(self, serializer):
            serializer.save(owner=self.request.user)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이번에는 읽기 기능과 쓰기 기능을 모두 지원하기 위해 &lt;code&gt;ModelViewSet&lt;/code&gt; 클래스를 사용했습니다.&lt;/p&gt;
&lt;p&gt;추가한 &lt;code&gt;highlight&lt;/code&gt; 기능에는 여전히 &lt;code&gt;@detail_route&lt;/code&gt; 데코레이터를 사용했습니다. 이 데코레이터는 &lt;code&gt;create&lt;/code&gt;나 &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;에 해당하지 않는 기능에 대해 사용하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@detail_route&lt;/code&gt; 데코레이터를 사용한 기능은 기본적으로 &lt;code&gt;GET&lt;/code&gt; 요청에 응답합니다. &lt;code&gt;methods&lt;/code&gt; 인자를 설정하면 &lt;code&gt;POST&lt;/code&gt; 요청에도 응답할 수 있습니다.&lt;/p&gt;
&lt;p&gt;추가 기능의 URL은 기본적으로 메서드 이름과 같습니다. 이를 변경하고 싶다면 데코레이터에 &lt;code&gt;url_path&lt;/code&gt; 인자를 설정하면 됩니다.&lt;/p&gt;
&lt;h2 id=""&gt;뷰셋과 주소를 명시적으로 연결하기&lt;/h2&gt;
&lt;p&gt;핸들러 메서드는 단지 URL 설정과 연결하는 기능만 담당합니다. 물 밑에서 어떤 일들이 벌어지는지 알아보고자, 여기서는 먼저 뷰셋의 뷰들을 명시적으로 적어보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;urls.py&lt;/code&gt; 파일에서 &lt;code&gt;ViewSet&lt;/code&gt; 클래스를 실제 뷰(concrete view)와 연결합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from snippets.views import SnippetViewSet, UserViewSet, api_root
from rest_framework import renderers

snippet_list = SnippetViewSet.as_view({
    'get': 'list',
    'post': 'create'
})
snippet_detail = SnippetViewSet.as_view({
    'get': 'retrieve',
    'put': 'update',
    'patch': 'partial_update',
    'delete': 'destroy'
})
snippet_highlight = SnippetViewSet.as_view({
    'get': 'highlight'
}, renderer_classes=[renderers.StaticHTMLRenderer])
user_list = UserViewSet.as_view({
    'get': 'list'
})
user_detail = UserViewSet.as_view({
    'get': 'retrieve'
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ViewSet&lt;/code&gt; 클래스의 뷰들을 HTTP 메서드에 따라 어떻게 실제 뷰와 연결했는지 살펴보세요.&lt;/p&gt;
&lt;p&gt;이제 실제 뷰와 URL을 연결해보겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;urlpatterns = format_suffix_patterns([
    url(r'^$', api_root),
    url(r'^snippets/$', snippet_list, name='snippet-list'),
    url(r'^snippets/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', snippet_detail, name='snippet-detail'),
    url(r'^snippets/(?P&amp;lt;pk&amp;gt;[0-9]+)/highlight/$', snippet_highlight, name='snippet-highlight'),
    url(r'^users/$', user_list, name='user-list'),
    url(r'^users/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', user_detail, name='user-detail')
])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;라우터 사용하기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;View&lt;/code&gt; 클래스 대신 &lt;code&gt;ViewSet&lt;/code&gt; 클래스를 사용했기 때문에, 이제는 URL도 설정할 필요가 없습니다. &lt;code&gt;Router&lt;/code&gt; 클래스를 사용하면 뷰 코드와 뷰, URL이 관례적으로 자동 연결됩니다. 단지 뷰를 라우터에 적절히 등록해주기만 하면 됩니다. 그러면 REST 프레임워크가 알아서 다 합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;urls.py&lt;/code&gt; 파일을 다음과 같이 고쳐보죠.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.conf.urls import url, include
from snippets import views
from rest_framework.routers import DefaultRouter

# 라우터를 생성하고 뷰셋을 등록합니다
router = DefaultRouter()
router.register(r'snippets', views.SnippetViewSet)
router.register(r'users', views.UserViewSet)

# 이제 API URL을 라우터가 자동으로 인식합니다
# 추가로 탐색 가능한 API를 구현하기 위해 로그인에 사용할 URL은 직접 설정을 했습니다
urlpatterns = [
    url(r'^', include(router.urls)),
    url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;라우터에 뷰셋을 등록하는 일은 url 패턴 설정하기와 비슷합니다. 여기서는 두 개를 등록했는데요. 뷰들에 사용할 URL의 접두어와 뷰셋입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DefaultRouter&lt;/code&gt; 클래스는 API의 최상단 뷰를 자동으로 생성해주므로, &lt;code&gt;views&lt;/code&gt; 모듈에 있는 &lt;code&gt;api_root&lt;/code&gt; 메서드와 연결했던 URL도 삭제하였습니다.&lt;/p&gt;
&lt;h2 id=""&gt;뷰? 뷰셋? 장단점 비교하기&lt;/h2&gt;
&lt;p&gt;뷰셋은 유용한 추상화입니다. API 전반에 걸쳐 일관적인 URL 관례를 구현할 수 있고 작성할 코드 양은 최소한으로 유지할 수 있어서, URL 설정에 낭비될 정성을 API의 상호작용과 표현 자체에 쏟을 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 이것이 항상 옳다는 뜻은 아닙니다. 클래스 기반 뷰와 함수 기반 뷰에 각각 장단점이 있듯이 말이죠. 뷰셋을 사용하면 명확함이 좀 약해집니다.&lt;/p&gt;
&lt;h2 id=""&gt;회고&lt;/h2&gt;
&lt;p&gt;정말 적은 양의 코드만으로 pastebin과 같은 웹 API를 구현했습니다. 이 API는 웹 브라우저를 완벽히 지원하고, 인증 기능도 있고, 오브젝트별로 권한도 설정되며 다양한 형태로 렌더링됩니다.&lt;/p&gt;
&lt;p&gt;지금까지 기본 Django 뷰에서 시작하여 기능들을 점진적으로 만드는 설계 과정을 차근차근 살펴보았습니다.&lt;/p&gt;
&lt;p&gt;최종 코드는 &lt;a href="https://github.com/tomchristie/rest-framework-tutorial"&gt;GitHub&lt;/a&gt;에서 볼 수 있고, &lt;a href="http://restframework.herokuapp.com/"&gt;라이브 데모&lt;/a&gt;에서 작동 모습을 확인할 수도 있습니다.&lt;/p&gt;
&lt;h2 id=""&gt;더 많은 것들&lt;/h2&gt;
&lt;p&gt;이제 튜토리얼이 끝났습니다. REST 프레임워크에 대해 더 알고 싶다면 다음 링크들로 시작하면 좋을 겁니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/tomchristie/django-rest-framework"&gt;GitHub&lt;/a&gt;에서 이슈를 등록하거나 리뷰하고, pull requests를 작성해 보세요.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://groups.google.com/forum/?fromgroups#!forum/django-rest-framework"&gt;REST 프레임워크 사용자 모임&lt;/a&gt;에 가입해서 활동해 보세요.&lt;/li&gt;
&lt;li&gt;창시자의 &lt;a href="https://twitter.com/_tomchristie"&gt;트위터&lt;/a&gt;를 팔로우하고 인사를 나누세요.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;이제 멋진 무언가를 만들어 보세요.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;번역에 도움을 주신 목돌님과 조청님께 감사합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</content:encoded></item><item><title>Django에서 쿼리셋 효과적으로 사용하기</title><description>Django ORM을 효율적으로 작성하는 방법을 알아봅니다. Django의 쿼리 지연, 쿼리셋 캐시의 특징을 이해한다면, 성능을 개선할 수 있습니다. 그리고 쿼리셋이 엄청나게 큰 경우엔 iterator()를 꼭 사용하고요.</description><link>http://raccoonyy.github.io/using-django-querysets-effectively-translate/</link><guid isPermaLink="false">59815cfbdd47a80001bb9ea1</guid><category>Django</category><category>translate</category><category>QuerySet</category><category>Effectively</category><category>formatter</category><dc:creator>raccoony</dc:creator><pubDate>Tue, 10 Mar 2015 05:04:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2016/01/IMG_0006.jpg" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2016/01/IMG_0006.jpg" alt="Django에서 쿼리셋 효과적으로 사용하기"&gt;&lt;p&gt;Django의 모델 쿼리를 좀 잘 활용하고 싶어서 아래 글을 읽다가 번역까지 해보았습니다.&lt;/p&gt;
&lt;p&gt;원문 - &lt;a href="http://blog.etianen.com/blog/2013/06/08/django-querysets/"&gt;Using Django QuerySets Effectively&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 Dave Hall 님께 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ORM 시스템을 사용하면 SQL 데이터베이스를 손쉽게 다룰 수 있다. 하지만 직접 작성한 SQL에 비해, 느리고 비효율적이라는 단점도 존재한다.&lt;/p&gt;
&lt;p&gt;ORM을 효과적으로 사용한다는 말은, ORM이 쿼리를 어떻게 작성하는지 이해한다는 뜻이다. 이 글에서는 중대형 데이터베이스에서 Django의 ORM 시스템을 효과적으로 사용하는 방법에 집중하려 한다.&lt;/p&gt;
&lt;h2 id="djangolazy"&gt;Django의 쿼리는 마지막까지 지연(lazy)된다&lt;/h2&gt;
&lt;p&gt;Django의 쿼리셋(queryset)은 데이터베이스의 여러 레코드(row)를 나타낸다. 필터링도 가능하다. 예를 들어 다음 코드는 DB에 저장된 사람 중 이름이 Dave인 모든 사람을 나타낸다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;person_set = Person.objects.filter(first_name=&amp;quot;Dave&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드는 DB에 어떤 쿼리도 전달하지 않는다. 여러분이 &lt;code&gt;person_set&lt;/code&gt;에 필터를 추가하거나 &lt;code&gt;person_set&lt;/code&gt;을 함수에 전달한다 해도, 이는 DB에 아무런 메시지도 전달하지 않는다. 이는 장점인데, 왜냐하면 DB에 쿼리를 전달하는 일이 웹 애플리케이션을 느려지게 하는 주범 중 하나이기 때문이다.&lt;/p&gt;
&lt;p&gt;DB의 레코드를 진짜로 가져오려면(fetch) 다음과 같이 쿼리셋을 순회(iterate)해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;for person in person_set:
    print(person.last_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="django"&gt;Django의 쿼리셋은 캐시된다&lt;/h2&gt;
&lt;p&gt;쿼리셋을 순회하는 시점에, 쿼리셋에 해당하는 DB의 레코드들을 실제로 가져오며(fetch), 이는 모두 Django 모델로 변환된다. 이를 가리켜 평가(evaluation)라고 한다. 평가된 모델들은 쿼리셋의 내장 캐시에 저장되며, 덕분에 여러분이 쿼리셋을 다시 순회하더라도 똑같은 쿼리를 DB에 다시 전달하지는 않는다.&lt;/p&gt;
&lt;p&gt;예를 들어, 다음 코드에서 DB 쿼리는 단 한 번만 발생한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;pet_set = Pet.objects.filter(species=&amp;quot;Dog&amp;quot;)

# 쿼리가 '평가'되고, 결과가 캐시된다.
for pet in pet_set:
    print(pet.first_name)
    
# 똑같은 순회를 반복할 경우 이미 캐시된 쿼리셋이 사용된다.
for pet in pet_set:
    print(pet.last_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="if"&gt;if 문에서는 쿼리셋 평가가 발생난다&lt;/h2&gt;
&lt;p&gt;쿼리셋의 캐시 기능은 특히, 일단 쿼리셋에 레코드가 존재하는지를 검사한 후 하나라도 발견되었을 때만 이를 순회하려 할 때 유용하다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;restaurant_set = Restaurant.objects.filter(cuisine=&amp;quot;Indian&amp;quot;)

#  if 문은 쿼리셋을 '평가'한다
if restaurant_set:
    # 순회할 때는 캐시된 쿼리셋이 사용된다
    for restaurant in restaurant_set:
        print(restaurant.name)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;결과 전체가 필요하지 않은 경우 쿼리셋 캐시가 문제가 된다&lt;/h2&gt;
&lt;p&gt;결과 전체를 순회하지 않고 단지 레코드가 최소한 하나는 존재하는지 알아보고 싶을 수도 있다. 이 경우, 쿼리 셋에 if 문을 사용하면 if 문 때문에 쿼리셋이 ‘평가’되고, 이에 따라 쿼리셋 캐시에도 전체 레코드가 저장된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;city_set = City.objects.filter(name=&amp;quot;Cambridge&amp;quot;)

# if 문은 쿼리셋을 평가한다
if city_set:
    # 쿼리셋의 전체 결과가 필요하지는 않은 상황임에도
    # ORM은 전체 결과를 가져온다(fetch)
    print(&amp;quot;At least one city called Cambridge still stands!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 피하려면 exists() 메서드를 사용하자. 이 메서드는 최소한 하나의 레코드가 존재하는지 여부를 확인하여 알려준다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;tree_set = Tree.objects.filter(type=&amp;quot;deciduous&amp;quot;)

# exists()는 쿼리셋 캐시를 만들지 않으면서 레코드가 존재하는지 검사한다
if tree_set.exists():
    # DB에서 가져온 레코드가 하나도 없다면
    # 트래픽과 메모리를 절약할 수 있다
    print(&amp;quot;There are still hardwood trees in the world!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;쿼리셋이 엄청 큰 경우 쿼리셋 캐시가 문제가 된다&lt;/h2&gt;
&lt;p&gt;몇 천 개 단위의 레코드를 다뤄야 할 경우, 이 데이터를 한 번에 가져와 메모리에 올리는 행위는 매우 비효율적이다. 더 나쁜 점은, 거대한 쿼리가 서버의 프로세스를 잠궈(lock) 버려서 웹 애플리케이션이 죽을 수도 있다는 사실이다.&lt;/p&gt;
&lt;p&gt;쿼리셋 캐시를 방지하면서도 전체 레코드를 순회해야 한다면, iterator()를 사용하자. 이는 데이터를 작은 덩어리로 쪼개어 가져오고, 이미 사용한 레코드는 메모리에서 지운다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;star_set = Star.objects.all()

# iterator() 메서드는 전체 레코드의 일부씩만 DB에서 가져오므로
# 메모리를 절약할 수 있다.
for star in star_set.iterator():
    print(star.name)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쿼리셋 캐시를 방지하고자 iterator() 메서드를 사용한 경우 당연하게도, 똑같은 쿼리셋을 한 번 더 순회할 때 쿼리를 다시 평가한다. 따라서 iterator() 메서드를 사용하기 전, 여러분의 코드에서 똑같은 거대 쿼리셋을 재사용하려고 하지는 않는지 주의해야 한다.&lt;/p&gt;
&lt;h2 id="if"&gt;쿼리셋이 엄청 큰 경우 if 문도 문제가 된다&lt;/h2&gt;
&lt;p&gt;앞서 보았듯이, 쿼리셋 캐시와 if/for 문을 조합하면 상황에 따라 쿼리셋을 순회하거나 하지 않을 수 있다. 하지만 쿼리셋이 엄청 큰 경우, 쿼리셋 캐시는 고려 사항이 될 수 없다.&lt;/p&gt;
&lt;p&gt;간단한 해결책으로 exists()와 iterator()를 함께 사용하면, DB에 두 개의 쿼리를 실행하고 그 결과를 쿼리셋 캐시로 생성하는 일을 방지할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;molecule_set = Molecule.objects.all()

# 첫 번째 쿼리로, 쿼리셋에 레코드가 존재하는지 확인한다
if molecule_set.exists():
    # 또다른 쿼리로 레코드를 조금씩 가져온다
    for molecule in molecule_set.iterator():
        print(molecule.velocity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;좀더 복잡한 해결책은 파이썬의 고급 순회 메서드(advanced iteration methods)를 사용하는 것이다. 이를 통해 순회를 진행할지 결정하기 전에 iterator() 메서드의 첫 번째 레코드를 감지(peek)할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;atom_set = Atom.objects.all()

# 첫 번째 쿼리로 레코드를 가져오기 시작한다
atom_iterator = atom_set.iterator()

# 첫 번째 레코드를 감지(peek)한다
try:
    first_atom = next(atom_iterator)
except StopIteration:
    # 레코드가 없다면 아무 일도 하지 않는다
    pass
else:
    # 레코드가 하나라도 존재한다면
    # 모든 레코드를 순회한다(첫 번째 레코드를 포함해서)
    from itertools import chain
    for atom in chain([first_atom], atom_set):
        print(atom.mass)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;안일한 최적화에 주의하라&lt;/h2&gt;
&lt;p&gt;쿼리셋 캐시는 애플리케이션이 만들어 내는 DB 쿼리의 개수를 줄이며, 일반적으로는 정말로 필요한 쿼리만을 DB에 전달하기 위해 존재한다.&lt;/p&gt;
&lt;p&gt;exists()와 iterator() 메서드를 사용하면 메모리 사용을 최적화할 수 있다. 그렇지만 쿼리셋 캐시는 생성되지 않기 때문에, DB 쿼리가 중복될 수 있다.&lt;/p&gt;
&lt;p&gt;코드를 주의 깊게 작성하고, 뭔가 느려진다 싶을 때 병목 지점을 조사한다면, 약간의 쿼리셋 최적화가 도움이 될 수도 있다.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>DRF3 튜토리얼 5 - 관계 &amp; 하이퍼링크 API</title><description>(django-rest-framework 공식 문서를 번역함) API의 시작 위치를 만들어 봅니다. 또, 각 부분을 하이퍼링크로 연결하여 탐색 가능한 API로 업그레이드합니다.</description><link>http://raccoonyy.github.io/drf3-tutorial-5/</link><guid isPermaLink="false">59815cfbdd47a80001bb9e9f</guid><category>django rest framework 3</category><category>DRF3</category><category>translate</category><category>Relationships</category><category>Hyperlinked-API</category><category>Django</category><dc:creator>raccoony</dc:creator><pubDate>Fri, 06 Mar 2015 04:16:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" alt="DRF3 튜토리얼 5 - 관계 &amp; 하이퍼링크 API"&gt;&lt;p&gt;원문 - &lt;a href="http://www.django-rest-framework.org/tutorial/5-relationships-and-hyperlinked-apis"&gt;Relationships and Hyperlinked APIs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 &lt;a href="https://twitter.com/_tomchristie"&gt;Tom Christie&lt;/a&gt;에게 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="5api"&gt;튜토리얼 5: 관계 &amp;amp; 하이퍼링크 API&lt;/h1&gt;
&lt;p&gt;지금까지 우리가 만든 API에서 '관계'는 주 키(primary key)로 나타나고 있었습니다. 이번 튜토리얼에서는 API의 발견성(discoverability)과 응집력(cohesion)을 향상시키고자 관계를 하이퍼링크로 나타내 보겠습니다.&lt;/p&gt;
&lt;h2 id="api"&gt;API의 최상단에 대한 엔드 포인트 만들기&lt;/h2&gt;
&lt;p&gt;지금까지 '코드 조각'과 '사용자'에 대한 엔드 포인트를 만들었지만, 아직까지 이렇다 할 API의 시작점은 없었습니다. 이를 만들기 위해 평범한 함수 기반 뷰와 &lt;code&gt;@api_view&lt;/code&gt; 데코레이터(&lt;a href="http://raccoonyy.github.io/drf3-tutorial-2/"&gt;2부 참고&lt;/a&gt;)를 사용해 보겠습니다. &lt;code&gt;snippets/views.py&lt;/code&gt; 파일을 여세요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.reverse import reverse


@api_view(('GET',))
def api_root(request, format=None):
    return Response({
        'users': reverse('user-list', request=request, format=format),
        'snippets': reverse('snippet-list', request=request, format=format)
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 URL을 만드는 데 &lt;code&gt;reverse&lt;/code&gt; 함수를 사용한 점을 주목하세요.&lt;/p&gt;
&lt;h2 id=""&gt;코드 조각의 하이라이트 버전에 대한 엔드 포인트 만들기&lt;/h2&gt;
&lt;p&gt;우리 API에서 아직까지 만들지 않은 부분은 바로, 코드 조각의 하이라이트 버전을 볼 수 있는 방법입니다.&lt;/p&gt;
&lt;p&gt;API의 다른 부분과는 달리 이번에는 JSON 대신 HTML 형태로 나타내겠습니다. REST 프레임워크에서 HTML로 렌더링하는 방식은 두 가지 정도가 있는데, 하나는 템플릿을 사용하는 것이고, 다른 하나는 미리 렌더링된 HTML을 사용하는 것입니다. 이번에는 후자가 더 어울려 보입니다.&lt;/p&gt;
&lt;p&gt;하이라이트된 코드 조각을 보여주려고 할 때 주의해야 할 점 하나는, 우리가 사용할 만한 제네릭 뷰가 없다는 것입니다. 오브젝트 자체가 아니라, 오브젝트의 속성 하나를 반환할 것이기 때문입니다.&lt;/p&gt;
&lt;p&gt;제네릭 뷰 대신 평범한 클래스를 사용하고, &lt;code&gt;.get()&lt;/code&gt; 메서드를 구현하겠습니다. &lt;code&gt;snippets/views.py&lt;/code&gt; 파일에 다음 내용을 추가하세요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from rest_framework import renderers
from rest_framework.response import Response

class SnippetHighlight(generics.GenericAPIView):
    queryset = Snippet.objects.all()
    renderer_classes = (renderers.StaticHTMLRenderer,)

    def get(self, request, *args, **kwargs):
        snippet = self.get_object()
        return Response(snippet.highlighted)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;지금까지 그래왔듯이, 새 뷰는 URL 설정에서도 연결해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;snippets/urls.py&lt;/code&gt; 파일에서 최상단 url을 방금 만든 뷰로 연결합시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;url(r'^$', views.api_root),
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하이라이트된 코드 조각을 볼 수 있는 url에 대한 패턴도 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;url(r'^snippets/(?P&amp;lt;pk&amp;gt;[0-9]+)/highlight/$', views.SnippetHighlight.as_view()),
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="api"&gt;하이퍼링크로 API 연결하기&lt;/h2&gt;
&lt;p&gt;요소들 사이의 관계를 다루는 일은 웹 API 설계에서 또 하나의 도전 과제입니다. 관계를 표현하는 방법은 꽤 다양합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주 키(primary key)&lt;/li&gt;
&lt;li&gt;하이퍼링크&lt;/li&gt;
&lt;li&gt;관계 요소의 식별 가능한 슬러그(slug) 필드&lt;/li&gt;
&lt;li&gt;관계 요소의 기본 문자열 표현&lt;/li&gt;
&lt;li&gt;포함된 관계 요소에 대한 표현&lt;/li&gt;
&lt;li&gt;이 외에도 사용자화된 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REST 프레임워크에서는 모든 방법을 지원합니다. 관계 혹은 역관계에 적용하거나, 제네릭 외부 키(foreign key)처럼 사용자화된 manager에 적용할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;여기서는 하이퍼링크 방식을 채택하겠습니다. 이러게 하려면 기존에 사용했던 &lt;code&gt;ModelSerializer&lt;/code&gt;를 &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt;로 변경해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt;는 다음과 같은 점들이 다릅니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pk&lt;/code&gt; 필드는 기본 요소가 아닙니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HyperlinkedIdentityField&lt;/code&gt;를 사용하는 &lt;code&gt;url&lt;/code&gt; 필드가 포함되어 있습니다.&lt;/li&gt;
&lt;li&gt;관계는 &lt;code&gt;PrimaryKeyRelatedField&lt;/code&gt; 대신 &lt;code&gt;HyperlinkedRelatedField&lt;/code&gt;를 사용하여 나타냅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;기존 시리얼라이저에 하이퍼링크를 추가하기는 쉽습니다. &lt;code&gt;snippets/serializers.py&lt;/code&gt; 파일에 다음 내용을 추가합시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SnippetSerializer(serializers.HyperlinkedModelSerializer):
    owner = serializers.ReadOnlyField(source='owner.username')
    highlight = serializers.HyperlinkedIdentityField(view_name='snippet-highlight', format='html')

    class Meta:
        model = Snippet
        fields = ('url', 'highlight', 'owner',
                  'title', 'code', 'linenos', 'language', 'style')


class UserSerializer(serializers.HyperlinkedModelSerializer):
    snippets = serializers.HyperlinkedRelatedField(many=True, view_name='snippet-detail', read_only=True)

    class Meta:
        model = User
        fields = ('url', 'username', 'snippets')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드에서는 새롭게 &lt;code&gt;'highlight'&lt;/code&gt; 필드가 추가되었습니다. 이 필드는 &lt;code&gt;url&lt;/code&gt; 필드와 같은 타입이며, &lt;code&gt;'snippet-detail'&lt;/code&gt; url 패턴 대신 &lt;code&gt;'snippet-highlight'&lt;/code&gt; url 패턴을 가리킵니다.&lt;/p&gt;
&lt;p&gt;앞에서 URL의 format 접미어로 &lt;code&gt;'.json'&lt;/code&gt;을 붙였듯이, &lt;code&gt;highlight&lt;/code&gt; 필드에는 format 접미어로 &lt;code&gt;'.html'&lt;/code&gt;을 붙였습니다.&lt;/p&gt;
&lt;h2 id="url"&gt;URL 패턴에 이름 붙이기&lt;/h2&gt;
&lt;p&gt;하이퍼링크 API를 만들고 싶다면, URL 패턴에 이름을 붙여야 합니다. 어떤 패턴들인지 살펴봅시다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API의 최상단은 &lt;code&gt;'user-list'&lt;/code&gt;와 &lt;code&gt;'snippet-list'&lt;/code&gt;를 가리킵니다.&lt;/li&gt;
&lt;li&gt;코드 조각 시리얼라이저에는 &lt;code&gt;'snippet-highlight'&lt;/code&gt;를 가리키는 필드가 존재합니다.&lt;/li&gt;
&lt;li&gt;사용자 시리얼라이저에는 &lt;code&gt;'snippet-detail'&lt;/code&gt;을 가리키는 필드가 존재합니다.&lt;/li&gt;
&lt;li&gt;코드 조각 시리얼라이저와 사용자 시리얼라이저에는 &lt;code&gt;'url'&lt;/code&gt; 필드가 존재합니다. 이 필드는 기본적으로 &lt;code&gt;'{모델_이름}-detail'&lt;/code&gt;을 가리키며 따라서 &lt;code&gt;'snippet-detail'&lt;/code&gt;과 &lt;code&gt;'user-detail'&lt;/code&gt;을 가리킵니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 이름들을 URL 설정에 넣었다면 &lt;code&gt;snippets/urls.py&lt;/code&gt; 파일은 다음과 같을 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.conf.urls import url, include

# API endpoints
urlpatterns = format_suffix_patterns([
    url(r'^$', views.api_root),
    url(r'^snippets/$',
        views.SnippetList.as_view(),
        name='snippet-list'),
    url(r'^snippets/(?P&amp;lt;pk&amp;gt;[0-9]+)/$',
        views.SnippetDetail.as_view(),
        name='snippet-detail'),
    url(r'^snippets/(?P&amp;lt;pk&amp;gt;[0-9]+)/highlight/$',
        views.SnippetHighlight.as_view(),
        name='snippet-highlight'),
    url(r'^users/$',
        views.UserList.as_view(),
        name='user-list'),
    url(r'^users/(?P&amp;lt;pk&amp;gt;[0-9]+)/$',
        views.UserDetail.as_view(),
        name='user-detail')
])

# 탐색 가능한 API를 위한 로그인/로그아웃 뷰
urlpatterns += [
    url(r'^api-auth/', include('rest_framework.urls',
                               namespace='rest_framework')),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;페이징 기능 추가하기&lt;/h2&gt;
&lt;p&gt;사용자나 코드 조각의 목록이 꽤 긴 경우가 있을 겁니다. 따라서 결과물을 여러 페이지로 나누어, API 클라이언트 측에서 각 페이지를 하나씩 차례대로 읽어가도록 만들면 좋겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tutorial/settings.py&lt;/code&gt; 파일을 열어 페이징 설정의 기본 값을 바꿔 봅시다. 다음을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;REST_FRAMEWORK = {
    'PAGE_SIZE': 10
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;REST 프레임워크의 모든 설정은 'REST_FRAMEWORK'라는 딕셔너리에 넣어야 합니다. 이렇게 해야 프로젝트의 다른 설정들과 분리할 수 있습니다.&lt;/p&gt;
&lt;p&gt;필요에 따라 페이징 스타일을 바꿀 수도 있지만 여기서는 기본 스타일을 따르겠습니다.&lt;/p&gt;
&lt;h2 id="api"&gt;탐색 가능한 API&lt;/h2&gt;
&lt;p&gt;탐색 가능한 API를 브라우저에서 열어서 링크들을 이리 저리 눌러보면, API의 구석구석을 둘러볼 수 있을 겁니다.&lt;/p&gt;
&lt;p&gt;또한 코드 조각 인스턴스의 '하이라이트 버전'을 살펴볼 수도 있겠습니다. (HTML 형태입니다.)&lt;/p&gt;
&lt;p&gt;&lt;a href="http://raccoonyy.github.io/drf3-tutorial-6"&gt;튜토리얼 6부&lt;/a&gt;에서는 뷰셋과 라우터를 통해 코드 양을 줄이는 방법을 배우겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;번역에 도움을 주신 파이님께 감사합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</content:encoded></item><item><title>DRF3 튜토리얼 4 - 인증과 권한</title><description>(django-rest-framework 공식 문서를 번역함) 지금까지 만든 API에 로그인 기능을 추가합니다. 또, 코드 조각을 올렸던 사용자만 해당 코드 조각을 편집하거나 삭제하도록 권한을 제한하겠습니다.</description><link>http://raccoonyy.github.io/drf3-tutorial-4/</link><guid isPermaLink="false">59815cfbdd47a80001bb9e9e</guid><category>django rest framework 3</category><category>DRF3</category><category>translate</category><category>Authentication</category><category>Permissions</category><category>Django</category><dc:creator>raccoony</dc:creator><pubDate>Fri, 06 Mar 2015 04:15:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" alt="DRF3 튜토리얼 4 - 인증과 권한"&gt;&lt;p&gt;원문 - &lt;a href="http://www.django-rest-framework.org/tutorial/4-authentication-and-permissions"&gt;Authentication &amp;amp; Permissions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 &lt;a href="https://twitter.com/_tomchristie"&gt;Tom Christie&lt;/a&gt;에게 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="4"&gt;튜토리얼 4: 인증과 권한&lt;/h1&gt;
&lt;p&gt;지금까지 우리가 만든 API에서는 누구라도 코드 조각을 편집하거나 삭제할 수 있습니다. 아무 제한이 없죠. 여기에 다음과 같은 고급 기능을 추가하고 싶습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드 조각은 만든 사람과 연관이 있다.&lt;/li&gt;
&lt;li&gt;인증받은 사용자만 코드 조각을 만들 수 있다.&lt;/li&gt;
&lt;li&gt;해당 코드 조각을 만든 사람만, 이를 편집하거나 삭제할 수 있다.&lt;/li&gt;
&lt;li&gt;인증받지 않은 사용자는 '읽기 전용'으로만 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=""&gt;모델에 속성 추가하기&lt;/h2&gt;
&lt;p&gt;먼저 &lt;code&gt;Snippet&lt;/code&gt; 모델을 조금 수정해보겠습니다.&lt;/p&gt;
&lt;p&gt;필드를 두 개 추가합니다. 하나(owner)는 코드 조각을 만든 사람을 가리킵니다. 다른 하나는 하이라이트된 코드를 HTML 형태로 저장하는 데 사용됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;models.py&lt;/code&gt;에 있는 &lt;code&gt;Snippet&lt;/code&gt; 모델에 다음 내용을 추가하세요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;owner = models.ForeignKey('auth.User', related_name='snippets')
highlighted = models.TextField()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 모델이 저장될 때 하이라이트된 코드를 highlighed 필드에 저장해야 합니다. 코드 하이라이팅에는 &lt;code&gt;pygments&lt;/code&gt; 라이브러리를 사용합니다.&lt;/p&gt;
&lt;p&gt;필요한 라이브러리들을 임포트하고,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pygments.lexers import get_lexer_by_name
from pygments.formatters.html import HtmlFormatter
from pygments import highlight
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모델에 &lt;code&gt;.save()&lt;/code&gt; 메서드를 작성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def save(self, *args, **kwargs):
    &amp;quot;&amp;quot;&amp;quot;
    `pygments` 라이브러리를 사용하여 하이라이트된 코드를 만든다.
    &amp;quot;&amp;quot;&amp;quot;
    lexer = get_lexer_by_name(self.language)
    linenos = self.linenos and 'table' or False
    options = self.title and {'title': self.title} or {}
    formatter = HtmlFormatter(style=self.style, linenos=linenos,
                              full=True, **options)
    self.highlighted = highlight(self.code, lexer, formatter)
    super(Snippet, self).save(*args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드를 모두 작성했다면 데이터베이스를 업데이트해야 합니다.&lt;/p&gt;
&lt;p&gt;보통은 데이터베이스 마이그레이션을 작성하겠지만, 지금은 튜토리얼일 뿐이니 데이터베이스를 지우고 새로 만들겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;rm -f tmp.db db.sqlite3
rm -r snippets/migrations
python manage.py makemigrations snippets
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;API를 테스트하는 데 사용할 사용자 계정을 만들고 싶다면, 다음과&lt;br&gt;
같이 &lt;code&gt;createsuperuser&lt;/code&gt; 명령을 사용하시면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python manage.py createsuperuser
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;사용자 모델에 엔드포인트 추가하기&lt;/h2&gt;
&lt;p&gt;사용자를 추가했으니 사용자를 보여주는 API도 추가합시다. &lt;code&gt;serializers.py&lt;/code&gt; 파일에 새 시리얼라이저를 작성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.contrib.auth.models import User

class UserSerializer(serializers.ModelSerializer):
    snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all())

    class Meta:
        model = User
        fields = ('id', 'username', 'snippets')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;'snippets'&lt;/code&gt;는 사용자 모델과 &lt;strong&gt;반대 방향&lt;/strong&gt;으로 이어져 있기 때문에 &lt;code&gt;ModelSerializer&lt;/code&gt;에 기본적으로 추가되지 않습니다. 따라서 명시적으로 필드를 지정해주었습니다.&lt;/p&gt;
&lt;p&gt;사용자와 관련된 뷰도 추가해야겠죠. 읽기 전용 뷰만 있으면 되니까, 제네릭 클래스 기반 뷰 중에서 &lt;code&gt;ListAPIView&lt;/code&gt;와 &lt;code&gt;RetrieveAPIView&lt;/code&gt;를 사용합시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.contrib.auth.models import User


class UserList(generics.ListAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer


class UserDetail(generics.RetrieveAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;UserSerializer&lt;/code&gt; 클래스도 임포트하고요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from snippets.serializers import UserSerializer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;마지막으로 뷰에 URL을 연결합시다. &lt;code&gt;urls.py&lt;/code&gt; 파일에 다음 내용을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;url(r'^users/$', views.UserList.as_view()),
url(r'^users/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', views.UserDetail.as_view()),
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;사용자가 만든 코드 조각 연결하기&lt;/h2&gt;
&lt;p&gt;지금까지는 코드 조각을 만들었더라도, 해당 코드 조각을 만든 사용자와 아무 관계도 맺지 않았습니다. 사용자는 직렬화된 표현에 나타나지 않았고, 요청하는 측에서 지정하는 속성이었을 뿐입니다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해 코드 조각 뷰에서 &lt;code&gt;.perform_create()&lt;/code&gt; 메서드를 오버라이딩합시다. 이 메서드는 인스턴스를 저장하는 과정을 조정하며, 따라서 요청이나 요청 URL에서 정보를 가져와 원하는 대로 다룰 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SnippetList&lt;/code&gt; 뷰 클래스에 다음 내용을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def perform_create(self, serializer):
    serializer.save(owner=self.request.user)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우리가 만든 시리얼라이저의 &lt;code&gt;create()&lt;/code&gt; 메서드는 검증한 요청 데이터에 더하여 &lt;code&gt;'owner'&lt;/code&gt; 필드도 전달합니다.&lt;/p&gt;
&lt;h2 id=""&gt;시리얼라이저 업데이트하기&lt;/h2&gt;
&lt;p&gt;이제 코드 조각이, 해당 코드 조각을 작성한 사용자와 연결되었습니다. &lt;code&gt;SnippetSerializer&lt;/code&gt;에도 이를 반영합시다. 다음 내용을 &lt;code&gt;serializers.py&lt;/code&gt;의 &lt;code&gt;SnippetSerializer&lt;/code&gt;에 추가합시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;owner = serializers.ReadOnlyField(source='owner.username')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;안내:&lt;/strong&gt; &lt;code&gt;Meta&lt;/code&gt; 클래스의 필드 목록에도 &lt;code&gt;'owner'&lt;/code&gt;를 추가해야 합니다.&lt;/p&gt;
&lt;p&gt;이 필드에는 조금 재미있는 면이 있는데요. &lt;code&gt;source&lt;/code&gt; 인자로는 특정 필드를 지정할 수 있습니다. 여기에는 직렬화된 인스턴스의 속성 뿐만 아니라 위의 코드에서처럼 마침표 표기 방식을 통해 특정 속성을 탐색할 수도 있습니다. 마치 Django의 템플릿 언어와 비슷하죠.&lt;/p&gt;
&lt;p&gt;이 필드는 &lt;code&gt;CharField&lt;/code&gt;나 &lt;code&gt;BooleanField&lt;/code&gt;와는 달리 타입이 없는 &lt;code&gt;ReadOnlyField&lt;/code&gt; 클래스로 지정했습니다. 타입이 없는 &lt;code&gt;ReadOnlyField&lt;/code&gt;는 직렬화에 사용되었을 땐 언제나 읽기 전용이므로, 모델의 인스턴스를 업데이트할 때는 사용할 수 없습니다. &lt;code&gt;CharField(read_only=True)&lt;/code&gt;도 이와 같은 기능을 수행합니다.&lt;/p&gt;
&lt;h2 id=""&gt;뷰에 요청 권한 추가하기&lt;/h2&gt;
&lt;p&gt;이렇게 해서 코드 조각이 사용자와 연결되었습니다. 이제 인증 받은 사용자만 코드 조각을 생성/업데이트/삭제해봅시다.&lt;/p&gt;
&lt;p&gt;REST 프레임워크는 특정 뷰에 제한을 걸 수 있는 권한 클래스를 제공하고 있습니다. 그 중 한 가지인 &lt;code&gt;IsAuthenticatedOrReadOnly&lt;/code&gt;는 인증 받은 요청에 읽기와 쓰기 권한을 부여하고, 인증 받지 않은 요청에 대해서는 읽기 권한만 부여합니다.&lt;/p&gt;
&lt;p&gt;뷰 파일에 다음 내용을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from rest_framework import permissions
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 &lt;code&gt;SnippetList&lt;/code&gt; 클래스와 &lt;code&gt;SnippetDetail&lt;/code&gt; 클래스에 &lt;strong&gt;모두&lt;/strong&gt; 다음 속성을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="api"&gt;탐색 가능한 API에 로그인 추가하기&lt;/h2&gt;
&lt;p&gt;여러분이 지금 시점에 브라우저에서 API에 접속해본다면 더이상 새 코드 조각을 만들 수 없다는 사실을 알 수 있을 겁니다. 이를 해결하려면 사용자 로그인 기능이 필요합니다.&lt;/p&gt;
&lt;p&gt;URL 설정 파일인 &lt;code&gt;urls.py&lt;/code&gt;를 수정하면 탐색 가능한 API에 사용할 로그인 뷰를 추가할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다음 내용을 &lt;code&gt;urls.py&lt;/code&gt; 파일의 첫 부분에 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.conf.urls import include
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 파일의 끝 부분에 다음 내용을 추가합니다. 탐색 가능한 API의 로그인 뷰와 로그아웃 뷰에 사용되는 url 패턴입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;urlpatterns += [
    url(r'^api-auth/', include('rest_framework.urls',
                               namespace='rest_framework')),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;url 패턴에서 &lt;code&gt;r'^api-auth/'&lt;/code&gt; 부분은 여러분이 사용하고 싶은 URL을 나타냅니다. 여기에는 한 가지 제약만 따르는데, 바로 namespace에 &lt;code&gt;'rest_framework'&lt;/code&gt;를 지정해야 한다는 점입니다.&lt;/p&gt;
&lt;p&gt;다시 브라우저로 돌아가 API에 접근해 보면 오른쪽 상단에 'Login' 링크가 보일 겁니다. 이제 앞에서 만들었던 사용자로 로그인하면 코드 조각을 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;코드 조각을 몇 개 만든 후에는 '/users/'에도 가보세요. 해당 사용자가 만든 코드 조각 목록이 'snippets' 필드에 포함되어 있을 겁니다.&lt;/p&gt;
&lt;h2 id=""&gt;객체 수준에서 권한 설정하기&lt;/h2&gt;
&lt;p&gt;코드 조각은 아무나 볼 수 있어야 하지만, 업데이트와 삭제는 해당 코드를 만든 사용자만 할 수 있어야 합니다.&lt;/p&gt;
&lt;p&gt;이를 위해 커스텀 권한을 만들어 봅시다.&lt;/p&gt;
&lt;p&gt;snippets 앱 안에 &lt;code&gt;permissions.py&lt;/code&gt; 파일을 만들고 다음 내용을 입력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):
    &amp;quot;&amp;quot;&amp;quot;
    객체의 소유자에게만 쓰기를 허용하는 커스텀 권한
    &amp;quot;&amp;quot;&amp;quot;

    def has_object_permission(self, request, view, obj):
        # 읽기 권한은 모두에게 허용하므로,
        # GET, HEAD, OPTIONS 요청은 항상 허용함
        if request.method in permissions.SAFE_METHODS:
            return True

        # 쓰기 권한은 코드 조각의 소유자에게만 부여함
        return obj.owner == request.user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 만든 커스텀 권한을 코드 조각 인스턴스에 추가합시다. &lt;code&gt;SnippetDetail&lt;/code&gt; 클래스에 &lt;code&gt;permission_classes&lt;/code&gt; 속성을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;permission_classes = (permissions.IsAuthenticatedOrReadOnly,
                      IsOwnerOrReadOnly,)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연히 &lt;code&gt;IsOwnerOrReadOnly&lt;/code&gt; 클래스를 임포트해야겠고요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from snippets.permissions import IsOwnerOrReadOnly
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다시 브라우저로 돌아가 보면, 코드 조각에 대한 'DELETE'와 'PUT' 기능은 해당 사용자에게만 나타날 겁니다.&lt;/p&gt;
&lt;h2 id="api"&gt;API에 인증 붙이기&lt;/h2&gt;
&lt;p&gt;API에 권한을 설정했으므로, 이제는 코드 조각을 수정할 수 있는 인증 절차가 필요합니다. 지금까지는 &lt;a href="http://www.django-rest-framework.org/api-guide/authentication"&gt;인증 클래스&lt;/a&gt;를 만들지 않고 기본으로 제공되는 &lt;code&gt;SessionAuthentication&lt;/code&gt;과 &lt;code&gt;BasicAuthentication&lt;/code&gt;을 사용했습니다.&lt;/p&gt;
&lt;p&gt;웹 브라우저로 API를 사용하는 경우, 로그인을 하면 브라우저의 세션에 인증 정보가 저장됩니다.&lt;/p&gt;
&lt;p&gt;프로그램 상에서 API를 사용하는 경우, 인증에 필요한 내용을 명시적으로 전달해야만 합니다.&lt;/p&gt;
&lt;p&gt;인증 없이 코드 조각을 생성하려는 경우, 다음과 같이 에러를 보여줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;http POST http://127.0.0.1:8000/snippets/ code=&amp;quot;print 123&amp;quot;

{
    &amp;quot;detail&amp;quot;: &amp;quot;Authentication credentials were not provided.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자 계정과 비밀번호를 포함하여 요청한다면, 이 요청은 성공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;http -a tom:password POST http://127.0.0.1:8000/snippets/ code=&amp;quot;print 789&amp;quot;

{
    &amp;quot;id&amp;quot;: 5,
    &amp;quot;owner&amp;quot;: &amp;quot;tom&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;foo&amp;quot;,
    &amp;quot;code&amp;quot;: &amp;quot;print 789&amp;quot;,
    &amp;quot;linenos&amp;quot;: false,
    &amp;quot;language&amp;quot;: &amp;quot;python&amp;quot;,
    &amp;quot;style&amp;quot;: &amp;quot;friendly&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;요약&lt;/h2&gt;
&lt;p&gt;이렇게 해서 웹 API 위에 권한들이 잘 설정되었고, 사용자의 코드 조각에 대한 엔드 포인트도 완성되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://raccoonyy.github.io/drf3-tutorial-5"&gt;튜토리얼 5부&lt;/a&gt;에서는 이 모든 것을 한 데 엮어 하이라이트된 코드 조각을 보여주는 HTML 엔드 포인트를 만들고, API에서는 관련 모델에 대한 링크도 제공해 보겠습니다.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>DRF3 튜토리얼 3 - 클래스 기반 뷰</title><description>(django-rest-framework 공식 문서를 번역함) 앞서 함수 기반으로 만들었던 API 뷰를 클래스 기반 뷰로도 만들 수 있습니다. 이는 일반적인 기능을 재사용하게 해주며 코드 중복(DRY)도 막아주기 때문에 굉장히 쓸모 있는 패턴입니다.</description><link>http://raccoonyy.github.io/drf3-tutorial-3/</link><guid isPermaLink="false">59815cfbdd47a80001bb9e9d</guid><category>django rest framework 3</category><category>DRF3</category><category>translate</category><category>CBV</category><category>class based view</category><category>Django</category><dc:creator>raccoony</dc:creator><pubDate>Fri, 06 Mar 2015 04:14:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" alt="DRF3 튜토리얼 3 - 클래스 기반 뷰"&gt;&lt;p&gt;원문 - &lt;a href="http://www.django-rest-framework.org/tutorial/3-class-based-views/"&gt;Class Based Views&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 &lt;a href="https://twitter.com/_tomchristie"&gt;Tom Christie&lt;/a&gt;에게 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="3"&gt;튜토리얼 3: 클래스 기반 뷰&lt;/h1&gt;
&lt;p&gt;앞서 함수 기반으로 만들었던 API 뷰를 클래스 기반 뷰로도 만들 수 있습니다. 이는 일반적인 기능을 재사용하게 해주며 코드 중복(&lt;a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself"&gt;DRY&lt;/a&gt;)도 막아주기 때문에 굉장히 쓸모 있는 패턴입니다.&lt;/p&gt;
&lt;h2 id="api"&gt;클래스 기반 뷰로 API 재작성하기&lt;/h2&gt;
&lt;p&gt;먼저 최상단 뷰를 클래스 기반 뷰로 재작성해봅시다. 이를 위해 &lt;code&gt;views.py&lt;/code&gt;를 약간 리팩터링해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from snippets.models import Snippet
from snippets.serializers import SnippetSerializer
from django.http import Http404
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status


class SnippetList(APIView):
    &amp;quot;&amp;quot;&amp;quot;
    코드 조각을 모두 보여주거나 새 코드 조각을 만듭니다.
    &amp;quot;&amp;quot;&amp;quot;
    def get(self, request, format=None):
        snippets = Snippet.objects.all()
        serializer = SnippetSerializer(snippets, many=True)
        return Response(serializer.data)

    def post(self, request, format=None):
        serializer = SnippetSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;좋습니다. 이전 코드와 거의 똑같이 보이지만 HTTP 메서드를 분리했기 때문에 좀더 좋습니다. 마찬가지로 &lt;code&gt;views.py&lt;/code&gt; 파일을 열어, 코드 조각 하나를 담당하는 뷰도 수정해봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SnippetDetail(APIView):
    &amp;quot;&amp;quot;&amp;quot;
    코드 조각 조회, 업데이트, 삭제
    &amp;quot;&amp;quot;&amp;quot;
    def get_object(self, pk):
        try:
            return Snippet.objects.get(pk=pk)
        except Snippet.DoesNotExist:
            raise Http404

    def get(self, request, pk, format=None):
        snippet = self.get_object(pk)
        serializer = SnippetSerializer(snippet)
        return Response(serializer.data)

    def put(self, request, pk, format=None):
        snippet = self.get_object(pk)
        serializer = SnippetSerializer(snippet, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def delete(self, request, pk, format=None):
        snippet = self.get_object(pk)
        snippet.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;훌륭합니다. 그렇지만 역시나 아직까진 함수 기반 뷰와 크게 다르지 않습니다.&lt;/p&gt;
&lt;p&gt;이제 &lt;code&gt;urls.py&lt;/code&gt;도 수정해야 합니다. 클래스 기반 뷰를 사용해야 하니까요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.conf.urls import url
from rest_framework.urlpatterns import format_suffix_patterns
from snippets import views

urlpatterns = [
    url(r'^snippets/$', views.SnippetList.as_view()),
    url(r'^snippets/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', views.SnippetDetail.as_view()),
]

urlpatterns = format_suffix_patterns(urlpatterns)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자, 끝났습니다. 개발 서버를 실행해 보면 이전과 동일하게 작동하는 모습을 볼 수 있을 겁니다.&lt;/p&gt;
&lt;h2 id=""&gt;믹스인 사용하기&lt;/h2&gt;
&lt;p&gt;클래스 기반 뷰를 사용하여 얻는 가장 큰 이점은 기능들을 손쉽게 조합할 수 있다는 점입니다.&lt;/p&gt;
&lt;p&gt;지금까지 사용한 생성/조회/업데이트/삭제 등의 명령은 일반적으로 모델을 사용할 때의 뷰와 비슷합니다. 이러한 보편적인 기능을 REST 프레임워크에서는 믹스인 클래스로 구현해두었습니다.&lt;/p&gt;
&lt;p&gt;이제 뷰에 믹스인 클래스를 추가하는 모습을 살펴봅시다. &lt;code&gt;views.py&lt;/code&gt; 파일입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from snippets.models import Snippet
from snippets.serializers import SnippetSerializer
from rest_framework import mixins
from rest_framework import generics

class SnippetList(mixins.ListModelMixin,
                  mixins.CreateModelMixin,
                  generics.GenericAPIView):
    queryset = Snippet.objects.all()
    serializer_class = SnippetSerializer

    def get(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        return self.create(request, *args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 무슨 일이 벌어지는지 꼼꼼히 따져봅시다. &lt;code&gt;GenericAPIView&lt;/code&gt;와 &lt;code&gt;ListModelMixin&lt;/code&gt;, &lt;code&gt;CreateModelMixin&lt;/code&gt;을 사용하여 뷰를 만들었습니다.&lt;/p&gt;
&lt;p&gt;기본 뷰(&lt;code&gt;GenericAPIView&lt;/code&gt;)는 핵심 기능을 제공하며, 믹스인 클래스들은 &lt;code&gt;.list()&lt;/code&gt;나 &lt;code&gt;.create()&lt;/code&gt; 기능을 제공합니다. 여기서는 이 기능들을 &lt;code&gt;get&lt;/code&gt;과 &lt;code&gt;post&lt;/code&gt; 메서드에 적절히 연결하였습니다. 이정도면 간단하죠?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SnippetDetail(mixins.RetrieveModelMixin,
                    mixins.UpdateModelMixin,
                    mixins.DestroyModelMixin,
                    generics.GenericAPIView):
    queryset = Snippet.objects.all()
    serializer_class = SnippetSerializer

    def get(self, request, *args, **kwargs):
        return self.retrieve(request, *args, **kwargs)

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;비슷하게, 여기서도 &lt;code&gt;GenericAPIView&lt;/code&gt;는 핵심 기능을 제공하며, 나머지 믹스인들이 &lt;code&gt;.retrieve()&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt;, &lt;code&gt;.destroy()&lt;/code&gt; 기능을 제공합니다.&lt;/p&gt;
&lt;h2 id=""&gt;제네릭 클래스 기반 뷰 사용하기&lt;/h2&gt;
&lt;p&gt;믹스인 클래스를 사용하여 뷰의 코드를 꽤 많이 줄였지만, 더 줄일 수 있습니다. REST 프레임워크에서는 믹스인과 연결된 제네릭 뷰를 제공합니다. 이를 사용하면 &lt;code&gt;views.py&lt;/code&gt; 파일이 굉장히 짧아집니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from snippets.models import Snippet
from snippets.serializers import SnippetSerializer
from rest_framework import generics


class SnippetList(generics.ListCreateAPIView):
    queryset = Snippet.objects.all()
    serializer_class = SnippetSerializer


class SnippetDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Snippet.objects.all()
    serializer_class = SnippetSerializer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보세요, 정말 간결하죠? 별 노력 없이 아주 많은 기능을 구현했는데도 코드는 더 깔끔하고 훨씬 Django다워졌습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://raccoonyy.github.io/drf3-tutorial-4"&gt;튜토리얼 4부&lt;/a&gt;에서는 인증과 권한을 API에서 어떻게 다룰지를 살펴보겠습니다.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>2014년에 Django로 개발하면서 실수한 부분</title><description>Joseph Misiti님이 2014년에 Django 개발에서 실수했던 교훈들을 모아서 설명합니다. 1. Postgres를 사용하라. 2. 유닛 테스트를 작성하라. 3. Restful 인터페이스를 지원하라. 4. 모델 필드에 help_text를 넣어라. 6. URL 모듈을...</description><link>http://raccoonyy.github.io/django-development-mistakes-in-2014-translatate/</link><guid isPermaLink="false">59815cfbdd47a80001bb9e9c</guid><category>Django</category><category>translate</category><dc:creator>raccoony</dc:creator><pubDate>Fri, 06 Mar 2015 02:52:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;저 같은 뉴비에게는 꽤나 도움이 되는 가이드여서, 더 잘 이해하고자 번역을 해보았습니다. (이미 &lt;a href="http://www.looah.com/article/view/2025"&gt;looah&lt;/a&gt;에 올렸던 글을 제 블로그로 옮겨와서 포매팅했어요.) 번역을 허락해 준 Joseph Misiti 님께 고마움을 전합니다.&lt;/p&gt;
&lt;p&gt;원문 - &lt;a href="http://medium.com/cs-math/2014-django-development-mistakes-in-2014-f48623f58b21"&gt;Django Development Mistakes in 2014&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2015년이 얼마 남지 않은 시점에, 저는 2014년 동안 개발에 대한 접근법이 어떻게 달라졌는지를 생각해보았습니다. 이전 글(&lt;a href="https://medium.com/cs-math/11-things-i-wish-i-knew-about-django-development-before-i-started-my-company-f29f6080c131"&gt;회사를 시작하기 전 Django에 대해 알았으면 좋았을 11가지 사실&lt;/a&gt;)에서 시작한 목록을 추가할 시점이 된 것이죠.&lt;/p&gt;
&lt;h2 id="1postgresdb"&gt;1. Postgres를 주 DB로 선택하세요&lt;/h2&gt;
&lt;p&gt;네. 제가 이전 글에서 주 DB로 MongoDB를 추천했던 사실을 잘 알고 있습니다. 그런데 1년 반 정도 사용하다 보니 추천하지 않을 이유들이 좀 생겼습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Django 1.7에서도 Django ORM은 여전히 MongoDB를 지원하지 않습니다. Mongoengine나 PyMongo를 사용해야 하죠. 이 두 라이브러리는 훌륭하지만, Django admin 같은 도구를 사용할 수는 없습니다. 이건 정말 끔찍하며, 제가 MongoDB를 주 DB로 사용하지 않게 된 이유이기도 합니다.&lt;/li&gt;
&lt;li&gt;2014년 12월 18일부터 Postgres는 JSONB 데이터 타입을 지원합니다. 이를 통해 Postgres에 &amp;quot;문서&amp;quot;를 저장할 수 있으며, MongoDB에서처럼 비슷하게 쿼리를 실행할 수도 있습니다. 성능 문제를 겪지 않고서도 말이죠.&lt;/li&gt;
&lt;li&gt;(MongoDB를 선택하는 순간) Django ORM을 사용한다고 가정하는 대다수 서드파티 라이브러리가 쓸모 없게 됩니다. 이는 Django의 생태계 대다수를 사용할 수 없다는 의미입니다. Django 생태계는 매우 훌륭하며, 매일 발전하고 있습니다. 이걸 사용할 수 없다니!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSX에서 개발하고 있다면 Postgres 코드를 다운받아 빌드하지 마시고, Postgres 앱(&lt;a href="http://postgresapp.com/"&gt;http://postgresapp.com/&lt;/a&gt;)을 사용하세요. 시간을 많이 절약해줄 겁니다.&lt;/p&gt;
&lt;h2 id="2"&gt;2. 유닛 테스트를 작성하기 쉽게, 유닛 테스트 인프라를 구성하세요.&lt;/h2&gt;
&lt;p&gt;Django와 테스트 주도 개발(TDD) 방식에 대해 수많은 찬반 논쟁이 벌어지고 있습니다. 저는 어느 한 쪽 편을 들 생각은 없지만, 모든 프로젝트에서 유닛 테스트를 작성하기 쉽게(또한 재미있게) 해주는 프레임워크도 구성을 해두려고 노력합니다. 프로젝트에는 먼저, 모든 테스트 케이스에 대해 믹스인처럼 작동하는 클래스를 하나 만듭니다. 이 믹스인을 상속받는 각 유닛 테스트(와 클래스)에는, 테스트용 데이터를 생성할 인스턴스 메서드도 만듭니다. 이러한 가짜 데이터를 만드는 데는 django_faker 프로젝트가 안성맞춤입니다. 데이터는 setUp() 메서드에서 생성된 후, tearDown() 메서드에서 삭제됩니다. 여기에 좀더 관심이 있다면 제 블로그에서 &lt;a href="http://josephmisiti.github.io/unit-testing-best-practices-in-django/"&gt;Django에서의 유닛 테스트&lt;/a&gt;라는 글을 읽어 보세요.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;django_faker 말고 model_mommy나 factory_boy 등도 좋습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="3djangotastypierestful"&gt;3. Django Tastypie를 사용해서 Restful 인터페이스를 만드세요.&lt;/h2&gt;
&lt;p&gt;Ember.js, Backbone.js, Angular.js 등 클라이언트 MVC 프레임워크의 수가 급증하는 시기이므로, 여러분의 웹 애플리케이션에서도 RESTful을 지원하면 좋습니다. Django에서 REST API를 구현한 두 개의 훌륭한 프레임워크가 있는데요, django-rest-framework와 django-tastypie입니다. django-rest-framework가 더 많이 사용되고 있는 것 같지만, 저는 아직 django-tastypie를 사용합니다. 이유는 django-tastypie가 좀더 간명해 보이며, 제가 경험도 많이 해봤기 때문입니다. 하지만 여러분이 공개 API를 만들고 있다면 두말 할 필요 없이 django-rest-framework를 사용하세요. 문서화 기능도 제공됩니다. 혹시나 django-tastypie를 시작해야 한다면 제가 쓴 &lt;a href="http://josephmisiti.github.io/using-django-tastypie-to-create-RESTful-APIs/"&gt;튜토리얼&lt;/a&gt;을 참고하세요.&lt;/p&gt;
&lt;h2 id="4djangohelp_text"&gt;4. 문서화 작업이라고 생각하고, Django 모델 필드의 속성인 help_text를 사용하세요.&lt;/h2&gt;
&lt;p&gt;Django 모델 필드에는 help_text 속성이 존재합니다. 이 속성은 Django의 폼 화면이나 admin 화면에 나타나죠. 설령 폼 화면이나 admin 화면에 사용하지 않는다하더라도 이 속성을 꼭 사용하길 권합니다. 왜냐하면 여러분이 만든 모델의 문서화에도 안성맞춤이거든요. 앞으로 새 개발자를 채용할 예정이라면, help_text 속성이 인수인계에 드는 수많은 시간을 단축시켜 줄 겁니다.&lt;/p&gt;
&lt;h2 id="5urldjangourl"&gt;5. 사용자에게 드러나는 URL에는 쿼리 문자열을 사용하지 말고 Django의 URL 모듈을 적용하세요.&lt;/h2&gt;
&lt;p&gt;웹 개발자들에겐 너무 당연한 사실이겠지만, 어쨌든 저는 url에 더이상 쿼리 문자열을 사용하지 않습니다. 대신 url 파라미터로 전달하죠. Django의 url 디스패처를 사용하여 이렇게 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 다음의 URL은&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.example.com/user?id=20"&gt;https://www.example.com/user?id=20&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음과 같이 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.example.com/user/20/"&gt;https://www.example.com/user/20/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이렇게 하면 컨트롤러에서 타입 검사 같은 코드를 덜 작성해도 됩니다. id 자리에 정수가 없다면 Django의 URL 모듈이 404 HTTP 오류를 던질 테니까요. 간혹 이 규칙을 따르지 못할 사정이 있을 수도 있겠지만, 저는 할 수 있는 한 이 규칙을 따릅니다.&lt;/p&gt;
&lt;h2 id="6djangoormdb"&gt;6. Django ORM으로 DB의 제약 조건을 지정하세요.&lt;/h2&gt;
&lt;p&gt;네, 네, 이제와서 또 언급하기엔 바보 같은 말이죠. 여러분이 DB의 제약 조건을 정확히 지정해 둔다면, 수많은 문제들을 해결할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;null 값을 가질 수 없는 필드에는 null=True를 설정하지 마세요.&lt;/li&gt;
&lt;li&gt;고유한 값을 저장하는 필드들은 unique_together로 지정해주세요.&lt;/li&gt;
&lt;li&gt;unique 파라미터도 적절히 사용해 주세요.&lt;/li&gt;
&lt;li&gt;max_length도 알맞게 지정하세요.&lt;br&gt;
데이터베이스의 스키마를 설계하는 데 공을 들이고, Django ORM을 최대한 사용하세요. 그러면 잘못된 데이터가 저장되는 일은 없을 겁니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="7django_model_utlisdjagno_extensions"&gt;7. 모든 프로젝트에 django_model_utlis와 djagno_extensions를 사용하세요.&lt;/h2&gt;
&lt;p&gt;django-extensions는 settings 출력, shell_plus, 덤프용 스크립트, 암호화 등 굉장한 기능들이 담긴 라이브러리입니다. 저는 이 기능들을 날이 갈수록 더 많이 사용하고 있습니다.&lt;/p&gt;
&lt;p&gt;django-model-utils는 Django ORM에서 지원하지 않거나 구현 방식이 조금 다른 유용한 기능들을 제공합니다. TimeStampField, MonitorField, Choices 등이 있습니다.&lt;/p&gt;
&lt;p&gt;바퀴를 새로 발명하기 전에 이 프로젝트들을 꼭 살펴보세요.&lt;/p&gt;
&lt;h2 id="8sentry"&gt;8. Sentry는 프론트엔드와 백엔드의 오류를 검출하는 데 사용하세요.&lt;/h2&gt;
&lt;p&gt;Sentry는 Django로 만들어진 모니터링용 오픈소스 소프트웨어입니다. getsentry.com에서 비용을 지불하고 사용하는 가입형과 직접 운영하는 설치형으로 나뉩니다. Sentry는 프론트엔트와 백엔드의 오류를 진단하는 데 없어서는 안 될 도구입니다. Sentry로 다음과 같은 유용한 정보들을 추적할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 오류가 몇 번이나 발생했었나&lt;/li&gt;
&lt;li&gt;브라우저 정보&lt;/li&gt;
&lt;li&gt;시간/지역에 따른 발생 빈도&lt;/li&gt;
&lt;li&gt;500 오류 등의 스택 트레이스(stack traces)&lt;/li&gt;
&lt;li&gt;404/403 오류&lt;/li&gt;
&lt;li&gt;프론트엔드 자바스크립트의 undefines 오류&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가입형은 한 달에 $24부터 시작하며, 이 돈을 낼 만한 가치가 충분합니다.&lt;/p&gt;
&lt;h2 id="9djangodebugtoolbar"&gt;9. 최적화와 디버깅에는 django-debug-toolbar를 사용하세요.&lt;/h2&gt;
&lt;p&gt;django-debug-toolbar는 놀라운 디버깅 도구입니다. 성능에 문제가 있는 SQL 쿼리와 요청, 템플릿, 캐시 등을 모두 추적할 수 있습니다. 저는 미리부터 최적화를 시도하는 편이 아니지만, 뭔가 느려졌다 싶을 땐 django-debug-toolbar가 문제점을 찾도록 도와줄 겁니다. 이 프로젝트에 대해 더 알고 싶다면 &lt;a href="http://josephmisiti.github.io/unit-testing-best-practices-in-django/"&gt;Unit Testing Best Practices in Django&lt;/a&gt;를 읽어 보세요.&lt;/p&gt;
&lt;h2 id="10djangouser"&gt;10. Django의 커스텀 User 모델을 첫 번째 커밋부터 도입하세요.&lt;/h2&gt;
&lt;p&gt;Django의 기본 User 모델을 사용하기보다는 Django 1.6에서 도입된 &lt;a href="https://docs.djangoproject.com/en/1.7/topics/auth/customizing/"&gt;커스텀 User 모델&lt;/a&gt;을 사용하길 적극 권합니다. User 모델에 필드를 추가할 때도 기존의 방법(기본 User 모델과 OneToOne으로 엮인 새 모델을 만드는 방법)보다 직관적입니다. Django를 이미 사용하고 있다면 기본 User 모델의 email과 username 필드가 30 글자로 제한되어서 답답했을 겁니다. 커스텀 User 모델을 도입하면 이런 문제들이 모두 해결됩니다. 기본 User 모델을 커스텀 User 모델로 마이그레이션할 수도 있겠지만 재미는 없을 겁니다. 제 말을 명심하세요.&lt;/p&gt;
&lt;h2 id="11djangoadmin"&gt;11. Django admin에 대체품을 도입해보세요.&lt;/h2&gt;
&lt;p&gt;Django의 admin은 훌륭하지만, 겉모습은 철 지난 디자인입니다. 외주 일을 맡아서 진행했다면 admin 화면을 좀더 전문가 답게 바꿔줄 도구들이 있습니다. 저는 django-grapelli와 django-suit를 애용합니다. 더 많은 목록은 다음 &lt;a href="https://github.com/rosarior/awesome-django#admin-interface"&gt;링크&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;p&gt;저는 Django와 머신 러닝에 대해 블로깅합니다. 이 주제에 관심이 있다면 제 트위터 계정 @josephmisiti를 follow해주세요.&lt;/p&gt;
&lt;p&gt;Django나 머신 러닝 관련 업무를 도와드립니다. 컨설팅도 가능합니다. Math &amp;amp; Pencil 홈페이지를 참고하세요.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>DRF3 튜토리얼 1 - 직렬화</title><description>(django-rest-framework 공식 문서를 번역함) 이 튜토리얼에서는 pastebin 같이 간단한 코드 하이라이팅 웹 API를 만들어 보겠습니다. 이와 함께 REST 프레임워크의 다양한 기능을 살펴보고, 이런 기능들이 어떻게 서로 어울려 작동하는지도 설명하겠습니다.</description><link>http://raccoonyy.github.io/drf3-tutorial-1/</link><guid isPermaLink="false">59815cfbdd47a80001bb9e99</guid><category>django rest framework 3</category><category>DRF3</category><category>serialization</category><category>translate</category><category>Django</category><dc:creator>raccoony</dc:creator><pubDate>Thu, 05 Mar 2015 13:30:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" alt="DRF3 튜토리얼 1 - 직렬화"&gt;&lt;p&gt;원문 - &lt;a href="http://www.django-rest-framework.org/tutorial/1-serialization/"&gt;Tutorial 1: Serialization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 &lt;a href="https://twitter.com/_tomchristie"&gt;Tom Christie&lt;/a&gt;에게 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="1serialization"&gt;튜토리얼 1: Serialization&lt;/h1&gt;
&lt;h2 id=""&gt;개요&lt;/h2&gt;
&lt;p&gt;이 튜토리얼에서는 pastebin 같이 간단한 코드 하이라이팅 웹 API를 만들어 보겠습니다. 이와 함께 REST 프레임워크의 다양한 기능을 살펴보고, 이런 기능들이 어떻게 서로 어울려 작동하는지도 설명하겠습니다.&lt;/p&gt;
&lt;p&gt;이 튜토리얼은 꽤 길기 때문에 쿠키와 음료를 옆에 준비해두기를 권합니다. 그저 슬쩍 훑어보고만 싶다면 &lt;a href="http://raccoonyy.github.io/django-rest-framework-3-quickstart/"&gt;훑어보기&lt;/a&gt; 문서를 보세요.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;안내:&lt;/strong&gt; 이 튜토리얼에서 사용하는 코드는 GitHub에 있는 저장소(&lt;a href="https://github.com/tomchristie/rest-framework-tutorial"&gt;tomchristie/rest-framework-tutorial&lt;/a&gt;)에서 확인할 수 있습니다. 전체 코드를 구현한 데모 버전은 &lt;a href="http://restframework.herokuapp.com/"&gt;여기서&lt;/a&gt; 확인할 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=""&gt;새 가상 환경 만들기&lt;/h2&gt;
&lt;p&gt;뭔가를 하기 전에 virtualenv를 사용하여 가상 환경을 만듭시다. 이를 통해 패키지 설정을 독립적으로 관리할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;virtualenv env
source env/bin/activate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;가상 환경 안에서 다음과 같은 패키지를 설치합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install django
pip install djangorestframework
pip install pygments  # 코드 하일라이팅에 사용할 패키지입니다
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;안내:&lt;/strong&gt; 가상 환경에서 벗어나고 싶다면 &lt;code&gt;deactivate&lt;/code&gt;를 입력하면 됩니다. 더 자세한 내용은 &lt;a href="http://www.virtualenv.org/en/latest/index.html"&gt;virtualenv 문서&lt;/a&gt;에서 확인하세요.&lt;/p&gt;
&lt;h2 id=""&gt;시작하기&lt;/h2&gt;
&lt;p&gt;자, 이제 코드를 작성해 봅시다. 우선 새 프로젝트를 만듭니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;cd ~
django-admin.py startproject tutorial
cd tutorial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 웹 API를 위한 앱을 하나 생성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python manage.py startapp snippets
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;방금 만든 &lt;code&gt;snippets&lt;/code&gt; 앱 외에 &lt;code&gt;rest_framework&lt;/code&gt; 앱도 &lt;code&gt;INSTALLED_APPS&lt;/code&gt;에 추가해야 합니다. &lt;code&gt;tutorial/settings.py&lt;/code&gt; 파일을 수정하세요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;INSTALLED_APPS = (
    ...
    'rest_framework',
    'snippets',
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;URL도 설정해야 합니다. &lt;code&gt;tutorial/urls.py&lt;/code&gt; 파일에 snippet 앱의 URL을 추가합시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;urlpatterns = [
    url(r'^', include('snippets.urls')),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 준비 과정은 끝났습니다.&lt;/p&gt;
&lt;h2 id=""&gt;모델 만들기&lt;/h2&gt;
&lt;p&gt;이 튜토리얼에서 사용할 간단한 &lt;code&gt;Snippet&lt;/code&gt; 모델을 만듭시다. 이 모델에는 코드 조각들이 저장됩니다. &lt;code&gt;snippets/models.py&lt;/code&gt; 파일을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;안내:&lt;/strong&gt; 코드 주석을 작성하는 것은 좋은 프로그래밍 습관입니다. 우리가 제공하는 저장소의 코드에서도 코드 주석을 볼 수 있을 겁니다. 하지만 여기서는 코드에 집중하기 위해 주석을 제거했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.db import models
from pygments.lexers import get_all_lexers
from pygments.styles import get_all_styles

LEXERS = [item for item in get_all_lexers() if item[1]]
LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS])
STYLE_CHOICES = sorted((item, item) for item in get_all_styles())


class Snippet(models.Model):
    created = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=100, blank=True, default='')
    code = models.TextField()
    linenos = models.BooleanField(default=False)
    language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100)
    style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100)

    class Meta:
        ordering = ('created',)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;snippet 모델을 초기화할 마이그레이션을 만들어야 하고, 데이터베이스에 처음으로 싱크도 해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python manage.py makemigrations snippets
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=""&gt;시리얼라이저 클래스 만들기&lt;/h2&gt;
&lt;p&gt;웹 API를 만들려면 우선 Snippet 클래스의 인스턴스를 &lt;code&gt;json&lt;/code&gt; 같은 형태로 직렬화(serializing)하거나 반직렬화(deserializing)할 수 있어야 합니다. Django REST 프레임워크에서는 Django 폼과 비슷한 방식으로 시리얼라이저를 작성합니다. &lt;code&gt;snippets/serializers.py&lt;/code&gt; 파일을 만들고 다음과 같은 내용을 작성합시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.forms import widgets
from rest_framework import serializers
from snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICES


class SnippetSerializer(serializers.Serializer):
    pk = serializers.IntegerField(read_only=True)
    title = serializers.CharField(required=False, allow_blank=True, max_length=100)
    code = serializers.CharField(style={'base_template': 'textarea.html'})
    linenos = serializers.BooleanField(required=False)
    language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python')
    style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly')

    def create(self, validated_data):
        &amp;quot;&amp;quot;&amp;quot;
        검증한 데이터로 새 `Snippet` 인스턴스를 생성하여 리턴합니다.
        &amp;quot;&amp;quot;&amp;quot;
        return Snippet.objects.create(**validated_data)

    def update(self, instance, validated_data):
        &amp;quot;&amp;quot;&amp;quot;
        검증한 데이터로 기존 `Snippet` 인스턴스를 업데이트한 후 리턴합니다.
        &amp;quot;&amp;quot;&amp;quot;
        instance.title = validated_data.get('title', instance.title)
        instance.code = validated_data.get('code', instance.code)
        instance.linenos = validated_data.get('linenos', instance.linenos)
        instance.language = validated_data.get('language', instance.language)
        instance.style = validated_data.get('style', instance.style)
        instance.save()
        return instance
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;시리얼라이저 클래스의 윗부분에서는 직렬화/반직렬화될 필드를 선언했습니다. &lt;code&gt;create()&lt;/code&gt; 메서드와 &lt;code&gt;update()&lt;/code&gt; 메서드에서는 &lt;code&gt;serializer.save()&lt;/code&gt;가 호출되었을 때 인스턴스가 생성 혹은 수정되는 과정을 전부 명시하고 있습니다.&lt;/p&gt;
&lt;p&gt;시리얼라이저 클래스는 Django의 &lt;code&gt;Form&lt;/code&gt; 클래스와 매우 비슷하며, &lt;code&gt;required&lt;/code&gt;나 &lt;code&gt;max_length&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt; 같이 &lt;code&gt;Form&lt;/code&gt; 클래스에서 사용하던 값 검증을 위한 옵션도 필드에 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 옵션들을 통해 특정 상황 - 예를 들면 HTML로 렌더링한다든지 - 에 시리얼라이저가 어떻게 작동해야 하는지를 명시할 수 있습니다. 앞선 코드의 &lt;code&gt;{'base_template': 'textarea.html'}&lt;/code&gt; 부분은 Django &lt;code&gt;Form&lt;/code&gt;의 &lt;code&gt;widget=widgets.Textarea&lt;/code&gt;과 같습니다. 탐색가능한 API를 만들 때 이런 기능이 얼마나 유용한지는 차차 알아보겠습니다.&lt;/p&gt;
&lt;p&gt;사실, 나중에 살펴 볼 &lt;code&gt;ModelSerializer&lt;/code&gt; 클래스를 사용하면 이러한 기능을 일일이 구현하지 않아도 되지만 일단은 명시적인 시리얼라이저를 만들어 봅시다.&lt;/p&gt;
&lt;h2 id=""&gt;시리얼라이저 사용하기&lt;/h2&gt;
&lt;p&gt;진도를 나아가기에 앞서, 우리가 만든 시리얼라이저 클래스에 조금 익숙해져 봅시다. Django 셸을 띄우세요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python manage.py shell
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;필요한 패키지들을 import하고 나서, 코드 조각(Snippet 클래스의 인스턴스)을 만들어 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from snippets.models import Snippet
from snippets.serializers import SnippetSerializer
from rest_framework.renderers import JSONRenderer
from rest_framework.parsers import JSONParser

snippet = Snippet(code='foo = &amp;quot;bar&amp;quot;\n')
snippet.save()

snippet = Snippet(code='print &amp;quot;hello, world&amp;quot;\n')
snippet.save()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;snippet 인스턴스가 만들어졌으니, 이 인스턴스 중 하나를 직렬화해보죠.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;serializer = SnippetSerializer(snippet)
serializer.data
# {'pk': 2, 'title': u'', 'code': u'print &amp;quot;hello, world&amp;quot;\n', 'linenos': False, 'language': u'python', 'style': u'friendly'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서는 모델 인스턴스를 파이썬의 데이터 타입으로 변환했는데요. 직렬화 과정을 마무리하려면 이 데이터를 &lt;code&gt;json&lt;/code&gt;으로 변환해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;content = JSONRenderer().render(serializer.data)
content
# '{&amp;quot;pk&amp;quot;: 2, &amp;quot;title&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;code&amp;quot;: &amp;quot;print \\&amp;quot;hello, world\\&amp;quot;\\n&amp;quot;, &amp;quot;linenos&amp;quot;: false, &amp;quot;language&amp;quot;: &amp;quot;python&amp;quot;, &amp;quot;style&amp;quot;: &amp;quot;friendly&amp;quot;}'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;반직렬화도 이와 비슷합니다. 먼저, 파이썬 데이터 타입을 파싱합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.utils.six import BytesIO

stream = BytesIO(content)
data = JSONParser().parse(stream)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 이 데이터를 인스턴스화합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;serializer = SnippetSerializer(data=data)
serializer.is_valid()
# True
serializer.validated_data
# OrderedDict([('title', ''), ('code', 'print &amp;quot;hello, world&amp;quot;\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])
serializer.save()
# &amp;lt;Snippet: Snippet object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;폼을 다루는 방식과 많이 비슷하죠? 뷰를 작성할 때뿐만 아니라 시리얼라이저를 사용하는 방식도 폼을 다루는 방식과 유사합니다.&lt;/p&gt;
&lt;p&gt;모델의 인스턴스뿐만 아니라 쿼리셋도 직렬화할 수 있습니다. 시리얼라이저의 인자에 &lt;code&gt;many=True&lt;/code&gt;만 추가하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;serializer = SnippetSerializer(Snippet.objects.all(), many=True)
serializer.data
# [{'pk': 1, 'title': u'', 'code': u'foo = &amp;quot;bar&amp;quot;\n', 'linenos': False, 'language': u'python', 'style': u'friendly'}, {'pk': 2, 'title': u'', 'code': u'print &amp;quot;hello, world&amp;quot;\n', 'linenos': False, 'language': u'python', 'style': u'friendly'}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="modelserializers"&gt;ModelSerializers 사용하기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SnippetSerializer&lt;/code&gt; 클래스는 &lt;code&gt;Snippet&lt;/code&gt; 모델의 정보들을 그대로 베낍니다. 이런 특징을 살려 코드를 좀더 간단하게 줄여 보겠습니다.&lt;/p&gt;
&lt;p&gt;Django에서 &lt;code&gt;Form&lt;/code&gt; 클래스와 &lt;code&gt;ModelForm&lt;/code&gt; 클래스를 제공하듯, REST 프레임워크에서도 &lt;code&gt;Serializer&lt;/code&gt; 클래스와 &lt;code&gt;ModelSerializer&lt;/code&gt; 클래스를 제공합니다.&lt;/p&gt;
&lt;p&gt;우리가 만든 시리얼라이저가 &lt;code&gt;ModelSerializer&lt;/code&gt; 클래스를 사용하도록 리팩터링해 봅시다. &lt;code&gt;snippets/serializers.py&lt;/code&gt; 파일을 열고 &lt;code&gt;SnippetSerializer&lt;/code&gt; 클래스 부분을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SnippetSerializer(serializers.ModelSerializer):
    class Meta:
        model = Snippet
        fields = ('id', 'title', 'code', 'linenos', 'language', 'style')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 시리얼라이저에 프로퍼티 하나만 정의한 후 시리얼라이저 인스턴스를 출력해보면 모든 필드를 확인할 수 있습니다. &lt;code&gt;python manage.py shell&lt;/code&gt; 명령으로 Django 셸을 열어 다음과 같이 해보세요.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from snippets.serializers import SnippetSerializer
&amp;gt;&amp;gt;&amp;gt; serializer = SnippetSerializer()
&amp;gt;&amp;gt;&amp;gt; print(repr(serializer))
SnippetSerializer():
    id = IntegerField(label='ID', read_only=True)
    title = CharField(allow_blank=True, max_length=100, required=False)
    code = CharField(style={'base_template': 'textarea.html'})
    linenos = BooleanField(required=False)
    language = ChoiceField(choices=[('Clipper', 'FoxPro'), ('Cucumber', 'Gherkin'), ('RobotFramework', 'RobotFramework'), ('abap', 'ABAP'), ('ada', 'Ada')...
    style = ChoiceField(choices=[('autumn', 'autumn'), ('borland', 'borland'), ('bw', 'bw'), ('colorful', 'colorful')...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ModelSerializer&lt;/code&gt; 클래스가 마법을 부리는 도구는 아닙니다. 그저 시리얼라이저 클래스의 단축 버전일 뿐이죠.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;필드를 자동으로 인식한다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;create()&lt;/code&gt; 메서드와 &lt;code&gt;update()&lt;/code&gt; 메서드가 이미 구현되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="django"&gt;시리얼라이저를 사용하는 Django 뷰 만들기&lt;/h2&gt;
&lt;p&gt;이제, 앞에서 새로 만든 시리얼라이저 클래스를 뷰에서 어떻게 사용할 수 있는지 보여드리겠습니다.&lt;br&gt;
지금 당장은 REST 프레임워크의 기능을 사용하지 않고, 일반적인 Django 뷰의 형태로 만들겠습니다.&lt;/p&gt;
&lt;p&gt;HttpResponse의 하위 클래스를 만들고, 받은 데이터를 모두 &lt;code&gt;json&lt;/code&gt; 형태로 반환합시다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;snippets/views.py&lt;/code&gt; 파일을 열고 다음 내용을 입력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.renderers import JSONRenderer
from rest_framework.parsers import JSONParser
from snippets.models import Snippet
from snippets.serializers import SnippetSerializer

class JSONResponse(HttpResponse):
    &amp;quot;&amp;quot;&amp;quot;
    콘텐츠를 JSON으로 변환한 후 HttpResponse 형태로 반환합니다.
    &amp;quot;&amp;quot;&amp;quot;
    def __init__(self, data, **kwargs):
        content = JSONRenderer().render(data)
        kwargs['content_type'] = 'application/json'
        super(JSONResponse, self).__init__(content, **kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우리가 만들 API의 최상단에서는 저장된 코드 조각을 모두 보여주며, 새 코드 조각을 만들 수도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@csrf_exempt
def snippet_list(request):
    &amp;quot;&amp;quot;&amp;quot;
    코드 조각을 모두 보여주거나 새 코드 조각을 만듭니다.
    &amp;quot;&amp;quot;&amp;quot;
    if request.method == 'GET':
        snippets = Snippet.objects.all()
        serializer = SnippetSerializer(snippets, many=True)
        return JSONResponse(serializer.data)

    elif request.method == 'POST':
        data = JSONParser().parse(request)
        serializer = SnippetSerializer(data=data)
        if serializer.is_valid():
            serializer.save()
            return JSONResponse(serializer.data, status=201)
        return JSONResponse(serializer.errors, status=400)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;인증되지 않은 사용자도 이 뷰에 POST를 할 수 있도록 &lt;code&gt;csrf_exempt&lt;/code&gt; 데코레이터를 적어둔 점을 눈여겨 보시기 바랍니다. 이는 보통의 경우 필요 없을 수도 있고 REST 프레임워크의 뷰가 이보다 더 정밀한 속성들을 제공하기도 하지만, 일단 여기서는 우리가 구현하고 싶은 기능을 &lt;code&gt;csrf_exempt&lt;/code&gt;가 잘 담당하고 있습니다.&lt;/p&gt;
&lt;p&gt;이제 코드 조각 하나를 보여줄 뷰도 필요합니다. 또 이 코드 조각을 업데이트하거나 삭제할 수도 있어야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@csrf_exempt
def snippet_detail(request, pk):
    &amp;quot;&amp;quot;&amp;quot;
    코드 조각 조회, 업데이트, 삭제
    &amp;quot;&amp;quot;&amp;quot;
    try:
        snippet = Snippet.objects.get(pk=pk)
    except Snippet.DoesNotExist:
        return HttpResponse(status=404)

    if request.method == 'GET':
        serializer = SnippetSerializer(snippet)
        return JSONResponse(serializer.data)

    elif request.method == 'PUT':
        data = JSONParser().parse(request)
        serializer = SnippetSerializer(snippet, data=data)
        if serializer.is_valid():
            serializer.save()
            return JSONResponse(serializer.data)
        return JSONResponse(serializer.errors, status=400)

    elif request.method == 'DELETE':
        snippet.delete()
        return HttpResponse(status=204)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;마지막으로 이 뷰들과 URL을 연결합시다. &lt;code&gt;snippets/urls.py&lt;/code&gt; 파일을 만들고 다음 내용을 입력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from django.conf.urls import url
from snippets import views

urlpatterns = [
    url(r'^snippets/$', views.snippet_list),
    url(r'^snippets/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', views.snippet_detail),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 다루지 않은 특별한 경우들은 그냥 무시하고 지나갑시다. &lt;code&gt;json&lt;/code&gt;의 내용이 깨졌거나 뷰가 처리할 수 없는 메서드 요청인 경우, '500 서버 오류'를 보게 될 겁니다. 그렇지만 일단은 그냥 둡시다.&lt;/p&gt;
&lt;h2 id="api"&gt;첫 번째 웹 API 테스트하기&lt;/h2&gt;
&lt;p&gt;이제 코드 조각을 보여주는 서버를 구동해 봅시다.&lt;/p&gt;
&lt;p&gt;셸에서 빠져나가,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Django의 개발 서버를 띄웁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python manage.py runserver

Validating models...

0 errors found
Django version 1.4.3, using settings 'tutorial.settings'
Development server is running at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다른 터미널 창에서 서버를 테스트합시다.&lt;br&gt;
테스트에는 &lt;a href="http://curl.haxx.se"&gt;curl&lt;/a&gt;이나 &lt;a href="https://github.com/jakubroztocil/httpie#installation"&gt;httpie&lt;/a&gt;를 사용할 수 있습니다. Httpie는 파이썬으로 작성된 사용자 친화적인 http 클라이언트입니다. 설치해 보죠.&lt;/p&gt;
&lt;p&gt;httpie는 pip로 설치하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install httpie
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;마지막으로 코드 조각 전체를 가져와 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;http http://127.0.0.1:8000/snippets/

HTTP/1.1 200 OK
...
[
  {
    &amp;quot;id&amp;quot;: 1,
    &amp;quot;title&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;code&amp;quot;: &amp;quot;foo = \&amp;quot;bar\&amp;quot;\n&amp;quot;,
    &amp;quot;linenos&amp;quot;: false,
    &amp;quot;language&amp;quot;: &amp;quot;python&amp;quot;,
    &amp;quot;style&amp;quot;: &amp;quot;friendly&amp;quot;
  },
  {
    &amp;quot;id&amp;quot;: 2,
    &amp;quot;title&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;code&amp;quot;: &amp;quot;print \&amp;quot;hello, world\&amp;quot;\n&amp;quot;,
    &amp;quot;linenos&amp;quot;: false,
    &amp;quot;language&amp;quot;: &amp;quot;python&amp;quot;,
    &amp;quot;style&amp;quot;: &amp;quot;friendly&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id를 지정하여 특정 코드 조각만 가져올 수도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;http http://127.0.0.1:8000/snippets/2/

HTTP/1.1 200 OK
...
{
  &amp;quot;id&amp;quot;: 2,
  &amp;quot;title&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;code&amp;quot;: &amp;quot;print \&amp;quot;hello, world\&amp;quot;\n&amp;quot;,
  &amp;quot;linenos&amp;quot;: false,
  &amp;quot;language&amp;quot;: &amp;quot;python&amp;quot;,
  &amp;quot;style&amp;quot;: &amp;quot;friendly&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;웹 브라우저에서도 똑같은 json 데이터를 확인하실 수 있을 겁니다.&lt;/p&gt;
&lt;h2 id=""&gt;지금 어디까지 왔을까요?&lt;/h2&gt;
&lt;p&gt;지금까지 잘 해 왔습니다. 시리얼라이저 API를 만들 땐 Django 폼 API나 일반적인 Django 뷰와 비슷하다고 느꼈을 겁니다.&lt;/p&gt;
&lt;p&gt;우리가 만든 API 뷰는 아직까진 &lt;code&gt;json&lt;/code&gt;을 응답하는 일 외에는 별다른 일을 하지 않으며, 몇몇 경우에는 (웹 API의 기능임에도) 에러도 발생하고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://raccoonyy.github.io/drf3-tutorial-2"&gt;튜토리얼 2부&lt;/a&gt;에서는 API를 개선해보겠습니다.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Django Rest Framework 3 훑어보기</title><description>Django Rest Framework 3을 이해해 보고자 튜토리얼 문서를 번역하고 있습니다. 의역이 난무하지만 기술적으로 잘못된 내용을 전달하지 않게 최선을 다해보겠습니다. ----
관리자 계정으로 사용자를 관리하는 간단한 API를 만들어 보겠습니다.</description><link>http://raccoonyy.github.io/django-rest-framework-3-quickstart/</link><guid isPermaLink="false">59815cfbdd47a80001bb9e98</guid><category>django rest framework 3</category><category>DRF3</category><category>quickstart</category><category>translate</category><category>Django</category><dc:creator>raccoony</dc:creator><pubDate>Wed, 04 Mar 2015 15:01:00 GMT</pubDate><media:content url="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" medium="image"/><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;img src="http://raccoonyy.github.io/content/images/2015/12/drf-logo.png" alt="Django Rest Framework 3 훑어보기"&gt;&lt;p&gt;Django Rest Framework 3을 이해해 보고자 튜토리얼 문서를 번역하고 있습니다. 의역이 난무하지만 기술적으로 잘못된 내용을 전달하지 않게 최선을 다해보겠습니다.&lt;/p&gt;
&lt;p&gt;원문 - &lt;a href="http://www.django-rest-framework.org/tutorial/quickstart/"&gt;QuickStart Guide with Django Rest Framework3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;번역을 허락해 준 &lt;a href="https://twitter.com/_tomchristie"&gt;Tom Christie&lt;/a&gt;에게 고마움을 전합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=""&gt;훑어보기&lt;/h1&gt;
&lt;p&gt;이제부터 관리자 계정으로 사용자를 관리하는 간단한 API를 만들어 보겠습니다.&lt;/p&gt;
&lt;h2 id=""&gt;프로젝트 설정&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tutorial&lt;/code&gt;이라는 이름으로 새로운 Django 프로젝트를 만든 다음 &lt;code&gt;quickstart&lt;/code&gt; 앱을 생성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;# 프로젝트용 디렉터리를 만듭니다
mkdir tutorial
cd tutorial

# 패키지 환경을 독립적으로 관리하기 위해 가상 환경을 생성합니다
virtualenv env
source env/bin/activate  # On Windows use `env\Scripts\activate`

# Django와 Django REST framework를 가상 환경에 설치합니다
pip install django
pip install djangorestframework

# 프로젝트와 앱을 생성합니다
django-admin.py startproject tutorial .  # 마지막에 있는 .을 꼭 입력하세요
cd tutorial
django-admin.py startapp quickstart
cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 처음으로 데이터베이스를 생성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;관리자 계정으로 사용할 아이디와 비밀번호도 만들죠. 나중에 이 계정으로 인증을 할 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;python manage.py createsuperuser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자, 이제 준비를 마쳤으니 코딩을 해봅시다.&lt;/p&gt;
&lt;h2 id=""&gt;시리얼라이저&lt;/h2&gt;
&lt;p&gt;시리얼라이저부터 만들어보죠. &lt;code&gt;tutorial/quickstart/serializers.py&lt;/code&gt; 파일을 만듭시다. 데이터를 표현하는 데 사용할 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;from django.contrib.auth.models import User, Group
from rest_framework import serializers


class UserSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = User
        fields = ('url', 'username', 'email', 'groups')


class GroupSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Group
        fields = ('url', 'name')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하이퍼링크 관계를 위해 &lt;code&gt;HyperlinkedModelSerializer&lt;/code&gt;를 사용한 것을 눈여겨 보세요. 물론 주 키(primary key)나 다른 방법으로도 관계를 연결할 수 있겠지만, 하이퍼링크야말로 RESTful 디자인에 잘 어울립니다.&lt;/p&gt;
&lt;h2 id=""&gt;뷰&lt;/h2&gt;
&lt;p&gt;좋습니다. 이제 뷰를 만들죠. &lt;code&gt;tutorial/quickstart/views.py&lt;/code&gt; 파일을 다음과 같이 작성합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;from django.contrib.auth.models import User, Group
from rest_framework import viewsets
from tutorial.quickstart.serializers import UserSerializer, GroupSerializer


class UserViewSet(viewsets.ModelViewSet):
    &amp;quot;&amp;quot;&amp;quot;
    사용자(user)를 보거나 편집하는 API
    &amp;quot;&amp;quot;&amp;quot;
    queryset = User.objects.all()
    serializer_class = UserSerializer


class GroupViewSet(viewsets.ModelViewSet):
    &amp;quot;&amp;quot;&amp;quot;
    그룹(group)을 보거나 편집하는 API
    &amp;quot;&amp;quot;&amp;quot;
    queryset = Group.objects.all()
    serializer_class = GroupSerializer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;뷰를 여러 번 작성하기보다는 자주 사용되는 기능들을 묶은 ViewSet 클래스를 사용했습니다.&lt;/p&gt;
&lt;p&gt;물론 필요에 따라 뷰를 잘게 나눌 수도 있습니다. 하지만 뷰셋(viewset)을 사용하면 뷰 로직을 아주 간결하고 체계적으로 유지할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.django-rest-framework.org/#example"&gt;문서의 제일 처음&lt;/a&gt;에 보여드렸던 클래스에서는 &lt;code&gt;model&lt;/code&gt; 속성 대신 &lt;code&gt;queryset&lt;/code&gt;과 &lt;code&gt;serializer_class&lt;/code&gt; 속성을 사용했는데요.&lt;/p&gt;
&lt;p&gt;일반적인 경우 ViewSet 클래스에 &lt;code&gt;model&lt;/code&gt; 속성만 설정하면 &lt;code&gt;serializer&lt;/code&gt;와 &lt;code&gt;queryset&lt;/code&gt;은 자동으로 설정됩니다. &lt;code&gt;queryset&lt;/code&gt;이나 &lt;code&gt;serializer_class&lt;/code&gt; 속성을 설정하면 API의 행동을 좀더 명시적으로 표현할 수 있는데 대다수 애플리케이션에서는 이렇게 하기를 권장합니다.&lt;/p&gt;
&lt;h2 id="url"&gt;URL&lt;/h2&gt;
&lt;p&gt;자 이제 API URL을 연결해봅시다. &lt;code&gt;tutorial/urls.py&lt;/code&gt; 파일입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;from django.conf.urls import url, include
from rest_framework import routers
from tutorial.quickstart import views

router = routers.DefaultRouter()
router.register(r'users', views.UserViewSet)
router.register(r'groups', views.GroupViewSet)

# 우리가 만든 API를 자동으로 라우팅합니다.
# 그리고 API 탐색을 위해 로그인 URL을 추가했습니다.
urlpatterns = [
    url(r'^', include(router.urls)),
    url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;뷰 대신 뷰셋을 사용한 덕에, 뷰셋의 라우터(router) 클래스를 통해 API에 대한 URL이 자동으로 생성됩니다.&lt;/p&gt;
&lt;p&gt;여기서도 역시, API URL을 여러분 마음대로 설정하고 싶다면 여러분이 직접 만든 클래스 기반 뷰(class based view)에 URL을 연결하면 되겠습니다.&lt;/p&gt;
&lt;p&gt;마지막으로 탐색친화적(browseable)인 API를 만들기 위해 기본 로그인/로그아웃 뷰를 추가했습니다. 반드시 추가해야 하는 건 아니자만 여러분의 API가 인증 후 API 탐색을 허용하는 경우에는 유용하게 사용할 수 있겠습니다.&lt;/p&gt;
&lt;h2 id=""&gt;설정&lt;/h2&gt;
&lt;p&gt;전역 변수를 몇 개 설정해 봅시다. 페이지 기능을 켜고, API에는 관리자 계정만 접근하도록 합시다. &lt;code&gt;tutorial/settings.py&lt;/code&gt; 파일에 다음 내용을 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-python"&gt;INSTALLED_APPS = (
    ...
    'rest_framework',
)

REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': ('rest_framework.permissions.IsAdminUser',),
    'PAGINATE_BY': 10
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;네, 이제 끝났습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="api"&gt;API 테스트하기&lt;/h2&gt;
&lt;p&gt;지금까지 만든 API를 테스트해 봅시다. 명령창에서 서버를 실행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;python ./manage.py runserver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 명령창에서 (curl 명령 등으로) API에 접근할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;bash: curl -H 'Accept: application/json; indent=4' -u admin:password http://127.0.0.1:8000/users/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-language-json"&gt;{
    &amp;quot;count&amp;quot;: 2,
    &amp;quot;next&amp;quot;: null,
    &amp;quot;previous&amp;quot;: null,
    &amp;quot;results&amp;quot;: [
        {
            &amp;quot;email&amp;quot;: &amp;quot;admin@example.com&amp;quot;,
            &amp;quot;groups&amp;quot;: [],
            &amp;quot;url&amp;quot;: &amp;quot;http://127.0.0.1:8000/users/1/&amp;quot;,
            &amp;quot;username&amp;quot;: &amp;quot;admin&amp;quot;
        },
        {
            &amp;quot;email&amp;quot;: &amp;quot;tom@example.com&amp;quot;,
            &amp;quot;groups&amp;quot;: [                ],
            &amp;quot;url&amp;quot;: &amp;quot;http://127.0.0.1:8000/users/2/&amp;quot;,
            &amp;quot;username&amp;quot;: &amp;quot;tom&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;httpie 같은 도구를 사용해도 좋습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-language-bash"&gt;bash: http -a username:password http://127.0.0.1:8000/users/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-language-json"&gt;HTTP/1.1 200 OK
...
{
    &amp;quot;count&amp;quot;: 2,
    &amp;quot;next&amp;quot;: null,
    &amp;quot;previous&amp;quot;: null,
    &amp;quot;results&amp;quot;: [
        {
            &amp;quot;email&amp;quot;: &amp;quot;admin@example.com&amp;quot;,
            &amp;quot;groups&amp;quot;: [],
            &amp;quot;url&amp;quot;: &amp;quot;http://localhost:8000/users/1/&amp;quot;,
            &amp;quot;username&amp;quot;: &amp;quot;paul&amp;quot;
        },
        {
            &amp;quot;email&amp;quot;: &amp;quot;tom@example.com&amp;quot;,
            &amp;quot;groups&amp;quot;: [                ],
            &amp;quot;url&amp;quot;: &amp;quot;http://127.0.0.1:8000/users/2/&amp;quot;,
            &amp;quot;username&amp;quot;: &amp;quot;tom&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아니면 웹 브라우저에서 봐도 되죠.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://www.django-rest-framework.org/img/quickstart.png" alt="Django Rest Framework 3 훑어보기"&gt;&lt;/p&gt;
&lt;p&gt;웹 브라우저를 사용한다면 오른쪽 상단의 버튼을 눌러 로그인을 해야 할 겁니다.&lt;/p&gt;
&lt;p&gt;좋습니다. 쉽죠?&lt;/p&gt;
&lt;p&gt;REST 프레임워크가 어떻게 작동하는지 더 알고 싶다면, &lt;a href="http://raccoonyy.github.io/drf3-tutorial-1"&gt;다음 튜토리얼&lt;/a&gt;을 계속 읽어가든지 &lt;a href="http://www.django-rest-framework.org/#api-guide"&gt;API 가이드&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss></html>